// /// Generated by mat_flutter, please don't edit! Created time: 2023-03-09 00:16:01.417697

library;

import 'package:flutter/src/foundation/key.dart';
import 'dart:ui';
import 'package:flutter/src/widgets/framework.dart';
import 'dart:core';
import 'package:flutter/src/rendering/custom_paint.dart';
import 'package:flutter/src/rendering/proxy_box.dart';
import 'package:flutter/src/painting/border_radius.dart';
import 'package:flutter/src/painting/box_border.dart';
import 'package:vector_math/vector_math_64.dart';
import 'package:flutter/src/painting/alignment.dart';
import 'package:flutter/src/rendering/layer.dart';
import 'package:flutter/src/painting/box_fit.dart';
import 'package:flutter/src/painting/edge_insets.dart';
import 'package:flutter/src/rendering/shifted_box.dart';
import 'package:flutter/src/rendering/custom_layout.dart';
import 'package:flutter/src/rendering/box.dart';
import 'package:flutter/src/painting/basic_types.dart';
import 'package:flutter/src/rendering/stack.dart';
import 'package:flutter/src/rendering/flex.dart';
import 'package:flutter/src/rendering/wrap.dart';
import 'package:flutter/src/rendering/flow.dart';
import 'package:flutter/src/painting/inline_span.dart';
import 'package:flutter/src/painting/text_painter.dart';
import 'package:flutter/src/painting/strut_style.dart';
import 'package:flutter/src/rendering/selection.dart';
import 'package:flutter/src/animation/animation.dart';
import 'package:flutter/src/painting/decoration_image.dart';
import 'package:flutter/src/services/asset_bundle.dart';
import 'package:flutter/src/gestures/events.dart';
import 'package:flutter/src/services/mouse_cursor.dart';
import 'package:flutter/src/semantics/semantics.dart';
import 'package:flutter/src/services/text_editing.dart';
export 'package:flutter/animation.dart';
export 'package:flutter/foundation.dart'
    show ChangeNotifier, FlutterErrorDetails, Listenable, TargetPlatform, ValueNotifier;
export 'package:flutter/painting.dart';
export 'package:flutter/rendering.dart'
    show
        AlignmentGeometryTween,
        AlignmentTween,
        Axis,
        BoxConstraints,
        BoxConstraintsTransform,
        CrossAxisAlignment,
        CustomClipper,
        CustomPainter,
        CustomPainterSemantics,
        DecorationPosition,
        FlexFit,
        FlowDelegate,
        FlowPaintingContext,
        FractionalOffsetTween,
        HitTestBehavior,
        LayerLink,
        MainAxisAlignment,
        MainAxisSize,
        MouseCursor,
        MultiChildLayoutDelegate,
        PaintingContext,
        PointerCancelEvent,
        PointerCancelEventListener,
        PointerDownEvent,
        PointerDownEventListener,
        PointerEvent,
        PointerMoveEvent,
        PointerMoveEventListener,
        PointerUpEvent,
        PointerUpEventListener,
        RelativeRect,
        SemanticsBuilderCallback,
        ShaderCallback,
        ShapeBorderClipper,
        SingleChildLayoutDelegate,
        StackFit,
        SystemMouseCursors,
        TextOverflow,
        ValueChanged,
        ValueGetter,
        WrapAlignment,
        WrapCrossAlignment;
export 'package:flutter/services.dart' show AssetBundle;

/// class Directionality extends _UbiquitousInheritedWidget
class DirectionalityMate {
  /// Directionality Directionality({Key? key, required TextDirection textDirection, required Widget child})
  DirectionalityMate({
// param: {Key? key}
    Key? key,
// param: {required TextDirection textDirection}
    required TextDirection textDirection,
// param: {required Widget child}
    required Widget child,
  }) {}
}

/// class Opacity extends SingleChildRenderObjectWidget
class OpacityMate {
  /// Opacity Opacity({Key? key, required double opacity, bool alwaysIncludeSemantics = false, Widget? child})
  OpacityMate({
// param: {Key? key}
    Key? key,
// param: {required double opacity}
    required double opacity,
// param: {bool alwaysIncludeSemantics = false}
    required bool alwaysIncludeSemantics,
// param: {Widget? child}
    Widget? child,
  }) {}
}

/// class ShaderMask extends SingleChildRenderObjectWidget
class ShaderMaskMate {
  /// ShaderMask ShaderMask({Key? key, required Shader Function(Rect) shaderCallback, BlendMode blendMode = BlendMode.modulate, Widget? child})
  ShaderMaskMate({
// param: {Key? key}
    Key? key,
// param: {required Shader Function(Rect) shaderCallback}
    required Shader Function(
      Rect, [
      Rect,
    ])
        shaderCallback,
// param: {BlendMode blendMode = BlendMode.modulate}
    required BlendMode blendMode,
// param: {Widget? child}
    Widget? child,
  }) {}
}

/// class BackdropFilter extends SingleChildRenderObjectWidget
class BackdropFilterMate {
  /// BackdropFilter BackdropFilter({Key? key, required ImageFilter filter, Widget? child, BlendMode blendMode = BlendMode.srcOver})
  BackdropFilterMate({
// param: {Key? key}
    Key? key,
// param: {required ImageFilter filter}
    required ImageFilter filter,
// param: {Widget? child}
    Widget? child,
// param: {BlendMode blendMode = BlendMode.srcOver}
    required BlendMode blendMode,
  }) {}
}

/// class CustomPaint extends SingleChildRenderObjectWidget
class CustomPaintMate {
  /// CustomPaint CustomPaint({Key? key, CustomPainter? painter, CustomPainter? foregroundPainter, Size size = Size.zero, bool isComplex = false, bool willChange = false, Widget? child})
  CustomPaintMate({
// param: {Key? key}
    Key? key,
// param: {CustomPainter? painter}
    CustomPainter? painter,
// param: {CustomPainter? foregroundPainter}
    CustomPainter? foregroundPainter,
// param: {Size size = Size.zero}
    required Size size,
// param: {bool isComplex = false}
    required bool isComplex,
// param: {bool willChange = false}
    required bool willChange,
// param: {Widget? child}
    Widget? child,
  }) {}
}

/// class ClipRect extends SingleChildRenderObjectWidget
class ClipRectMate {
  /// ClipRect ClipRect({Key? key, CustomClipper<Rect>? clipper, Clip clipBehavior = Clip.hardEdge, Widget? child})
  ClipRectMate({
// param: {Key? key}
    Key? key,
// param: {CustomClipper<Rect>? clipper}
    CustomClipper<Rect>? clipper,
// param: {Clip clipBehavior = Clip.hardEdge}
    required Clip clipBehavior,
// param: {Widget? child}
    Widget? child,
  }) {}
}

/// class ClipRRect extends SingleChildRenderObjectWidget
class ClipRRectMate {
  /// ClipRRect ClipRRect({Key? key, BorderRadiusGeometry? borderRadius = BorderRadius.zero, CustomClipper<RRect>? clipper, Clip clipBehavior = Clip.antiAlias, Widget? child})
  ClipRRectMate({
// param: {Key? key}
    Key? key,
// param: {BorderRadiusGeometry? borderRadius = BorderRadius.zero}
    BorderRadiusGeometry? borderRadius,
// param: {CustomClipper<RRect>? clipper}
    CustomClipper<RRect>? clipper,
// param: {Clip clipBehavior = Clip.antiAlias}
    required Clip clipBehavior,
// param: {Widget? child}
    Widget? child,
  }) {}
}

/// class ClipOval extends SingleChildRenderObjectWidget
class ClipOvalMate {
  /// ClipOval ClipOval({Key? key, CustomClipper<Rect>? clipper, Clip clipBehavior = Clip.antiAlias, Widget? child})
  ClipOvalMate({
// param: {Key? key}
    Key? key,
// param: {CustomClipper<Rect>? clipper}
    CustomClipper<Rect>? clipper,
// param: {Clip clipBehavior = Clip.antiAlias}
    required Clip clipBehavior,
// param: {Widget? child}
    Widget? child,
  }) {}
}

/// class ClipPath extends SingleChildRenderObjectWidget
class ClipPathMate {
  /// ClipPath ClipPath({Key? key, CustomClipper<Path>? clipper, Clip clipBehavior = Clip.antiAlias, Widget? child})
  ClipPathMate({
// param: {Key? key}
    Key? key,
// param: {CustomClipper<Path>? clipper}
    CustomClipper<Path>? clipper,
// param: {Clip clipBehavior = Clip.antiAlias}
    required Clip clipBehavior,
// param: {Widget? child}
    Widget? child,
  }) {}
}

/// class PhysicalModel extends SingleChildRenderObjectWidget
class PhysicalModelMate {
  /// PhysicalModel PhysicalModel({Key? key, BoxShape shape = BoxShape.rectangle, Clip clipBehavior = Clip.none, BorderRadius? borderRadius, double elevation = 0.0, required Color color, Color shadowColor = const Color(0xFF000000), Widget? child})
  PhysicalModelMate({
// param: {Key? key}
    Key? key,
// param: {BoxShape shape = BoxShape.rectangle}
    required BoxShape shape,
// param: {Clip clipBehavior = Clip.none}
    required Clip clipBehavior,
// param: {BorderRadius? borderRadius}
    BorderRadius? borderRadius,
// param: {double elevation = 0.0}
    required double elevation,
// param: {required Color color}
    required Color color,
// param: {Color shadowColor = const Color(0xFF000000)}
    required Color shadowColor,
// param: {Widget? child}
    Widget? child,
  }) {}
}

/// class PhysicalShape extends SingleChildRenderObjectWidget
class PhysicalShapeMate {
  /// PhysicalShape PhysicalShape({Key? key, required CustomClipper<Path> clipper, Clip clipBehavior = Clip.none, double elevation = 0.0, required Color color, Color shadowColor = const Color(0xFF000000), Widget? child})
  PhysicalShapeMate({
// param: {Key? key}
    Key? key,
// param: {required CustomClipper<Path> clipper}
    required CustomClipper<Path> clipper,
// param: {Clip clipBehavior = Clip.none}
    required Clip clipBehavior,
// param: {double elevation = 0.0}
    required double elevation,
// param: {required Color color}
    required Color color,
// param: {Color shadowColor = const Color(0xFF000000)}
    required Color shadowColor,
// param: {Widget? child}
    Widget? child,
  }) {}
}

/// class Transform extends SingleChildRenderObjectWidget
class TransformMate {
  /// Transform Transform({Key? key, required Matrix4 transform, Offset? origin, AlignmentGeometry? alignment, bool transformHitTests = true, FilterQuality? filterQuality, Widget? child})
  TransformMate({
// param: {Key? key}
    Key? key,
// param: {required Matrix4 transform}
    required Matrix4 transform,
// param: {Offset? origin}
    Offset? origin,
// param: {AlignmentGeometry? alignment}
    AlignmentGeometry? alignment,
// param: {bool transformHitTests = true}
    required bool transformHitTests,
// param: {FilterQuality? filterQuality}
    FilterQuality? filterQuality,
// param: {Widget? child}
    Widget? child,
  }) {}

  /// Transform Transform.rotate({Key? key, required double angle, Offset? origin, AlignmentGeometry? alignment = Alignment.center, bool transformHitTests = true, FilterQuality? filterQuality, Widget? child})
  TransformMate.rotate({
// param: {Key? key}
    Key? key,
// param: {required double angle}
    required double angle,
// param: {Offset? origin}
    Offset? origin,
// param: {AlignmentGeometry? alignment = Alignment.center}
    AlignmentGeometry? alignment,
// param: {bool transformHitTests = true}
    required bool transformHitTests,
// param: {FilterQuality? filterQuality}
    FilterQuality? filterQuality,
// param: {Widget? child}
    Widget? child,
  }) {}

  /// Transform Transform.translate({Key? key, required Offset offset, bool transformHitTests = true, FilterQuality? filterQuality, Widget? child})
  TransformMate.translate({
// param: {Key? key}
    Key? key,
// param: {required Offset offset}
    required Offset offset,
// param: {bool transformHitTests = true}
    required bool transformHitTests,
// param: {FilterQuality? filterQuality}
    FilterQuality? filterQuality,
// param: {Widget? child}
    Widget? child,
  }) {}

  /// Transform Transform.scale({Key? key, double? scale, double? scaleX, double? scaleY, Offset? origin, AlignmentGeometry? alignment = Alignment.center, bool transformHitTests = true, FilterQuality? filterQuality, Widget? child})
  TransformMate.scale({
// param: {Key? key}
    Key? key,
// param: {double? scale}
    double? scale,
// param: {double? scaleX}
    double? scaleX,
// param: {double? scaleY}
    double? scaleY,
// param: {Offset? origin}
    Offset? origin,
// param: {AlignmentGeometry? alignment = Alignment.center}
    AlignmentGeometry? alignment,
// param: {bool transformHitTests = true}
    required bool transformHitTests,
// param: {FilterQuality? filterQuality}
    FilterQuality? filterQuality,
// param: {Widget? child}
    Widget? child,
  }) {}

  /// Transform Transform.flip({Key? key, bool flipX = false, bool flipY = false, Offset? origin, bool transformHitTests = true, FilterQuality? filterQuality, Widget? child})
  TransformMate.flip({
// param: {Key? key}
    Key? key,
// param: {bool flipX = false}
    required bool flipX,
// param: {bool flipY = false}
    required bool flipY,
// param: {Offset? origin}
    Offset? origin,
// param: {bool transformHitTests = true}
    required bool transformHitTests,
// param: {FilterQuality? filterQuality}
    FilterQuality? filterQuality,
// param: {Widget? child}
    Widget? child,
  }) {}
}

/// class CompositedTransformTarget extends SingleChildRenderObjectWidget
class CompositedTransformTargetMate {
  /// CompositedTransformTarget CompositedTransformTarget({Key? key, required LayerLink link, Widget? child})
  CompositedTransformTargetMate({
// param: {Key? key}
    Key? key,
// param: {required LayerLink link}
    required LayerLink link,
// param: {Widget? child}
    Widget? child,
  }) {}
}

/// class CompositedTransformFollower extends SingleChildRenderObjectWidget
class CompositedTransformFollowerMate {
  /// CompositedTransformFollower CompositedTransformFollower({Key? key, required LayerLink link, bool showWhenUnlinked = true, Offset offset = Offset.zero, Alignment targetAnchor = Alignment.topLeft, Alignment followerAnchor = Alignment.topLeft, Widget? child})
  CompositedTransformFollowerMate({
// param: {Key? key}
    Key? key,
// param: {required LayerLink link}
    required LayerLink link,
// param: {bool showWhenUnlinked = true}
    required bool showWhenUnlinked,
// param: {Offset offset = Offset.zero}
    required Offset offset,
// param: {Alignment targetAnchor = Alignment.topLeft}
    required Alignment targetAnchor,
// param: {Alignment followerAnchor = Alignment.topLeft}
    required Alignment followerAnchor,
// param: {Widget? child}
    Widget? child,
  }) {}
}

/// class FittedBox extends SingleChildRenderObjectWidget
class FittedBoxMate {
  /// FittedBox FittedBox({Key? key, BoxFit fit = BoxFit.contain, AlignmentGeometry alignment = Alignment.center, Clip clipBehavior = Clip.none, Widget? child})
  FittedBoxMate({
// param: {Key? key}
    Key? key,
// param: {BoxFit fit = BoxFit.contain}
    required BoxFit fit,
// param: {AlignmentGeometry alignment = Alignment.center}
    required AlignmentGeometry alignment,
// param: {Clip clipBehavior = Clip.none}
    required Clip clipBehavior,
// param: {Widget? child}
    Widget? child,
  }) {}
}

/// class FractionalTranslation extends SingleChildRenderObjectWidget
class FractionalTranslationMate {
  /// FractionalTranslation FractionalTranslation({Key? key, required Offset translation, bool transformHitTests = true, Widget? child})
  FractionalTranslationMate({
// param: {Key? key}
    Key? key,
// param: {required Offset translation}
    required Offset translation,
// param: {bool transformHitTests = true}
    required bool transformHitTests,
// param: {Widget? child}
    Widget? child,
  }) {}
}

/// class RotatedBox extends SingleChildRenderObjectWidget
class RotatedBoxMate {
  /// RotatedBox RotatedBox({Key? key, required int quarterTurns, Widget? child})
  RotatedBoxMate({
// param: {Key? key}
    Key? key,
// param: {required int quarterTurns}
    required int quarterTurns,
// param: {Widget? child}
    Widget? child,
  }) {}
}

/// class Padding extends SingleChildRenderObjectWidget
class PaddingMate {
  /// Padding Padding({Key? key, required EdgeInsetsGeometry padding, Widget? child})
  PaddingMate({
// param: {Key? key}
    Key? key,
// param: {required EdgeInsetsGeometry padding}
    required EdgeInsetsGeometry padding,
// param: {Widget? child}
    Widget? child,
  }) {}
}

/// class Align extends SingleChildRenderObjectWidget
class AlignMate {
  /// Align Align({Key? key, AlignmentGeometry alignment = Alignment.center, double? widthFactor, double? heightFactor, Widget? child})
  AlignMate({
// param: {Key? key}
    Key? key,
// param: {AlignmentGeometry alignment = Alignment.center}
    required AlignmentGeometry alignment,
// param: {double? widthFactor}
    double? widthFactor,
// param: {double? heightFactor}
    double? heightFactor,
// param: {Widget? child}
    Widget? child,
  }) {}
}

/// class Center extends Align
class CenterMate {
  /// Center Center({Key? key, double? widthFactor, double? heightFactor, Widget? child})
  CenterMate({
// param: {Key? key}
    Key? key,
// param: {double? widthFactor}
    double? widthFactor,
// param: {double? heightFactor}
    double? heightFactor,
// param: {Widget? child}
    Widget? child,
  }) {}
}

/// class CustomSingleChildLayout extends SingleChildRenderObjectWidget
class CustomSingleChildLayoutMate {
  /// CustomSingleChildLayout CustomSingleChildLayout({Key? key, required SingleChildLayoutDelegate delegate, Widget? child})
  CustomSingleChildLayoutMate({
// param: {Key? key}
    Key? key,
// param: {required SingleChildLayoutDelegate delegate}
    required SingleChildLayoutDelegate delegate,
// param: {Widget? child}
    Widget? child,
  }) {}
}

/// class LayoutId extends ParentDataWidget<MultiChildLayoutParentData>
class LayoutIdMate {
  /// LayoutId LayoutId({Key? key, required Object id, required Widget child})
  LayoutIdMate({
// param: {Key? key}
    Key? key,
// param: {required Object id}
    required Object id,
// param: {required Widget child}
    required Widget child,
  }) {}
}

/// class CustomMultiChildLayout extends MultiChildRenderObjectWidget
class CustomMultiChildLayoutMate {
  /// CustomMultiChildLayout CustomMultiChildLayout({Key? key, required MultiChildLayoutDelegate delegate, List<Widget> children = const <Widget>[]})
  CustomMultiChildLayoutMate({
// param: {Key? key}
    Key? key,
// param: {required MultiChildLayoutDelegate delegate}
    required MultiChildLayoutDelegate delegate,
// param: {List<Widget> children = const <Widget>[]}
    required List<Widget> children,
  }) {}
}

/// class SizedBox extends SingleChildRenderObjectWidget
class SizedBoxMate {
  /// SizedBox SizedBox({Key? key, double? width, double? height, Widget? child})
  SizedBoxMate({
// param: {Key? key}
    Key? key,
// param: {double? width}
    double? width,
// param: {double? height}
    double? height,
// param: {Widget? child}
    Widget? child,
  }) {}

  /// SizedBox SizedBox.expand({Key? key, Widget? child})
  SizedBoxMate.expand({
// param: {Key? key}
    Key? key,
// param: {Widget? child}
    Widget? child,
  }) {}

  /// SizedBox SizedBox.shrink({Key? key, Widget? child})
  SizedBoxMate.shrink({
// param: {Key? key}
    Key? key,
// param: {Widget? child}
    Widget? child,
  }) {}

  /// SizedBox SizedBox.fromSize({Key? key, Widget? child, Size? size})
  SizedBoxMate.fromSize({
// param: {Key? key}
    Key? key,
// param: {Widget? child}
    Widget? child,
// param: {Size? size}
    Size? size,
  }) {}

  /// SizedBox SizedBox.square({Key? key, Widget? child, double? dimension})
  SizedBoxMate.square({
// param: {Key? key}
    Key? key,
// param: {Widget? child}
    Widget? child,
// param: {double? dimension}
    double? dimension,
  }) {}
}

/// class ConstrainedBox extends SingleChildRenderObjectWidget
class ConstrainedBoxMate {
  /// ConstrainedBox ConstrainedBox({Key? key, required BoxConstraints constraints, Widget? child})
  ConstrainedBoxMate({
// param: {Key? key}
    Key? key,
// param: {required BoxConstraints constraints}
    required BoxConstraints constraints,
// param: {Widget? child}
    Widget? child,
  }) {}
}

/// class ConstraintsTransformBox extends SingleChildRenderObjectWidget
class ConstraintsTransformBoxMate {
  /// ConstraintsTransformBox ConstraintsTransformBox({Key? key, Widget? child, TextDirection? textDirection, AlignmentGeometry alignment = Alignment.center, required BoxConstraints Function(BoxConstraints) constraintsTransform, Clip clipBehavior = Clip.none, String debugTransformType = ''})
  ConstraintsTransformBoxMate({
// param: {Key? key}
    Key? key,
// param: {Widget? child}
    Widget? child,
// param: {TextDirection? textDirection}
    TextDirection? textDirection,
// param: {AlignmentGeometry alignment = Alignment.center}
    required AlignmentGeometry alignment,
// param: {required BoxConstraints Function(BoxConstraints) constraintsTransform}
    required BoxConstraints Function(
      BoxConstraints, [
      BoxConstraints,
    ])
        constraintsTransform,
// param: {Clip clipBehavior = Clip.none}
    required Clip clipBehavior,
// param: {String debugTransformType = ''}
    required String debugTransformType,
  }) {}
}

/// class UnconstrainedBox extends StatelessWidget
class UnconstrainedBoxMate {
  /// UnconstrainedBox UnconstrainedBox({Key? key, Widget? child, TextDirection? textDirection, AlignmentGeometry alignment = Alignment.center, Axis? constrainedAxis, Clip clipBehavior = Clip.none})
  UnconstrainedBoxMate({
// param: {Key? key}
    Key? key,
// param: {Widget? child}
    Widget? child,
// param: {TextDirection? textDirection}
    TextDirection? textDirection,
// param: {AlignmentGeometry alignment = Alignment.center}
    required AlignmentGeometry alignment,
// param: {Axis? constrainedAxis}
    Axis? constrainedAxis,
// param: {Clip clipBehavior = Clip.none}
    required Clip clipBehavior,
  }) {}
}

/// class FractionallySizedBox extends SingleChildRenderObjectWidget
class FractionallySizedBoxMate {
  /// FractionallySizedBox FractionallySizedBox({Key? key, AlignmentGeometry alignment = Alignment.center, double? widthFactor, double? heightFactor, Widget? child})
  FractionallySizedBoxMate({
// param: {Key? key}
    Key? key,
// param: {AlignmentGeometry alignment = Alignment.center}
    required AlignmentGeometry alignment,
// param: {double? widthFactor}
    double? widthFactor,
// param: {double? heightFactor}
    double? heightFactor,
// param: {Widget? child}
    Widget? child,
  }) {}
}

/// class LimitedBox extends SingleChildRenderObjectWidget
class LimitedBoxMate {
  /// LimitedBox LimitedBox({Key? key, double maxWidth = double.infinity, double maxHeight = double.infinity, Widget? child})
  LimitedBoxMate({
// param: {Key? key}
    Key? key,
// param: {double maxWidth = double.infinity}
    required double maxWidth,
// param: {double maxHeight = double.infinity}
    required double maxHeight,
// param: {Widget? child}
    Widget? child,
  }) {}
}

/// class OverflowBox extends SingleChildRenderObjectWidget
class OverflowBoxMate {
  /// OverflowBox OverflowBox({Key? key, AlignmentGeometry alignment = Alignment.center, double? minWidth, double? maxWidth, double? minHeight, double? maxHeight, Widget? child})
  OverflowBoxMate({
// param: {Key? key}
    Key? key,
// param: {AlignmentGeometry alignment = Alignment.center}
    required AlignmentGeometry alignment,
// param: {double? minWidth}
    double? minWidth,
// param: {double? maxWidth}
    double? maxWidth,
// param: {double? minHeight}
    double? minHeight,
// param: {double? maxHeight}
    double? maxHeight,
// param: {Widget? child}
    Widget? child,
  }) {}
}

/// class SizedOverflowBox extends SingleChildRenderObjectWidget
class SizedOverflowBoxMate {
  /// SizedOverflowBox SizedOverflowBox({Key? key, required Size size, AlignmentGeometry alignment = Alignment.center, Widget? child})
  SizedOverflowBoxMate({
// param: {Key? key}
    Key? key,
// param: {required Size size}
    required Size size,
// param: {AlignmentGeometry alignment = Alignment.center}
    required AlignmentGeometry alignment,
// param: {Widget? child}
    Widget? child,
  }) {}
}

/// class Offstage extends SingleChildRenderObjectWidget
class OffstageMate {
  /// Offstage Offstage({Key? key, bool offstage = true, Widget? child})
  OffstageMate({
// param: {Key? key}
    Key? key,
// param: {bool offstage = true}
    required bool offstage,
// param: {Widget? child}
    Widget? child,
  }) {}
}

/// class AspectRatio extends SingleChildRenderObjectWidget
class AspectRatioMate {
  /// AspectRatio AspectRatio({Key? key, required double aspectRatio, Widget? child})
  AspectRatioMate({
// param: {Key? key}
    Key? key,
// param: {required double aspectRatio}
    required double aspectRatio,
// param: {Widget? child}
    Widget? child,
  }) {}
}

/// class IntrinsicWidth extends SingleChildRenderObjectWidget
class IntrinsicWidthMate {
  /// IntrinsicWidth IntrinsicWidth({Key? key, double? stepWidth, double? stepHeight, Widget? child})
  IntrinsicWidthMate({
// param: {Key? key}
    Key? key,
// param: {double? stepWidth}
    double? stepWidth,
// param: {double? stepHeight}
    double? stepHeight,
// param: {Widget? child}
    Widget? child,
  }) {}
}

/// class IntrinsicHeight extends SingleChildRenderObjectWidget
class IntrinsicHeightMate {
  /// IntrinsicHeight IntrinsicHeight({Key? key, Widget? child})
  IntrinsicHeightMate({
// param: {Key? key}
    Key? key,
// param: {Widget? child}
    Widget? child,
  }) {}
}

/// class Baseline extends SingleChildRenderObjectWidget
class BaselineMate {
  /// Baseline Baseline({Key? key, required double baseline, required TextBaseline baselineType, Widget? child})
  BaselineMate({
// param: {Key? key}
    Key? key,
// param: {required double baseline}
    required double baseline,
// param: {required TextBaseline baselineType}
    required TextBaseline baselineType,
// param: {Widget? child}
    Widget? child,
  }) {}
}

/// class SliverToBoxAdapter extends SingleChildRenderObjectWidget
class SliverToBoxAdapterMate {
  /// SliverToBoxAdapter SliverToBoxAdapter({Key? key, Widget? child})
  SliverToBoxAdapterMate({
// param: {Key? key}
    Key? key,
// param: {Widget? child}
    Widget? child,
  }) {}
}

/// class SliverPadding extends SingleChildRenderObjectWidget
class SliverPaddingMate {
  /// SliverPadding SliverPadding({Key? key, required EdgeInsetsGeometry padding, Widget? sliver})
  SliverPaddingMate({
// param: {Key? key}
    Key? key,
// param: {required EdgeInsetsGeometry padding}
    required EdgeInsetsGeometry padding,
// param: {Widget? sliver}
    Widget? sliver,
  }) {}
}

/// class ListBody extends MultiChildRenderObjectWidget
class ListBodyMate {
  /// ListBody ListBody({Key? key, Axis mainAxis = Axis.vertical, bool reverse = false, List<Widget> children = const <Widget>[]})
  ListBodyMate({
// param: {Key? key}
    Key? key,
// param: {Axis mainAxis = Axis.vertical}
    required Axis mainAxis,
// param: {bool reverse = false}
    required bool reverse,
// param: {List<Widget> children = const <Widget>[]}
    required List<Widget> children,
  }) {}
}

/// class Stack extends MultiChildRenderObjectWidget
class StackMate {
  /// Stack Stack({Key? key, AlignmentGeometry alignment = AlignmentDirectional.topStart, TextDirection? textDirection, StackFit fit = StackFit.loose, Clip clipBehavior = Clip.hardEdge, List<Widget> children = const <Widget>[]})
  StackMate({
// param: {Key? key}
    Key? key,
// param: {AlignmentGeometry alignment = AlignmentDirectional.topStart}
    required AlignmentGeometry alignment,
// param: {TextDirection? textDirection}
    TextDirection? textDirection,
// param: {StackFit fit = StackFit.loose}
    required StackFit fit,
// param: {Clip clipBehavior = Clip.hardEdge}
    required Clip clipBehavior,
// param: {List<Widget> children = const <Widget>[]}
    required List<Widget> children,
  }) {}
}

/// class IndexedStack extends Stack
class IndexedStackMate {
  /// IndexedStack IndexedStack({Key? key, AlignmentGeometry alignment = AlignmentDirectional.topStart, TextDirection? textDirection, Clip clipBehavior = Clip.hardEdge, StackFit sizing = StackFit.loose, int? index = 0, List<Widget> children = const <Widget>[]})
  IndexedStackMate({
// param: {Key? key}
    Key? key,
// param: {AlignmentGeometry alignment = AlignmentDirectional.topStart}
    required AlignmentGeometry alignment,
// param: {TextDirection? textDirection}
    TextDirection? textDirection,
// param: {Clip clipBehavior = Clip.hardEdge}
    required Clip clipBehavior,
// param: {StackFit sizing = StackFit.loose}
    required StackFit sizing,
// param: {int? index = 0}
    int? index,
// param: {List<Widget> children = const <Widget>[]}
    required List<Widget> children,
  }) {}
}

/// class Positioned extends ParentDataWidget<StackParentData>
class PositionedMate {
  /// Positioned Positioned({Key? key, double? left, double? top, double? right, double? bottom, double? width, double? height, required Widget child})
  PositionedMate({
// param: {Key? key}
    Key? key,
// param: {double? left}
    double? left,
// param: {double? top}
    double? top,
// param: {double? right}
    double? right,
// param: {double? bottom}
    double? bottom,
// param: {double? width}
    double? width,
// param: {double? height}
    double? height,
// param: {required Widget child}
    required Widget child,
  }) {}

  /// Positioned Positioned.fromRect({Key? key, required Rect rect, required Widget child})
  PositionedMate.fromRect({
// param: {Key? key}
    Key? key,
// param: {required Rect rect}
    required Rect rect,
// param: {required Widget child}
    required Widget child,
  }) {}

  /// Positioned Positioned.fromRelativeRect({Key? key, required RelativeRect rect, required Widget child})
  PositionedMate.fromRelativeRect({
// param: {Key? key}
    Key? key,
// param: {required RelativeRect rect}
    required RelativeRect rect,
// param: {required Widget child}
    required Widget child,
  }) {}

  /// Positioned Positioned.fill({Key? key, double? left = 0.0, double? top = 0.0, double? right = 0.0, double? bottom = 0.0, required Widget child})
  PositionedMate.fill({
// param: {Key? key}
    Key? key,
// param: {double? left = 0.0}
    double? left,
// param: {double? top = 0.0}
    double? top,
// param: {double? right = 0.0}
    double? right,
// param: {double? bottom = 0.0}
    double? bottom,
// param: {required Widget child}
    required Widget child,
  }) {}
}

/// class PositionedDirectional extends StatelessWidget
class PositionedDirectionalMate {
  /// PositionedDirectional PositionedDirectional({Key? key, double? start, double? top, double? end, double? bottom, double? width, double? height, required Widget child})
  PositionedDirectionalMate({
// param: {Key? key}
    Key? key,
// param: {double? start}
    double? start,
// param: {double? top}
    double? top,
// param: {double? end}
    double? end,
// param: {double? bottom}
    double? bottom,
// param: {double? width}
    double? width,
// param: {double? height}
    double? height,
// param: {required Widget child}
    required Widget child,
  }) {}
}

/// class Flex extends MultiChildRenderObjectWidget
class FlexMate {
  /// Flex Flex({Key? key, required Axis direction, MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start, MainAxisSize mainAxisSize = MainAxisSize.max, CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center, TextDirection? textDirection, VerticalDirection verticalDirection = VerticalDirection.down, TextBaseline? textBaseline, Clip clipBehavior = Clip.none, List<Widget> children = const <Widget>[]})
  FlexMate({
// param: {Key? key}
    Key? key,
// param: {required Axis direction}
    required Axis direction,
// param: {MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start}
    required MainAxisAlignment mainAxisAlignment,
// param: {MainAxisSize mainAxisSize = MainAxisSize.max}
    required MainAxisSize mainAxisSize,
// param: {CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center}
    required CrossAxisAlignment crossAxisAlignment,
// param: {TextDirection? textDirection}
    TextDirection? textDirection,
// param: {VerticalDirection verticalDirection = VerticalDirection.down}
    required VerticalDirection verticalDirection,
// param: {TextBaseline? textBaseline}
    TextBaseline? textBaseline,
// param: {Clip clipBehavior = Clip.none}
    required Clip clipBehavior,
// param: {List<Widget> children = const <Widget>[]}
    required List<Widget> children,
  }) {}
}

/// class Row extends Flex
class RowMate {
  /// Row Row({Key? key, MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start, MainAxisSize mainAxisSize = MainAxisSize.max, CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center, TextDirection? textDirection, VerticalDirection verticalDirection = VerticalDirection.down, TextBaseline? textBaseline, List<Widget> children = const <Widget>[]})
  RowMate({
// param: {Key? key}
    Key? key,
// param: {MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start}
    required MainAxisAlignment mainAxisAlignment,
// param: {MainAxisSize mainAxisSize = MainAxisSize.max}
    required MainAxisSize mainAxisSize,
// param: {CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center}
    required CrossAxisAlignment crossAxisAlignment,
// param: {TextDirection? textDirection}
    TextDirection? textDirection,
// param: {VerticalDirection verticalDirection = VerticalDirection.down}
    required VerticalDirection verticalDirection,
// param: {TextBaseline? textBaseline}
    TextBaseline? textBaseline,
// param: {List<Widget> children = const <Widget>[]}
    required List<Widget> children,
  }) {}
}

/// class Column extends Flex
class ColumnMate {
  /// Column Column({Key? key, MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start, MainAxisSize mainAxisSize = MainAxisSize.max, CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center, TextDirection? textDirection, VerticalDirection verticalDirection = VerticalDirection.down, TextBaseline? textBaseline, List<Widget> children = const <Widget>[]})
  ColumnMate({
// param: {Key? key}
    Key? key,
// param: {MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start}
    required MainAxisAlignment mainAxisAlignment,
// param: {MainAxisSize mainAxisSize = MainAxisSize.max}
    required MainAxisSize mainAxisSize,
// param: {CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center}
    required CrossAxisAlignment crossAxisAlignment,
// param: {TextDirection? textDirection}
    TextDirection? textDirection,
// param: {VerticalDirection verticalDirection = VerticalDirection.down}
    required VerticalDirection verticalDirection,
// param: {TextBaseline? textBaseline}
    TextBaseline? textBaseline,
// param: {List<Widget> children = const <Widget>[]}
    required List<Widget> children,
  }) {}
}

/// class Flexible extends ParentDataWidget<FlexParentData>
class FlexibleMate {
  /// Flexible Flexible({Key? key, int flex = 1, FlexFit fit = FlexFit.loose, required Widget child})
  FlexibleMate({
// param: {Key? key}
    Key? key,
// param: {int flex = 1}
    required int flex,
// param: {FlexFit fit = FlexFit.loose}
    required FlexFit fit,
// param: {required Widget child}
    required Widget child,
  }) {}
}

/// class Expanded extends Flexible
class ExpandedMate {
  /// Expanded Expanded({Key? key, int flex = 1, required Widget child})
  ExpandedMate({
// param: {Key? key}
    Key? key,
// param: {int flex = 1}
    required int flex,
// param: {required Widget child}
    required Widget child,
  }) {}
}

/// class Wrap extends MultiChildRenderObjectWidget
class WrapMate {
  /// Wrap Wrap({Key? key, Axis direction = Axis.horizontal, WrapAlignment alignment = WrapAlignment.start, double spacing = 0.0, WrapAlignment runAlignment = WrapAlignment.start, double runSpacing = 0.0, WrapCrossAlignment crossAxisAlignment = WrapCrossAlignment.start, TextDirection? textDirection, VerticalDirection verticalDirection = VerticalDirection.down, Clip clipBehavior = Clip.none, List<Widget> children = const <Widget>[]})
  WrapMate({
// param: {Key? key}
    Key? key,
// param: {Axis direction = Axis.horizontal}
    required Axis direction,
// param: {WrapAlignment alignment = WrapAlignment.start}
    required WrapAlignment alignment,
// param: {double spacing = 0.0}
    required double spacing,
// param: {WrapAlignment runAlignment = WrapAlignment.start}
    required WrapAlignment runAlignment,
// param: {double runSpacing = 0.0}
    required double runSpacing,
// param: {WrapCrossAlignment crossAxisAlignment = WrapCrossAlignment.start}
    required WrapCrossAlignment crossAxisAlignment,
// param: {TextDirection? textDirection}
    TextDirection? textDirection,
// param: {VerticalDirection verticalDirection = VerticalDirection.down}
    required VerticalDirection verticalDirection,
// param: {Clip clipBehavior = Clip.none}
    required Clip clipBehavior,
// param: {List<Widget> children = const <Widget>[]}
    required List<Widget> children,
  }) {}
}

/// class Flow extends MultiChildRenderObjectWidget
class FlowMate {
  /// Flow Flow({Key? key, required FlowDelegate delegate, List<Widget> children = const <Widget>[], Clip clipBehavior = Clip.hardEdge})
  FlowMate({
// param: {Key? key}
    Key? key,
// param: {required FlowDelegate delegate}
    required FlowDelegate delegate,
// param: {List<Widget> children = const <Widget>[]}
    required List<Widget> children,
// param: {Clip clipBehavior = Clip.hardEdge}
    required Clip clipBehavior,
  }) {}

  /// Flow Flow.unwrapped({Key? key, required FlowDelegate delegate, List<Widget> children = const <Widget>[], Clip clipBehavior = Clip.hardEdge})
  FlowMate.unwrapped({
// param: {Key? key}
    Key? key,
// param: {required FlowDelegate delegate}
    required FlowDelegate delegate,
// param: {List<Widget> children = const <Widget>[]}
    required List<Widget> children,
// param: {Clip clipBehavior = Clip.hardEdge}
    required Clip clipBehavior,
  }) {}
}

/// class RichText extends MultiChildRenderObjectWidget
class RichTextMate {
  /// RichText RichText({Key? key, required InlineSpan text, TextAlign textAlign = TextAlign.start, TextDirection? textDirection, bool softWrap = true, TextOverflow overflow = TextOverflow.clip, double textScaleFactor = 1.0, int? maxLines, Locale? locale, StrutStyle? strutStyle, TextWidthBasis textWidthBasis = TextWidthBasis.parent, TextHeightBehavior? textHeightBehavior, SelectionRegistrar? selectionRegistrar, Color? selectionColor})
  RichTextMate({
// param: {Key? key}
    Key? key,
// param: {required InlineSpan text}
    required InlineSpan text,
// param: {TextAlign textAlign = TextAlign.start}
    required TextAlign textAlign,
// param: {TextDirection? textDirection}
    TextDirection? textDirection,
// param: {bool softWrap = true}
    required bool softWrap,
// param: {TextOverflow overflow = TextOverflow.clip}
    required TextOverflow overflow,
// param: {double textScaleFactor = 1.0}
    required double textScaleFactor,
// param: {int? maxLines}
    int? maxLines,
// param: {Locale? locale}
    Locale? locale,
// param: {StrutStyle? strutStyle}
    StrutStyle? strutStyle,
// param: {TextWidthBasis textWidthBasis = TextWidthBasis.parent}
    required TextWidthBasis textWidthBasis,
// param: {TextHeightBehavior? textHeightBehavior}
    TextHeightBehavior? textHeightBehavior,
// param: {SelectionRegistrar? selectionRegistrar}
    SelectionRegistrar? selectionRegistrar,
// param: {Color? selectionColor}
    Color? selectionColor,
  }) {}
}

/// class RawImage extends LeafRenderObjectWidget
class RawImageMate {
  /// RawImage RawImage({Key? key, Image? image, String? debugImageLabel, double? width, double? height, double scale = 1.0, Color? color, Animation<double>? opacity, BlendMode? colorBlendMode, BoxFit? fit, AlignmentGeometry alignment = Alignment.center, ImageRepeat repeat = ImageRepeat.noRepeat, Rect? centerSlice, bool matchTextDirection = false, bool invertColors = false, FilterQuality filterQuality = FilterQuality.low, bool isAntiAlias = false})
  RawImageMate({
// param: {Key? key}
    Key? key,
// param: {Image? image}
    Image? image,
// param: {String? debugImageLabel}
    String? debugImageLabel,
// param: {double? width}
    double? width,
// param: {double? height}
    double? height,
// param: {double scale = 1.0}
    required double scale,
// param: {Color? color}
    Color? color,
// param: {Animation<double>? opacity}
    Animation<double>? opacity,
// param: {BlendMode? colorBlendMode}
    BlendMode? colorBlendMode,
// param: {BoxFit? fit}
    BoxFit? fit,
// param: {AlignmentGeometry alignment = Alignment.center}
    required AlignmentGeometry alignment,
// param: {ImageRepeat repeat = ImageRepeat.noRepeat}
    required ImageRepeat repeat,
// param: {Rect? centerSlice}
    Rect? centerSlice,
// param: {bool matchTextDirection = false}
    required bool matchTextDirection,
// param: {bool invertColors = false}
    required bool invertColors,
// param: {FilterQuality filterQuality = FilterQuality.low}
    required FilterQuality filterQuality,
// param: {bool isAntiAlias = false}
    required bool isAntiAlias,
  }) {}
}

/// class DefaultAssetBundle extends InheritedWidget
class DefaultAssetBundleMate {
  /// DefaultAssetBundle DefaultAssetBundle({Key? key, required AssetBundle bundle, required Widget child})
  DefaultAssetBundleMate({
// param: {Key? key}
    Key? key,
// param: {required AssetBundle bundle}
    required AssetBundle bundle,
// param: {required Widget child}
    required Widget child,
  }) {}
}

/// class WidgetToRenderBoxAdapter extends LeafRenderObjectWidget
class WidgetToRenderBoxAdapterMate {
  /// WidgetToRenderBoxAdapter WidgetToRenderBoxAdapter({required RenderBox renderBox, void Function()? onBuild, void Function()? onUnmount})
  WidgetToRenderBoxAdapterMate({
// param: {required RenderBox renderBox}
    required RenderBox renderBox,
// param: {void Function()? onBuild}
    void Function()? onBuild,
// param: {void Function()? onUnmount}
    void Function()? onUnmount,
  }) {}
}

/// class Listener extends SingleChildRenderObjectWidget
class ListenerMate {
  /// Listener Listener({Key? key, void Function(PointerDownEvent)? onPointerDown, void Function(PointerMoveEvent)? onPointerMove, void Function(PointerUpEvent)? onPointerUp, void Function(PointerHoverEvent)? onPointerHover, void Function(PointerCancelEvent)? onPointerCancel, void Function(PointerPanZoomStartEvent)? onPointerPanZoomStart, void Function(PointerPanZoomUpdateEvent)? onPointerPanZoomUpdate, void Function(PointerPanZoomEndEvent)? onPointerPanZoomEnd, void Function(PointerSignalEvent)? onPointerSignal, HitTestBehavior behavior = HitTestBehavior.deferToChild, Widget? child})
  ListenerMate({
// param: {Key? key}
    Key? key,
// param: {void Function(PointerDownEvent)? onPointerDown}
    void Function(
      PointerDownEvent, [
      PointerDownEvent,
    ])?
        onPointerDown,
// param: {void Function(PointerMoveEvent)? onPointerMove}
    void Function(
      PointerMoveEvent, [
      PointerMoveEvent,
    ])?
        onPointerMove,
// param: {void Function(PointerUpEvent)? onPointerUp}
    void Function(
      PointerUpEvent, [
      PointerUpEvent,
    ])?
        onPointerUp,
// param: {void Function(PointerHoverEvent)? onPointerHover}
    void Function(
      PointerHoverEvent, [
      PointerHoverEvent,
    ])?
        onPointerHover,
// param: {void Function(PointerCancelEvent)? onPointerCancel}
    void Function(
      PointerCancelEvent, [
      PointerCancelEvent,
    ])?
        onPointerCancel,
// param: {void Function(PointerPanZoomStartEvent)? onPointerPanZoomStart}
    void Function(
      PointerPanZoomStartEvent, [
      PointerPanZoomStartEvent,
    ])?
        onPointerPanZoomStart,
// param: {void Function(PointerPanZoomUpdateEvent)? onPointerPanZoomUpdate}
    void Function(
      PointerPanZoomUpdateEvent, [
      PointerPanZoomUpdateEvent,
    ])?
        onPointerPanZoomUpdate,
// param: {void Function(PointerPanZoomEndEvent)? onPointerPanZoomEnd}
    void Function(
      PointerPanZoomEndEvent, [
      PointerPanZoomEndEvent,
    ])?
        onPointerPanZoomEnd,
// param: {void Function(PointerSignalEvent)? onPointerSignal}
    void Function(
      PointerSignalEvent, [
      PointerSignalEvent,
    ])?
        onPointerSignal,
// param: {HitTestBehavior behavior = HitTestBehavior.deferToChild}
    required HitTestBehavior behavior,
// param: {Widget? child}
    Widget? child,
  }) {}
}

/// class MouseRegion extends SingleChildRenderObjectWidget
class MouseRegionMate {
  /// MouseRegion MouseRegion({Key? key, void Function(PointerEnterEvent)? onEnter, void Function(PointerExitEvent)? onExit, void Function(PointerHoverEvent)? onHover, MouseCursor cursor = MouseCursor.defer, bool opaque = true, HitTestBehavior? hitTestBehavior, Widget? child})
  MouseRegionMate({
// param: {Key? key}
    Key? key,
// param: {void Function(PointerEnterEvent)? onEnter}
    void Function(
      PointerEnterEvent, [
      PointerEnterEvent,
    ])?
        onEnter,
// param: {void Function(PointerExitEvent)? onExit}
    void Function(
      PointerExitEvent, [
      PointerExitEvent,
    ])?
        onExit,
// param: {void Function(PointerHoverEvent)? onHover}
    void Function(
      PointerHoverEvent, [
      PointerHoverEvent,
    ])?
        onHover,
// param: {MouseCursor cursor = MouseCursor.defer}
    required MouseCursor cursor,
// param: {bool opaque = true}
    required bool opaque,
// param: {HitTestBehavior? hitTestBehavior}
    HitTestBehavior? hitTestBehavior,
// param: {Widget? child}
    Widget? child,
  }) {}
}

/// class RepaintBoundary extends SingleChildRenderObjectWidget
class RepaintBoundaryMate {
  /// RepaintBoundary RepaintBoundary({Key? key, Widget? child})
  RepaintBoundaryMate({
// param: {Key? key}
    Key? key,
// param: {Widget? child}
    Widget? child,
  }) {}
}

/// class IgnorePointer extends SingleChildRenderObjectWidget
class IgnorePointerMate {
  /// IgnorePointer IgnorePointer({Key? key, bool ignoring = true, bool? ignoringSemantics, Widget? child})
  IgnorePointerMate({
// param: {Key? key}
    Key? key,
// param: {bool ignoring = true}
    required bool ignoring,
// param: {bool? ignoringSemantics}
    bool? ignoringSemantics,
// param: {Widget? child}
    Widget? child,
  }) {}
}

/// class AbsorbPointer extends SingleChildRenderObjectWidget
class AbsorbPointerMate {
  /// AbsorbPointer AbsorbPointer({Key? key, bool absorbing = true, Widget? child, bool? ignoringSemantics})
  AbsorbPointerMate({
// param: {Key? key}
    Key? key,
// param: {bool absorbing = true}
    required bool absorbing,
// param: {Widget? child}
    Widget? child,
// param: {bool? ignoringSemantics}
    bool? ignoringSemantics,
  }) {}
}

/// class MetaData extends SingleChildRenderObjectWidget
class MetaDataMate {
  /// MetaData MetaData({Key? key, dynamic metaData, HitTestBehavior behavior = HitTestBehavior.deferToChild, Widget? child})
  MetaDataMate({
// param: {Key? key}
    Key? key,
// param: {dynamic metaData}
    required dynamic metaData,
// param: {HitTestBehavior behavior = HitTestBehavior.deferToChild}
    required HitTestBehavior behavior,
// param: {Widget? child}
    Widget? child,
  }) {}
}

/// class Semantics extends SingleChildRenderObjectWidget
class SemanticsMate {
  /// Semantics Semantics({Key? key, Widget? child, bool container = false, bool explicitChildNodes = false, bool excludeSemantics = false, bool? enabled, bool? checked, bool? mixed, bool? selected, bool? toggled, bool? button, bool? slider, bool? keyboardKey, bool? link, bool? header, bool? textField, bool? readOnly, bool? focusable, bool? focused, bool? inMutuallyExclusiveGroup, bool? obscured, bool? multiline, bool? scopesRoute, bool? namesRoute, bool? hidden, bool? image, bool? liveRegion, int? maxValueLength, int? currentValueLength, String? label, AttributedString? attributedLabel, String? value, AttributedString? attributedValue, String? increasedValue, AttributedString? attributedIncreasedValue, String? decreasedValue, AttributedString? attributedDecreasedValue, String? hint, AttributedString? attributedHint, String? tooltip, String? onTapHint, String? onLongPressHint, TextDirection? textDirection, SemanticsSortKey? sortKey, SemanticsTag? tagForChildren, void Function()? onTap, void Function()? onLongPress, void Function()? onScrollLeft, void Function()? onScrollRight, void Function()? onScrollUp, void Function()? onScrollDown, void Function()? onIncrease, void Function()? onDecrease, void Function()? onCopy, void Function()? onCut, void Function()? onPaste, void Function()? onDismiss, void Function(bool)? onMoveCursorForwardByCharacter, void Function(bool)? onMoveCursorBackwardByCharacter, void Function(TextSelection)? onSetSelection, void Function(String)? onSetText, void Function()? onDidGainAccessibilityFocus, void Function()? onDidLoseAccessibilityFocus, Map<CustomSemanticsAction, void Function()>? customSemanticsActions})
  SemanticsMate({
// param: {Key? key}
    Key? key,
// param: {Widget? child}
    Widget? child,
// param: {bool container = false}
    required bool container,
// param: {bool explicitChildNodes = false}
    required bool explicitChildNodes,
// param: {bool excludeSemantics = false}
    required bool excludeSemantics,
// param: {bool? enabled}
    bool? enabled,
// param: {bool? checked}
    bool? checked,
// param: {bool? mixed}
    bool? mixed,
// param: {bool? selected}
    bool? selected,
// param: {bool? toggled}
    bool? toggled,
// param: {bool? button}
    bool? button,
// param: {bool? slider}
    bool? slider,
// param: {bool? keyboardKey}
    bool? keyboardKey,
// param: {bool? link}
    bool? link,
// param: {bool? header}
    bool? header,
// param: {bool? textField}
    bool? textField,
// param: {bool? readOnly}
    bool? readOnly,
// param: {bool? focusable}
    bool? focusable,
// param: {bool? focused}
    bool? focused,
// param: {bool? inMutuallyExclusiveGroup}
    bool? inMutuallyExclusiveGroup,
// param: {bool? obscured}
    bool? obscured,
// param: {bool? multiline}
    bool? multiline,
// param: {bool? scopesRoute}
    bool? scopesRoute,
// param: {bool? namesRoute}
    bool? namesRoute,
// param: {bool? hidden}
    bool? hidden,
// param: {bool? image}
    bool? image,
// param: {bool? liveRegion}
    bool? liveRegion,
// param: {int? maxValueLength}
    int? maxValueLength,
// param: {int? currentValueLength}
    int? currentValueLength,
// param: {String? label}
    String? label,
// param: {AttributedString? attributedLabel}
    AttributedString? attributedLabel,
// param: {String? value}
    String? value,
// param: {AttributedString? attributedValue}
    AttributedString? attributedValue,
// param: {String? increasedValue}
    String? increasedValue,
// param: {AttributedString? attributedIncreasedValue}
    AttributedString? attributedIncreasedValue,
// param: {String? decreasedValue}
    String? decreasedValue,
// param: {AttributedString? attributedDecreasedValue}
    AttributedString? attributedDecreasedValue,
// param: {String? hint}
    String? hint,
// param: {AttributedString? attributedHint}
    AttributedString? attributedHint,
// param: {String? tooltip}
    String? tooltip,
// param: {String? onTapHint}
    String? onTapHint,
// param: {String? onLongPressHint}
    String? onLongPressHint,
// param: {TextDirection? textDirection}
    TextDirection? textDirection,
// param: {SemanticsSortKey? sortKey}
    SemanticsSortKey? sortKey,
// param: {SemanticsTag? tagForChildren}
    SemanticsTag? tagForChildren,
// param: {void Function()? onTap}
    void Function()? onTap,
// param: {void Function()? onLongPress}
    void Function()? onLongPress,
// param: {void Function()? onScrollLeft}
    void Function()? onScrollLeft,
// param: {void Function()? onScrollRight}
    void Function()? onScrollRight,
// param: {void Function()? onScrollUp}
    void Function()? onScrollUp,
// param: {void Function()? onScrollDown}
    void Function()? onScrollDown,
// param: {void Function()? onIncrease}
    void Function()? onIncrease,
// param: {void Function()? onDecrease}
    void Function()? onDecrease,
// param: {void Function()? onCopy}
    void Function()? onCopy,
// param: {void Function()? onCut}
    void Function()? onCut,
// param: {void Function()? onPaste}
    void Function()? onPaste,
// param: {void Function()? onDismiss}
    void Function()? onDismiss,
// param: {void Function(bool)? onMoveCursorForwardByCharacter}
    void Function(
      bool, [
      bool,
    ])?
        onMoveCursorForwardByCharacter,
// param: {void Function(bool)? onMoveCursorBackwardByCharacter}
    void Function(
      bool, [
      bool,
    ])?
        onMoveCursorBackwardByCharacter,
// param: {void Function(TextSelection)? onSetSelection}
    void Function(
      TextSelection, [
      TextSelection,
    ])?
        onSetSelection,
// param: {void Function(String)? onSetText}
    void Function(
      String, [
      String,
    ])?
        onSetText,
// param: {void Function()? onDidGainAccessibilityFocus}
    void Function()? onDidGainAccessibilityFocus,
// param: {void Function()? onDidLoseAccessibilityFocus}
    void Function()? onDidLoseAccessibilityFocus,
// param: {Map<CustomSemanticsAction, void Function()>? customSemanticsActions}
    Map<CustomSemanticsAction, void Function()>? customSemanticsActions,
  }) {}

  /// Semantics Semantics.fromProperties({Key? key, Widget? child, bool container = false, bool explicitChildNodes = false, bool excludeSemantics = false, required SemanticsProperties properties})
  SemanticsMate.fromProperties({
// param: {Key? key}
    Key? key,
// param: {Widget? child}
    Widget? child,
// param: {bool container = false}
    required bool container,
// param: {bool explicitChildNodes = false}
    required bool explicitChildNodes,
// param: {bool excludeSemantics = false}
    required bool excludeSemantics,
// param: {required SemanticsProperties properties}
    required SemanticsProperties properties,
  }) {}
}

/// class MergeSemantics extends SingleChildRenderObjectWidget
class MergeSemanticsMate {
  /// MergeSemantics MergeSemantics({Key? key, Widget? child})
  MergeSemanticsMate({
// param: {Key? key}
    Key? key,
// param: {Widget? child}
    Widget? child,
  }) {}
}

/// class BlockSemantics extends SingleChildRenderObjectWidget
class BlockSemanticsMate {
  /// BlockSemantics BlockSemantics({Key? key, bool blocking = true, Widget? child})
  BlockSemanticsMate({
// param: {Key? key}
    Key? key,
// param: {bool blocking = true}
    required bool blocking,
// param: {Widget? child}
    Widget? child,
  }) {}
}

/// class ExcludeSemantics extends SingleChildRenderObjectWidget
class ExcludeSemanticsMate {
  /// ExcludeSemantics ExcludeSemantics({Key? key, bool excluding = true, Widget? child})
  ExcludeSemanticsMate({
// param: {Key? key}
    Key? key,
// param: {bool excluding = true}
    required bool excluding,
// param: {Widget? child}
    Widget? child,
  }) {}
}

/// class IndexedSemantics extends SingleChildRenderObjectWidget
class IndexedSemanticsMate {
  /// IndexedSemantics IndexedSemantics({Key? key, required int index, Widget? child})
  IndexedSemanticsMate({
// param: {Key? key}
    Key? key,
// param: {required int index}
    required int index,
// param: {Widget? child}
    Widget? child,
  }) {}
}

/// class KeyedSubtree extends StatelessWidget
class KeyedSubtreeMate {
  /// KeyedSubtree KeyedSubtree({Key? key, required Widget child})
  KeyedSubtreeMate({
// param: {Key? key}
    Key? key,
// param: {required Widget child}
    required Widget child,
  }) {}
}

/// class Builder extends StatelessWidget
class BuilderMate {
  /// Builder Builder({Key? key, required Widget Function(BuildContext) builder})
  BuilderMate({
// param: {Key? key}
    Key? key,
// param: {required Widget Function(BuildContext) builder}
    required Widget Function(
      BuildContext, [
      BuildContext,
    ])
        builder,
  }) {}
}

/// class StatefulBuilder extends StatefulWidget
class StatefulBuilderMate {
  /// StatefulBuilder StatefulBuilder({Key? key, required Widget Function(BuildContext, void Function(void Function())) builder})
  StatefulBuilderMate({
// param: {Key? key}
    Key? key,
// param: {required Widget Function(BuildContext, void Function(void Function())) builder}
    required Widget Function(
      BuildContext,
      void Function(
        void Function(), [
        void Function(),
      ]), [
      BuildContext,
      void Function(
        void Function(), [
        void Function(),
      ]),
    ])
        builder,
  }) {}
}

/// class ColoredBox extends SingleChildRenderObjectWidget
class ColoredBoxMate {
  /// ColoredBox ColoredBox({required Color color, Widget? child, Key? key})
  ColoredBoxMate({
// param: {required Color color}
    required Color color,
// param: {Widget? child}
    Widget? child,
// param: {Key? key}
    Key? key,
  }) {}
}
