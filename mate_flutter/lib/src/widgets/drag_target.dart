// /// Generated by mat_flutter, please don't edit! Created time: 2023-03-09 00:16:01.561638

library;

import 'dart:core';
import 'package:flutter/src/foundation/key.dart';
import 'package:flutter/src/widgets/framework.dart';
import 'package:flutter/src/widgets/drag_target.dart';
import 'package:flutter/src/painting/basic_types.dart';
import 'dart:ui';
import 'package:flutter/src/gestures/drag_details.dart';
import 'package:flutter/src/gestures/velocity_tracker.dart';
import 'package:flutter/src/rendering/proxy_box.dart';

/// class Draggable<T extends Object> extends StatefulWidget
class DraggableMate<T extends Object> {
  /// Draggable<T> Draggable({Key? key, required Widget child, required Widget feedback, T? data, Axis? axis, Widget? childWhenDragging, Offset feedbackOffset = Offset.zero, Offset Function(Draggable<Object>, BuildContext, Offset) dragAnchorStrategy = childDragAnchorStrategy, Axis? affinity, int? maxSimultaneousDrags, void Function()? onDragStarted, void Function(DragUpdateDetails)? onDragUpdate, void Function(Velocity, Offset)? onDraggableCanceled, void Function(DraggableDetails)? onDragEnd, void Function()? onDragCompleted, bool ignoringFeedbackSemantics = true, bool ignoringFeedbackPointer = true, bool rootOverlay = false, HitTestBehavior hitTestBehavior = HitTestBehavior.deferToChild, bool Function(int)? allowedButtonsFilter})
  DraggableMate({
// param: {Key? key}
    Key? key,
// param: {required Widget child}
    required Widget child,
// param: {required Widget feedback}
    required Widget feedback,
// param: {T? data}
    T? data,
// param: {Axis? axis}
    Axis? axis,
// param: {Widget? childWhenDragging}
    Widget? childWhenDragging,
// param: {Offset feedbackOffset = Offset.zero}
    required Offset feedbackOffset,
// param: {Offset Function(Draggable<Object>, BuildContext, Offset) dragAnchorStrategy = childDragAnchorStrategy}
    required Offset Function(
      Draggable<Object>,
      BuildContext,
      Offset, [
      Draggable<Object>,
      BuildContext,
      Offset,
    ])
        dragAnchorStrategy,
// param: {Axis? affinity}
    Axis? affinity,
// param: {int? maxSimultaneousDrags}
    int? maxSimultaneousDrags,
// param: {void Function()? onDragStarted}
    void Function()? onDragStarted,
// param: {void Function(DragUpdateDetails)? onDragUpdate}
    void Function(
      DragUpdateDetails, [
      DragUpdateDetails,
    ])?
        onDragUpdate,
// param: {void Function(Velocity, Offset)? onDraggableCanceled}
    void Function(
      Velocity,
      Offset, [
      Velocity,
      Offset,
    ])?
        onDraggableCanceled,
// param: {void Function(DraggableDetails)? onDragEnd}
    void Function(
      DraggableDetails, [
      DraggableDetails,
    ])?
        onDragEnd,
// param: {void Function()? onDragCompleted}
    void Function()? onDragCompleted,
// param: {bool ignoringFeedbackSemantics = true}
    required bool ignoringFeedbackSemantics,
// param: {bool ignoringFeedbackPointer = true}
    required bool ignoringFeedbackPointer,
// param: {bool rootOverlay = false}
    required bool rootOverlay,
// param: {HitTestBehavior hitTestBehavior = HitTestBehavior.deferToChild}
    required HitTestBehavior hitTestBehavior,
// param: {bool Function(int)? allowedButtonsFilter}
    bool Function(
      int, [
      int,
    ])?
        allowedButtonsFilter,
  }) {}
}

/// class LongPressDraggable<T extends Object> extends Draggable<T>
class LongPressDraggableMate<T extends Object> {
  /// LongPressDraggable<T> LongPressDraggable({Key? key, required Widget child, required Widget feedback, T? data, Axis? axis, Widget? childWhenDragging, Offset feedbackOffset = Offset.zero, Offset Function(Draggable<Object>, BuildContext, Offset) dragAnchorStrategy = childDragAnchorStrategy, int? maxSimultaneousDrags, void Function()? onDragStarted, void Function(DragUpdateDetails)? onDragUpdate, void Function(Velocity, Offset)? onDraggableCanceled, void Function(DraggableDetails)? onDragEnd, void Function()? onDragCompleted, bool hapticFeedbackOnStart = true, bool ignoringFeedbackSemantics = true, bool ignoringFeedbackPointer = true, Duration delay = kLongPressTimeout, bool Function(int)? allowedButtonsFilter})
  LongPressDraggableMate({
// param: {Key? key}
    Key? key,
// param: {required Widget child}
    required Widget child,
// param: {required Widget feedback}
    required Widget feedback,
// param: {T? data}
    T? data,
// param: {Axis? axis}
    Axis? axis,
// param: {Widget? childWhenDragging}
    Widget? childWhenDragging,
// param: {Offset feedbackOffset = Offset.zero}
    required Offset feedbackOffset,
// param: {Offset Function(Draggable<Object>, BuildContext, Offset) dragAnchorStrategy = childDragAnchorStrategy}
    required Offset Function(
      Draggable<Object>,
      BuildContext,
      Offset, [
      Draggable<Object>,
      BuildContext,
      Offset,
    ])
        dragAnchorStrategy,
// param: {int? maxSimultaneousDrags}
    int? maxSimultaneousDrags,
// param: {void Function()? onDragStarted}
    void Function()? onDragStarted,
// param: {void Function(DragUpdateDetails)? onDragUpdate}
    void Function(
      DragUpdateDetails, [
      DragUpdateDetails,
    ])?
        onDragUpdate,
// param: {void Function(Velocity, Offset)? onDraggableCanceled}
    void Function(
      Velocity,
      Offset, [
      Velocity,
      Offset,
    ])?
        onDraggableCanceled,
// param: {void Function(DraggableDetails)? onDragEnd}
    void Function(
      DraggableDetails, [
      DraggableDetails,
    ])?
        onDragEnd,
// param: {void Function()? onDragCompleted}
    void Function()? onDragCompleted,
// param: {bool hapticFeedbackOnStart = true}
    required bool hapticFeedbackOnStart,
// param: {bool ignoringFeedbackSemantics = true}
    required bool ignoringFeedbackSemantics,
// param: {bool ignoringFeedbackPointer = true}
    required bool ignoringFeedbackPointer,
// param: {Duration delay = kLongPressTimeout}
    required Duration delay,
// param: {bool Function(int)? allowedButtonsFilter}
    bool Function(
      int, [
      int,
    ])?
        allowedButtonsFilter,
  }) {}
}

/// class DraggableDetails
class DraggableDetailsMate {
  /// DraggableDetails DraggableDetails({bool wasAccepted = false, required Velocity velocity, required Offset offset})
  DraggableDetailsMate({
// param: {bool wasAccepted = false}
    required bool wasAccepted,
// param: {required Velocity velocity}
    required Velocity velocity,
// param: {required Offset offset}
    required Offset offset,
  }) {}
}

/// class DragTargetDetails<T>
class DragTargetDetailsMate<T> {
  /// DragTargetDetails<T> DragTargetDetails({required T data, required Offset offset})
  DragTargetDetailsMate({
// param: {required T data}
    required T data,
// param: {required Offset offset}
    required Offset offset,
  }) {}
}

/// class DragTarget<T extends Object> extends StatefulWidget
class DragTargetMate<T extends Object> {
  /// DragTarget<T> DragTarget({Key? key, required Widget Function(BuildContext, List<T?>, List<dynamic>) builder, bool Function(T?)? onWillAccept, void Function(T)? onAccept, void Function(DragTargetDetails<T>)? onAcceptWithDetails, void Function(T?)? onLeave, void Function(DragTargetDetails<T>)? onMove, HitTestBehavior hitTestBehavior = HitTestBehavior.translucent})
  DragTargetMate({
// param: {Key? key}
    Key? key,
// param: {required Widget Function(BuildContext, List<T?>, List<dynamic>) builder}
    required Widget Function(
      BuildContext,
      List<T?>,
      List<dynamic>, [
      BuildContext,
      List<T?>,
      List<dynamic>,
    ])
        builder,
// param: {bool Function(T?)? onWillAccept}
    bool Function(
      T?, [
      T?,
    ])?
        onWillAccept,
// param: {void Function(T)? onAccept}
    void Function(
      T, [
      T,
    ])?
        onAccept,
// param: {void Function(DragTargetDetails<T>)? onAcceptWithDetails}
    void Function(
      DragTargetDetails<T>, [
      DragTargetDetails<T>,
    ])?
        onAcceptWithDetails,
// param: {void Function(T?)? onLeave}
    void Function(
      T?, [
      T?,
    ])?
        onLeave,
// param: {void Function(DragTargetDetails<T>)? onMove}
    void Function(
      DragTargetDetails<T>, [
      DragTargetDetails<T>,
    ])?
        onMove,
// param: {HitTestBehavior hitTestBehavior = HitTestBehavior.translucent}
    required HitTestBehavior hitTestBehavior,
  }) {}
}
