// /// Generated by gen_maters.dart, please don't edit!

import 'package:flutter/src/rendering/proxy_box.dart';
import 'package:flutter/src/rendering/box.dart';
import 'package:note/mate.dart';
import 'dart:core';
import 'package:flutter/src/animation/animation.dart';
import 'dart:ui';
import 'package:flutter/src/painting/borders.dart';
import 'package:flutter/src/painting/border_radius.dart';
import 'package:flutter/src/painting/box_border.dart';
import 'package:flutter/src/painting/decoration.dart';
import 'package:flutter/src/painting/image_provider.dart';
import 'package:vector_math/vector_math_64.dart';
import 'package:flutter/src/painting/alignment.dart';
import 'package:flutter/src/painting/box_fit.dart';
import 'package:flutter/src/services/mouse_tracking.dart';
import 'package:flutter/src/services/mouse_cursor.dart';
import 'package:flutter/src/gestures/tap.dart';
import 'package:flutter/src/gestures/long_press.dart';
import 'package:flutter/src/gestures/drag_details.dart';
import 'package:flutter/src/semantics/semantics.dart';
import 'package:flutter/src/rendering/layer.dart';

/// class RenderProxyBox extends RenderBox with RenderObjectWithChildMixin<RenderBox>, RenderProxyBoxMixin<RenderBox>
class RenderProxyBox$Mate extends RenderProxyBox with Mate<RenderProxyBox$Mate> {
  /// RenderProxyBox RenderProxyBox([RenderBox? child])
  RenderProxyBox$Mate(

      /// requiredParameters: [RenderBox? child]
      RenderBox? child)
      : super(child) {
    mateParams = Params(
      init: this,
      builder: (p) => RenderProxyBox$Mate(p.getValue('child')),
    );
    mateParams.set(name: 'child', init: child);
  }
}

/// class RenderConstrainedBox extends RenderProxyBox
class RenderConstrainedBox$Mate extends RenderConstrainedBox with Mate<RenderConstrainedBox$Mate> {
  /// RenderConstrainedBox RenderConstrainedBox({RenderBox? child, required BoxConstraints additionalConstraints})
  RenderConstrainedBox$Mate({
    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,

    /// optionalParameters: {required BoxConstraints additionalConstraints} , hasDefaultValue:false, defaultValueCode:null
    required BoxConstraints additionalConstraints,
  }) : super(
          child: child,
          additionalConstraints: additionalConstraints,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => RenderConstrainedBox$Mate(
        child: p.getValue('child'),
        additionalConstraints: p.getValue('additionalConstraints'),
      ),
    );
    mateParams.set(name: 'child', init: child);
    mateParams.set(name: 'additionalConstraints', init: additionalConstraints);
  }
}

/// class RenderLimitedBox extends RenderProxyBox
class RenderLimitedBox$Mate extends RenderLimitedBox with Mate<RenderLimitedBox$Mate> {
  /// RenderLimitedBox RenderLimitedBox({RenderBox? child, double maxWidth = double.infinity, double maxHeight = double.infinity})
  RenderLimitedBox$Mate({
    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,

    /// optionalParameters: {double maxWidth = double.infinity} , hasDefaultValue:true, defaultValueCode:double.infinity
    required double maxWidth,

    /// optionalParameters: {double maxHeight = double.infinity} , hasDefaultValue:true, defaultValueCode:double.infinity
    required double maxHeight,
  }) : super(
          child: child,
          maxWidth: maxWidth,
          maxHeight: maxHeight,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => RenderLimitedBox$Mate(
        child: p.getValue('child'),
        maxWidth: p.getValue('maxWidth'),
        maxHeight: p.getValue('maxHeight'),
      ),
    );
    mateParams.set(name: 'child', init: child);
    mateParams.set(name: 'maxWidth', init: maxWidth);
    mateParams.set(name: 'maxHeight', init: maxHeight);
  }
}

/// class RenderAspectRatio extends RenderProxyBox
class RenderAspectRatio$Mate extends RenderAspectRatio with Mate<RenderAspectRatio$Mate> {
  /// RenderAspectRatio RenderAspectRatio({RenderBox? child, required double aspectRatio})
  RenderAspectRatio$Mate({
    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,

    /// optionalParameters: {required double aspectRatio} , hasDefaultValue:false, defaultValueCode:null
    required double aspectRatio,
  }) : super(
          child: child,
          aspectRatio: aspectRatio,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => RenderAspectRatio$Mate(
        child: p.getValue('child'),
        aspectRatio: p.getValue('aspectRatio'),
      ),
    );
    mateParams.set(name: 'child', init: child);
    mateParams.set(name: 'aspectRatio', init: aspectRatio);
  }
}

/// class RenderIntrinsicWidth extends RenderProxyBox
class RenderIntrinsicWidth$Mate extends RenderIntrinsicWidth with Mate<RenderIntrinsicWidth$Mate> {
  /// RenderIntrinsicWidth RenderIntrinsicWidth({double? stepWidth, double? stepHeight, RenderBox? child})
  RenderIntrinsicWidth$Mate({
    /// optionalParameters: {double? stepWidth} , hasDefaultValue:false, defaultValueCode:null
    double? stepWidth,

    /// optionalParameters: {double? stepHeight} , hasDefaultValue:false, defaultValueCode:null
    double? stepHeight,

    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,
  }) : super(
          stepWidth: stepWidth,
          stepHeight: stepHeight,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => RenderIntrinsicWidth$Mate(
        stepWidth: p.getValue('stepWidth'),
        stepHeight: p.getValue('stepHeight'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'stepWidth', init: stepWidth);
    mateParams.set(name: 'stepHeight', init: stepHeight);
    mateParams.set(name: 'child', init: child);
  }
}

/// class RenderIntrinsicHeight extends RenderProxyBox
class RenderIntrinsicHeight$Mate extends RenderIntrinsicHeight with Mate<RenderIntrinsicHeight$Mate> {
  /// RenderIntrinsicHeight RenderIntrinsicHeight({RenderBox? child})
  RenderIntrinsicHeight$Mate(
      {
      /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
      RenderBox? child})
      : super(child: child) {
    mateParams = Params(
      init: this,
      builder: (p) => RenderIntrinsicHeight$Mate(child: p.getValue('child')),
    );
    mateParams.set(name: 'child', init: child);
  }
}

/// class RenderOpacity extends RenderProxyBox
class RenderOpacity$Mate extends RenderOpacity with Mate<RenderOpacity$Mate> {
  /// RenderOpacity RenderOpacity({double opacity = 1.0, bool alwaysIncludeSemantics = false, RenderBox? child})
  RenderOpacity$Mate({
    /// optionalParameters: {double opacity = 1.0} , hasDefaultValue:true, defaultValueCode:1.0
    required double opacity,

    /// optionalParameters: {bool alwaysIncludeSemantics = false} , hasDefaultValue:true, defaultValueCode:false
    required bool alwaysIncludeSemantics,

    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,
  }) : super(
          opacity: opacity,
          alwaysIncludeSemantics: alwaysIncludeSemantics,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => RenderOpacity$Mate(
        opacity: p.getValue('opacity'),
        alwaysIncludeSemantics: p.getValue('alwaysIncludeSemantics'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'opacity', init: opacity);
    mateParams.set(name: 'alwaysIncludeSemantics', init: alwaysIncludeSemantics);
    mateParams.set(name: 'child', init: child);
  }
}

/// class RenderAnimatedOpacity extends RenderProxyBox with RenderAnimatedOpacityMixin<RenderBox>
class RenderAnimatedOpacity$Mate extends RenderAnimatedOpacity with Mate<RenderAnimatedOpacity$Mate> {
  /// RenderAnimatedOpacity RenderAnimatedOpacity({required Animation<double> opacity, bool alwaysIncludeSemantics = false, RenderBox? child})
  RenderAnimatedOpacity$Mate({
    /// optionalParameters: {required Animation<double> opacity} , hasDefaultValue:false, defaultValueCode:null
    required Animation<double> opacity,

    /// optionalParameters: {bool alwaysIncludeSemantics = false} , hasDefaultValue:true, defaultValueCode:false
    required bool alwaysIncludeSemantics,

    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,
  }) : super(
          opacity: opacity,
          alwaysIncludeSemantics: alwaysIncludeSemantics,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => RenderAnimatedOpacity$Mate(
        opacity: p.getValue('opacity'),
        alwaysIncludeSemantics: p.getValue('alwaysIncludeSemantics'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'opacity', init: opacity);
    mateParams.set(name: 'alwaysIncludeSemantics', init: alwaysIncludeSemantics);
    mateParams.set(name: 'child', init: child);
  }
}

/// class RenderShaderMask extends RenderProxyBox
class RenderShaderMask$Mate extends RenderShaderMask with Mate<RenderShaderMask$Mate> {
  /// RenderShaderMask RenderShaderMask({RenderBox? child, required Shader Function(Rect) shaderCallback, BlendMode blendMode = BlendMode.modulate})
  RenderShaderMask$Mate({
    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,

    /// optionalParameters: {required Shader Function(Rect) shaderCallback} , hasDefaultValue:false, defaultValueCode:null
    required ShaderCallback shaderCallback,

    /// optionalParameters: {BlendMode blendMode = BlendMode.modulate} , hasDefaultValue:true, defaultValueCode:BlendMode.modulate
    required BlendMode blendMode,
  }) : super(
          child: child,
          shaderCallback: shaderCallback,
          blendMode: blendMode,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => RenderShaderMask$Mate(
        child: p.getValue('child'),
        shaderCallback: p.getValue('shaderCallback'),
        blendMode: p.getValue('blendMode'),
      ),
    );
    mateParams.set(name: 'child', init: child);
    mateParams.set(name: 'shaderCallback', init: shaderCallback);
    mateParams.set(name: 'blendMode', init: blendMode);
  }
}

/// class RenderBackdropFilter extends RenderProxyBox
class RenderBackdropFilter$Mate extends RenderBackdropFilter with Mate<RenderBackdropFilter$Mate> {
  /// RenderBackdropFilter RenderBackdropFilter({RenderBox? child, required ImageFilter filter, BlendMode blendMode = BlendMode.srcOver})
  RenderBackdropFilter$Mate({
    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,

    /// optionalParameters: {required ImageFilter filter} , hasDefaultValue:false, defaultValueCode:null
    required ImageFilter filter,

    /// optionalParameters: {BlendMode blendMode = BlendMode.srcOver} , hasDefaultValue:true, defaultValueCode:BlendMode.srcOver
    required BlendMode blendMode,
  }) : super(
          child: child,
          filter: filter,
          blendMode: blendMode,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => RenderBackdropFilter$Mate(
        child: p.getValue('child'),
        filter: p.getValue('filter'),
        blendMode: p.getValue('blendMode'),
      ),
    );
    mateParams.set(name: 'child', init: child);
    mateParams.set(name: 'filter', init: filter);
    mateParams.set(name: 'blendMode', init: blendMode);
  }
}

/// class ShapeBorderClipper extends CustomClipper<Path>
class ShapeBorderClipper$Mate extends ShapeBorderClipper with Mate<ShapeBorderClipper$Mate> {
  /// ShapeBorderClipper ShapeBorderClipper({required ShapeBorder shape, TextDirection? textDirection})
  ShapeBorderClipper$Mate({
    /// optionalParameters: {required ShapeBorder shape} , hasDefaultValue:false, defaultValueCode:null
    required ShapeBorder shape,

    /// optionalParameters: {TextDirection? textDirection} , hasDefaultValue:false, defaultValueCode:null
    TextDirection? textDirection,
  }) : super(
          shape: shape,
          textDirection: textDirection,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => ShapeBorderClipper$Mate(
        shape: p.getValue('shape'),
        textDirection: p.getValue('textDirection'),
      ),
    );
    mateParams.set(name: 'shape', init: shape);
    mateParams.set(name: 'textDirection', init: textDirection);
  }
}

/// class RenderClipRect extends _RenderCustomClip<Rect>
class RenderClipRect$Mate extends RenderClipRect with Mate<RenderClipRect$Mate> {
  /// RenderClipRect RenderClipRect({RenderBox? child, CustomClipper<Rect>? clipper, Clip clipBehavior = Clip.antiAlias})
  RenderClipRect$Mate({
    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,

    /// optionalParameters: {CustomClipper<Rect>? clipper} , hasDefaultValue:false, defaultValueCode:null
    CustomClipper<Rect>? clipper,

    /// optionalParameters: {Clip clipBehavior = Clip.antiAlias} , hasDefaultValue:true, defaultValueCode:Clip.antiAlias
    required Clip clipBehavior,
  }) : super(
          child: child,
          clipper: clipper,
          clipBehavior: clipBehavior,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => RenderClipRect$Mate(
        child: p.getValue('child'),
        clipper: p.getValue('clipper'),
        clipBehavior: p.getValue('clipBehavior'),
      ),
    );
    mateParams.set(name: 'child', init: child);
    mateParams.set(name: 'clipper', init: clipper);
    mateParams.set(name: 'clipBehavior', init: clipBehavior);
  }
}

/// class RenderClipRRect extends _RenderCustomClip<RRect>
class RenderClipRRect$Mate extends RenderClipRRect with Mate<RenderClipRRect$Mate> {
  /// RenderClipRRect RenderClipRRect({RenderBox? child, BorderRadiusGeometry borderRadius = BorderRadius.zero, CustomClipper<RRect>? clipper, Clip clipBehavior = Clip.antiAlias, TextDirection? textDirection})
  RenderClipRRect$Mate({
    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,

    /// optionalParameters: {BorderRadiusGeometry borderRadius = BorderRadius.zero} , hasDefaultValue:true, defaultValueCode:BorderRadius.zero
    required BorderRadiusGeometry borderRadius,

    /// optionalParameters: {CustomClipper<RRect>? clipper} , hasDefaultValue:false, defaultValueCode:null
    CustomClipper<RRect>? clipper,

    /// optionalParameters: {Clip clipBehavior = Clip.antiAlias} , hasDefaultValue:true, defaultValueCode:Clip.antiAlias
    required Clip clipBehavior,

    /// optionalParameters: {TextDirection? textDirection} , hasDefaultValue:false, defaultValueCode:null
    TextDirection? textDirection,
  }) : super(
          child: child,
          borderRadius: borderRadius,
          clipper: clipper,
          clipBehavior: clipBehavior,
          textDirection: textDirection,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => RenderClipRRect$Mate(
        child: p.getValue('child'),
        borderRadius: p.getValue('borderRadius'),
        clipper: p.getValue('clipper'),
        clipBehavior: p.getValue('clipBehavior'),
        textDirection: p.getValue('textDirection'),
      ),
    );
    mateParams.set(name: 'child', init: child);
    mateParams.set(name: 'borderRadius', init: borderRadius);
    mateParams.set(name: 'clipper', init: clipper);
    mateParams.set(name: 'clipBehavior', init: clipBehavior);
    mateParams.set(name: 'textDirection', init: textDirection);
  }
}

/// class RenderClipOval extends _RenderCustomClip<Rect>
class RenderClipOval$Mate extends RenderClipOval with Mate<RenderClipOval$Mate> {
  /// RenderClipOval RenderClipOval({RenderBox? child, CustomClipper<Rect>? clipper, Clip clipBehavior = Clip.antiAlias})
  RenderClipOval$Mate({
    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,

    /// optionalParameters: {CustomClipper<Rect>? clipper} , hasDefaultValue:false, defaultValueCode:null
    CustomClipper<Rect>? clipper,

    /// optionalParameters: {Clip clipBehavior = Clip.antiAlias} , hasDefaultValue:true, defaultValueCode:Clip.antiAlias
    required Clip clipBehavior,
  }) : super(
          child: child,
          clipper: clipper,
          clipBehavior: clipBehavior,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => RenderClipOval$Mate(
        child: p.getValue('child'),
        clipper: p.getValue('clipper'),
        clipBehavior: p.getValue('clipBehavior'),
      ),
    );
    mateParams.set(name: 'child', init: child);
    mateParams.set(name: 'clipper', init: clipper);
    mateParams.set(name: 'clipBehavior', init: clipBehavior);
  }
}

/// class RenderClipPath extends _RenderCustomClip<Path>
class RenderClipPath$Mate extends RenderClipPath with Mate<RenderClipPath$Mate> {
  /// RenderClipPath RenderClipPath({RenderBox? child, CustomClipper<Path>? clipper, Clip clipBehavior = Clip.antiAlias})
  RenderClipPath$Mate({
    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,

    /// optionalParameters: {CustomClipper<Path>? clipper} , hasDefaultValue:false, defaultValueCode:null
    CustomClipper<Path>? clipper,

    /// optionalParameters: {Clip clipBehavior = Clip.antiAlias} , hasDefaultValue:true, defaultValueCode:Clip.antiAlias
    required Clip clipBehavior,
  }) : super(
          child: child,
          clipper: clipper,
          clipBehavior: clipBehavior,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => RenderClipPath$Mate(
        child: p.getValue('child'),
        clipper: p.getValue('clipper'),
        clipBehavior: p.getValue('clipBehavior'),
      ),
    );
    mateParams.set(name: 'child', init: child);
    mateParams.set(name: 'clipper', init: clipper);
    mateParams.set(name: 'clipBehavior', init: clipBehavior);
  }
}

/// class RenderPhysicalModel extends _RenderPhysicalModelBase<RRect>
class RenderPhysicalModel$Mate extends RenderPhysicalModel with Mate<RenderPhysicalModel$Mate> {
  /// RenderPhysicalModel RenderPhysicalModel({RenderBox? child, BoxShape shape = BoxShape.rectangle, Clip clipBehavior = Clip.none, BorderRadius? borderRadius, double elevation = 0.0, required Color color, Color shadowColor = const Color(0xFF000000)})
  RenderPhysicalModel$Mate({
    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,

    /// optionalParameters: {BoxShape shape = BoxShape.rectangle} , hasDefaultValue:true, defaultValueCode:BoxShape.rectangle
    required BoxShape shape,

    /// optionalParameters: {Clip clipBehavior = Clip.none} , hasDefaultValue:true, defaultValueCode:Clip.none
    required Clip clipBehavior,

    /// optionalParameters: {BorderRadius? borderRadius} , hasDefaultValue:false, defaultValueCode:null
    BorderRadius? borderRadius,

    /// optionalParameters: {double elevation = 0.0} , hasDefaultValue:true, defaultValueCode:0.0
    required double elevation,

    /// optionalParameters: {required Color color} , hasDefaultValue:false, defaultValueCode:null
    required Color color,

    /// optionalParameters: {Color shadowColor = const Color(0xFF000000)} , hasDefaultValue:true, defaultValueCode:const Color(0xFF000000)
    required Color shadowColor,
  }) : super(
          child: child,
          shape: shape,
          clipBehavior: clipBehavior,
          borderRadius: borderRadius,
          elevation: elevation,
          color: color,
          shadowColor: shadowColor,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => RenderPhysicalModel$Mate(
        child: p.getValue('child'),
        shape: p.getValue('shape'),
        clipBehavior: p.getValue('clipBehavior'),
        borderRadius: p.getValue('borderRadius'),
        elevation: p.getValue('elevation'),
        color: p.getValue('color'),
        shadowColor: p.getValue('shadowColor'),
      ),
    );
    mateParams.set(name: 'child', init: child);
    mateParams.set(name: 'shape', init: shape);
    mateParams.set(name: 'clipBehavior', init: clipBehavior);
    mateParams.set(name: 'borderRadius', init: borderRadius);
    mateParams.set(name: 'elevation', init: elevation);
    mateParams.set(name: 'color', init: color);
    mateParams.set(name: 'shadowColor', init: shadowColor);
  }
}

/// class RenderPhysicalShape extends _RenderPhysicalModelBase<Path>
class RenderPhysicalShape$Mate extends RenderPhysicalShape with Mate<RenderPhysicalShape$Mate> {
  /// RenderPhysicalShape RenderPhysicalShape({RenderBox? child, required CustomClipper<Path> clipper, Clip clipBehavior = Clip.none, double elevation = 0.0, required Color color, Color shadowColor = const Color(0xFF000000)})
  RenderPhysicalShape$Mate({
    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,

    /// optionalParameters: {required CustomClipper<Path> clipper} , hasDefaultValue:false, defaultValueCode:null
    required CustomClipper<Path> clipper,

    /// optionalParameters: {Clip clipBehavior = Clip.none} , hasDefaultValue:true, defaultValueCode:Clip.none
    required Clip clipBehavior,

    /// optionalParameters: {double elevation = 0.0} , hasDefaultValue:true, defaultValueCode:0.0
    required double elevation,

    /// optionalParameters: {required Color color} , hasDefaultValue:false, defaultValueCode:null
    required Color color,

    /// optionalParameters: {Color shadowColor = const Color(0xFF000000)} , hasDefaultValue:true, defaultValueCode:const Color(0xFF000000)
    required Color shadowColor,
  }) : super(
          child: child,
          clipper: clipper,
          clipBehavior: clipBehavior,
          elevation: elevation,
          color: color,
          shadowColor: shadowColor,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => RenderPhysicalShape$Mate(
        child: p.getValue('child'),
        clipper: p.getValue('clipper'),
        clipBehavior: p.getValue('clipBehavior'),
        elevation: p.getValue('elevation'),
        color: p.getValue('color'),
        shadowColor: p.getValue('shadowColor'),
      ),
    );
    mateParams.set(name: 'child', init: child);
    mateParams.set(name: 'clipper', init: clipper);
    mateParams.set(name: 'clipBehavior', init: clipBehavior);
    mateParams.set(name: 'elevation', init: elevation);
    mateParams.set(name: 'color', init: color);
    mateParams.set(name: 'shadowColor', init: shadowColor);
  }
}

/// class RenderDecoratedBox extends RenderProxyBox
class RenderDecoratedBox$Mate extends RenderDecoratedBox with Mate<RenderDecoratedBox$Mate> {
  /// RenderDecoratedBox RenderDecoratedBox({required Decoration decoration, DecorationPosition position = DecorationPosition.background, ImageConfiguration configuration = ImageConfiguration.empty, RenderBox? child})
  RenderDecoratedBox$Mate({
    /// optionalParameters: {required Decoration decoration} , hasDefaultValue:false, defaultValueCode:null
    required Decoration decoration,

    /// optionalParameters: {DecorationPosition position = DecorationPosition.background} , hasDefaultValue:true, defaultValueCode:DecorationPosition.background
    required DecorationPosition position,

    /// optionalParameters: {ImageConfiguration configuration = ImageConfiguration.empty} , hasDefaultValue:true, defaultValueCode:ImageConfiguration.empty
    required ImageConfiguration configuration,

    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,
  }) : super(
          decoration: decoration,
          position: position,
          configuration: configuration,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => RenderDecoratedBox$Mate(
        decoration: p.getValue('decoration'),
        position: p.getValue('position'),
        configuration: p.getValue('configuration'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'decoration', init: decoration);
    mateParams.set(name: 'position', init: position);
    mateParams.set(name: 'configuration', init: configuration);
    mateParams.set(name: 'child', init: child);
  }
}

/// class RenderTransform extends RenderProxyBox
class RenderTransform$Mate extends RenderTransform with Mate<RenderTransform$Mate> {
  /// RenderTransform RenderTransform({required Matrix4 transform, Offset? origin, AlignmentGeometry? alignment, TextDirection? textDirection, bool transformHitTests = true, FilterQuality? filterQuality, RenderBox? child})
  RenderTransform$Mate({
    /// optionalParameters: {required Matrix4 transform} , hasDefaultValue:false, defaultValueCode:null
    required Matrix4 transform,

    /// optionalParameters: {Offset? origin} , hasDefaultValue:false, defaultValueCode:null
    Offset? origin,

    /// optionalParameters: {AlignmentGeometry? alignment} , hasDefaultValue:false, defaultValueCode:null
    AlignmentGeometry? alignment,

    /// optionalParameters: {TextDirection? textDirection} , hasDefaultValue:false, defaultValueCode:null
    TextDirection? textDirection,

    /// optionalParameters: {bool transformHitTests = true} , hasDefaultValue:true, defaultValueCode:true
    required bool transformHitTests,

    /// optionalParameters: {FilterQuality? filterQuality} , hasDefaultValue:false, defaultValueCode:null
    FilterQuality? filterQuality,

    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,
  }) : super(
          transform: transform,
          origin: origin,
          alignment: alignment,
          textDirection: textDirection,
          transformHitTests: transformHitTests,
          filterQuality: filterQuality,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => RenderTransform$Mate(
        transform: p.getValue('transform'),
        origin: p.getValue('origin'),
        alignment: p.getValue('alignment'),
        textDirection: p.getValue('textDirection'),
        transformHitTests: p.getValue('transformHitTests'),
        filterQuality: p.getValue('filterQuality'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'transform', init: transform);
    mateParams.set(name: 'origin', init: origin);
    mateParams.set(name: 'alignment', init: alignment);
    mateParams.set(name: 'textDirection', init: textDirection);
    mateParams.set(name: 'transformHitTests', init: transformHitTests);
    mateParams.set(name: 'filterQuality', init: filterQuality);
    mateParams.set(name: 'child', init: child);
  }
}

/// class RenderFittedBox extends RenderProxyBox
class RenderFittedBox$Mate extends RenderFittedBox with Mate<RenderFittedBox$Mate> {
  /// RenderFittedBox RenderFittedBox({BoxFit fit = BoxFit.contain, AlignmentGeometry alignment = Alignment.center, TextDirection? textDirection, RenderBox? child, Clip clipBehavior = Clip.none})
  RenderFittedBox$Mate({
    /// optionalParameters: {BoxFit fit = BoxFit.contain} , hasDefaultValue:true, defaultValueCode:BoxFit.contain
    required BoxFit fit,

    /// optionalParameters: {AlignmentGeometry alignment = Alignment.center} , hasDefaultValue:true, defaultValueCode:Alignment.center
    required AlignmentGeometry alignment,

    /// optionalParameters: {TextDirection? textDirection} , hasDefaultValue:false, defaultValueCode:null
    TextDirection? textDirection,

    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,

    /// optionalParameters: {Clip clipBehavior = Clip.none} , hasDefaultValue:true, defaultValueCode:Clip.none
    required Clip clipBehavior,
  }) : super(
          fit: fit,
          alignment: alignment,
          textDirection: textDirection,
          child: child,
          clipBehavior: clipBehavior,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => RenderFittedBox$Mate(
        fit: p.getValue('fit'),
        alignment: p.getValue('alignment'),
        textDirection: p.getValue('textDirection'),
        child: p.getValue('child'),
        clipBehavior: p.getValue('clipBehavior'),
      ),
    );
    mateParams.set(name: 'fit', init: fit);
    mateParams.set(name: 'alignment', init: alignment);
    mateParams.set(name: 'textDirection', init: textDirection);
    mateParams.set(name: 'child', init: child);
    mateParams.set(name: 'clipBehavior', init: clipBehavior);
  }
}

/// class RenderFractionalTranslation extends RenderProxyBox
class RenderFractionalTranslation$Mate extends RenderFractionalTranslation with Mate<RenderFractionalTranslation$Mate> {
  /// RenderFractionalTranslation RenderFractionalTranslation({required Offset translation, bool transformHitTests = true, RenderBox? child})
  RenderFractionalTranslation$Mate({
    /// optionalParameters: {required Offset translation} , hasDefaultValue:false, defaultValueCode:null
    required Offset translation,

    /// optionalParameters: {bool transformHitTests = true} , hasDefaultValue:true, defaultValueCode:true
    required bool transformHitTests,

    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,
  }) : super(
          translation: translation,
          transformHitTests: transformHitTests,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => RenderFractionalTranslation$Mate(
        translation: p.getValue('translation'),
        transformHitTests: p.getValue('transformHitTests'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'translation', init: translation);
    mateParams.set(name: 'transformHitTests', init: transformHitTests);
    mateParams.set(name: 'child', init: child);
  }
}

/// class RenderPointerListener extends RenderProxyBoxWithHitTestBehavior
class RenderPointerListener$Mate extends RenderPointerListener with Mate<RenderPointerListener$Mate> {
  /// RenderPointerListener RenderPointerListener({void Function(PointerDownEvent)? onPointerDown, void Function(PointerMoveEvent)? onPointerMove, void Function(PointerUpEvent)? onPointerUp, void Function(PointerHoverEvent)? onPointerHover, void Function(PointerCancelEvent)? onPointerCancel, void Function(PointerPanZoomStartEvent)? onPointerPanZoomStart, void Function(PointerPanZoomUpdateEvent)? onPointerPanZoomUpdate, void Function(PointerPanZoomEndEvent)? onPointerPanZoomEnd, void Function(PointerSignalEvent)? onPointerSignal, HitTestBehavior behavior = HitTestBehavior.deferToChild, RenderBox? child})
  RenderPointerListener$Mate({
    /// optionalParameters: {void Function(PointerDownEvent)? onPointerDown} , hasDefaultValue:false, defaultValueCode:null
    PointerDownEventListener? onPointerDown,

    /// optionalParameters: {void Function(PointerMoveEvent)? onPointerMove} , hasDefaultValue:false, defaultValueCode:null
    PointerMoveEventListener? onPointerMove,

    /// optionalParameters: {void Function(PointerUpEvent)? onPointerUp} , hasDefaultValue:false, defaultValueCode:null
    PointerUpEventListener? onPointerUp,

    /// optionalParameters: {void Function(PointerHoverEvent)? onPointerHover} , hasDefaultValue:false, defaultValueCode:null
    PointerHoverEventListener? onPointerHover,

    /// optionalParameters: {void Function(PointerCancelEvent)? onPointerCancel} , hasDefaultValue:false, defaultValueCode:null
    PointerCancelEventListener? onPointerCancel,

    /// optionalParameters: {void Function(PointerPanZoomStartEvent)? onPointerPanZoomStart} , hasDefaultValue:false, defaultValueCode:null
    PointerPanZoomStartEventListener? onPointerPanZoomStart,

    /// optionalParameters: {void Function(PointerPanZoomUpdateEvent)? onPointerPanZoomUpdate} , hasDefaultValue:false, defaultValueCode:null
    PointerPanZoomUpdateEventListener? onPointerPanZoomUpdate,

    /// optionalParameters: {void Function(PointerPanZoomEndEvent)? onPointerPanZoomEnd} , hasDefaultValue:false, defaultValueCode:null
    PointerPanZoomEndEventListener? onPointerPanZoomEnd,

    /// optionalParameters: {void Function(PointerSignalEvent)? onPointerSignal} , hasDefaultValue:false, defaultValueCode:null
    PointerSignalEventListener? onPointerSignal,

    /// optionalParameters: {HitTestBehavior behavior = HitTestBehavior.deferToChild} , hasDefaultValue:true, defaultValueCode:HitTestBehavior.deferToChild
    required HitTestBehavior behavior,

    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,
  }) : super(
          onPointerDown: onPointerDown,
          onPointerMove: onPointerMove,
          onPointerUp: onPointerUp,
          onPointerHover: onPointerHover,
          onPointerCancel: onPointerCancel,
          onPointerPanZoomStart: onPointerPanZoomStart,
          onPointerPanZoomUpdate: onPointerPanZoomUpdate,
          onPointerPanZoomEnd: onPointerPanZoomEnd,
          onPointerSignal: onPointerSignal,
          behavior: behavior,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => RenderPointerListener$Mate(
        onPointerDown: p.getValue('onPointerDown'),
        onPointerMove: p.getValue('onPointerMove'),
        onPointerUp: p.getValue('onPointerUp'),
        onPointerHover: p.getValue('onPointerHover'),
        onPointerCancel: p.getValue('onPointerCancel'),
        onPointerPanZoomStart: p.getValue('onPointerPanZoomStart'),
        onPointerPanZoomUpdate: p.getValue('onPointerPanZoomUpdate'),
        onPointerPanZoomEnd: p.getValue('onPointerPanZoomEnd'),
        onPointerSignal: p.getValue('onPointerSignal'),
        behavior: p.getValue('behavior'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'onPointerDown', init: onPointerDown);
    mateParams.set(name: 'onPointerMove', init: onPointerMove);
    mateParams.set(name: 'onPointerUp', init: onPointerUp);
    mateParams.set(name: 'onPointerHover', init: onPointerHover);
    mateParams.set(name: 'onPointerCancel', init: onPointerCancel);
    mateParams.set(name: 'onPointerPanZoomStart', init: onPointerPanZoomStart);
    mateParams.set(name: 'onPointerPanZoomUpdate', init: onPointerPanZoomUpdate);
    mateParams.set(name: 'onPointerPanZoomEnd', init: onPointerPanZoomEnd);
    mateParams.set(name: 'onPointerSignal', init: onPointerSignal);
    mateParams.set(name: 'behavior', init: behavior);
    mateParams.set(name: 'child', init: child);
  }
}

/// class RenderMouseRegion extends RenderProxyBoxWithHitTestBehavior implements MouseTrackerAnnotation
class RenderMouseRegion$Mate extends RenderMouseRegion with Mate<RenderMouseRegion$Mate> {
  /// RenderMouseRegion RenderMouseRegion({void Function(PointerEnterEvent)? onEnter, void Function(PointerHoverEvent)? onHover, void Function(PointerExitEvent)? onExit, MouseCursor cursor = MouseCursor.defer, bool validForMouseTracker = true, bool opaque = true, RenderBox? child, HitTestBehavior? hitTestBehavior = HitTestBehavior.opaque})
  RenderMouseRegion$Mate({
    /// optionalParameters: {void Function(PointerEnterEvent)? onEnter} , hasDefaultValue:false, defaultValueCode:null
    PointerEnterEventListener? onEnter,

    /// optionalParameters: {void Function(PointerHoverEvent)? onHover} , hasDefaultValue:false, defaultValueCode:null
    PointerHoverEventListener? onHover,

    /// optionalParameters: {void Function(PointerExitEvent)? onExit} , hasDefaultValue:false, defaultValueCode:null
    PointerExitEventListener? onExit,

    /// optionalParameters: {MouseCursor cursor = MouseCursor.defer} , hasDefaultValue:true, defaultValueCode:MouseCursor.defer
    required MouseCursor cursor,

    /// optionalParameters: {bool validForMouseTracker = true} , hasDefaultValue:true, defaultValueCode:true
    required bool validForMouseTracker,

    /// optionalParameters: {bool opaque = true} , hasDefaultValue:true, defaultValueCode:true
    required bool opaque,

    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,

    /// optionalParameters: {HitTestBehavior? hitTestBehavior = HitTestBehavior.opaque} , hasDefaultValue:true, defaultValueCode:HitTestBehavior.opaque
    HitTestBehavior? hitTestBehavior,
  }) : super(
          onEnter: onEnter,
          onHover: onHover,
          onExit: onExit,
          cursor: cursor,
          validForMouseTracker: validForMouseTracker,
          opaque: opaque,
          child: child,
          hitTestBehavior: hitTestBehavior,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => RenderMouseRegion$Mate(
        onEnter: p.getValue('onEnter'),
        onHover: p.getValue('onHover'),
        onExit: p.getValue('onExit'),
        cursor: p.getValue('cursor'),
        validForMouseTracker: p.getValue('validForMouseTracker'),
        opaque: p.getValue('opaque'),
        child: p.getValue('child'),
        hitTestBehavior: p.getValue('hitTestBehavior'),
      ),
    );
    mateParams.set(name: 'onEnter', init: onEnter);
    mateParams.set(name: 'onHover', init: onHover);
    mateParams.set(name: 'onExit', init: onExit);
    mateParams.set(name: 'cursor', init: cursor);
    mateParams.set(name: 'validForMouseTracker', init: validForMouseTracker);
    mateParams.set(name: 'opaque', init: opaque);
    mateParams.set(name: 'child', init: child);
    mateParams.set(name: 'hitTestBehavior', init: hitTestBehavior);
  }
}

/// class RenderRepaintBoundary extends RenderProxyBox
class RenderRepaintBoundary$Mate extends RenderRepaintBoundary with Mate<RenderRepaintBoundary$Mate> {
  /// RenderRepaintBoundary RenderRepaintBoundary({RenderBox? child})
  RenderRepaintBoundary$Mate(
      {
      /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
      RenderBox? child})
      : super(child: child) {
    mateParams = Params(
      init: this,
      builder: (p) => RenderRepaintBoundary$Mate(child: p.getValue('child')),
    );
    mateParams.set(name: 'child', init: child);
  }
}

/// class RenderIgnorePointer extends RenderProxyBox
class RenderIgnorePointer$Mate extends RenderIgnorePointer with Mate<RenderIgnorePointer$Mate> {
  /// RenderIgnorePointer RenderIgnorePointer({RenderBox? child, bool ignoring = true, bool? ignoringSemantics})
  RenderIgnorePointer$Mate({
    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,

    /// optionalParameters: {bool ignoring = true} , hasDefaultValue:true, defaultValueCode:true
    required bool ignoring,

    /// optionalParameters: {bool? ignoringSemantics} , hasDefaultValue:false, defaultValueCode:null
    bool? ignoringSemantics,
  }) : super(
          child: child,
          ignoring: ignoring,
          ignoringSemantics: ignoringSemantics,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => RenderIgnorePointer$Mate(
        child: p.getValue('child'),
        ignoring: p.getValue('ignoring'),
        ignoringSemantics: p.getValue('ignoringSemantics'),
      ),
    );
    mateParams.set(name: 'child', init: child);
    mateParams.set(name: 'ignoring', init: ignoring);
    mateParams.set(name: 'ignoringSemantics', init: ignoringSemantics);
  }
}

/// class RenderOffstage extends RenderProxyBox
class RenderOffstage$Mate extends RenderOffstage with Mate<RenderOffstage$Mate> {
  /// RenderOffstage RenderOffstage({bool offstage = true, RenderBox? child})
  RenderOffstage$Mate({
    /// optionalParameters: {bool offstage = true} , hasDefaultValue:true, defaultValueCode:true
    required bool offstage,

    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,
  }) : super(
          offstage: offstage,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => RenderOffstage$Mate(
        offstage: p.getValue('offstage'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'offstage', init: offstage);
    mateParams.set(name: 'child', init: child);
  }
}

/// class RenderAbsorbPointer extends RenderProxyBox
class RenderAbsorbPointer$Mate extends RenderAbsorbPointer with Mate<RenderAbsorbPointer$Mate> {
  /// RenderAbsorbPointer RenderAbsorbPointer({RenderBox? child, bool absorbing = true, bool? ignoringSemantics})
  RenderAbsorbPointer$Mate({
    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,

    /// optionalParameters: {bool absorbing = true} , hasDefaultValue:true, defaultValueCode:true
    required bool absorbing,

    /// optionalParameters: {bool? ignoringSemantics} , hasDefaultValue:false, defaultValueCode:null
    bool? ignoringSemantics,
  }) : super(
          child: child,
          absorbing: absorbing,
          ignoringSemantics: ignoringSemantics,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => RenderAbsorbPointer$Mate(
        child: p.getValue('child'),
        absorbing: p.getValue('absorbing'),
        ignoringSemantics: p.getValue('ignoringSemantics'),
      ),
    );
    mateParams.set(name: 'child', init: child);
    mateParams.set(name: 'absorbing', init: absorbing);
    mateParams.set(name: 'ignoringSemantics', init: ignoringSemantics);
  }
}

/// class RenderMetaData extends RenderProxyBoxWithHitTestBehavior
class RenderMetaData$Mate extends RenderMetaData with Mate<RenderMetaData$Mate> {
  /// RenderMetaData RenderMetaData({dynamic metaData, HitTestBehavior behavior = HitTestBehavior.deferToChild, RenderBox? child})
  RenderMetaData$Mate({
    /// optionalParameters: {dynamic metaData} , hasDefaultValue:false, defaultValueCode:null
    required dynamic metaData,

    /// optionalParameters: {HitTestBehavior behavior = HitTestBehavior.deferToChild} , hasDefaultValue:true, defaultValueCode:HitTestBehavior.deferToChild
    required HitTestBehavior behavior,

    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,
  }) : super(
          metaData: metaData,
          behavior: behavior,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => RenderMetaData$Mate(
        metaData: p.getValue('metaData'),
        behavior: p.getValue('behavior'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'metaData', init: metaData);
    mateParams.set(name: 'behavior', init: behavior);
    mateParams.set(name: 'child', init: child);
  }
}

/// class RenderSemanticsGestureHandler extends RenderProxyBoxWithHitTestBehavior
class RenderSemanticsGestureHandler$Mate extends RenderSemanticsGestureHandler
    with Mate<RenderSemanticsGestureHandler$Mate> {
  /// RenderSemanticsGestureHandler RenderSemanticsGestureHandler({RenderBox? child, void Function()? onTap, void Function()? onLongPress, void Function(DragUpdateDetails)? onHorizontalDragUpdate, void Function(DragUpdateDetails)? onVerticalDragUpdate, double scrollFactor = 0.8, HitTestBehavior behavior = HitTestBehavior.deferToChild})
  RenderSemanticsGestureHandler$Mate({
    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,

    /// optionalParameters: {void Function()? onTap} , hasDefaultValue:false, defaultValueCode:null
    GestureTapCallback? onTap,

    /// optionalParameters: {void Function()? onLongPress} , hasDefaultValue:false, defaultValueCode:null
    GestureLongPressCallback? onLongPress,

    /// optionalParameters: {void Function(DragUpdateDetails)? onHorizontalDragUpdate} , hasDefaultValue:false, defaultValueCode:null
    GestureDragUpdateCallback? onHorizontalDragUpdate,

    /// optionalParameters: {void Function(DragUpdateDetails)? onVerticalDragUpdate} , hasDefaultValue:false, defaultValueCode:null
    GestureDragUpdateCallback? onVerticalDragUpdate,

    /// optionalParameters: {double scrollFactor = 0.8} , hasDefaultValue:true, defaultValueCode:0.8
    required double scrollFactor,

    /// optionalParameters: {HitTestBehavior behavior = HitTestBehavior.deferToChild} , hasDefaultValue:true, defaultValueCode:HitTestBehavior.deferToChild
    required HitTestBehavior behavior,
  }) : super(
          child: child,
          onTap: onTap,
          onLongPress: onLongPress,
          onHorizontalDragUpdate: onHorizontalDragUpdate,
          onVerticalDragUpdate: onVerticalDragUpdate,
          scrollFactor: scrollFactor,
          behavior: behavior,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => RenderSemanticsGestureHandler$Mate(
        child: p.getValue('child'),
        onTap: p.getValue('onTap'),
        onLongPress: p.getValue('onLongPress'),
        onHorizontalDragUpdate: p.getValue('onHorizontalDragUpdate'),
        onVerticalDragUpdate: p.getValue('onVerticalDragUpdate'),
        scrollFactor: p.getValue('scrollFactor'),
        behavior: p.getValue('behavior'),
      ),
    );
    mateParams.set(name: 'child', init: child);
    mateParams.set(name: 'onTap', init: onTap);
    mateParams.set(name: 'onLongPress', init: onLongPress);
    mateParams.set(name: 'onHorizontalDragUpdate', init: onHorizontalDragUpdate);
    mateParams.set(name: 'onVerticalDragUpdate', init: onVerticalDragUpdate);
    mateParams.set(name: 'scrollFactor', init: scrollFactor);
    mateParams.set(name: 'behavior', init: behavior);
  }
}

/// class RenderSemanticsAnnotations extends RenderProxyBox
class RenderSemanticsAnnotations$Mate extends RenderSemanticsAnnotations with Mate<RenderSemanticsAnnotations$Mate> {
  /// RenderSemanticsAnnotations RenderSemanticsAnnotations({RenderBox? child, required SemanticsProperties properties, bool container = false, bool explicitChildNodes = false, bool excludeSemantics = false, TextDirection? textDirection})
  RenderSemanticsAnnotations$Mate({
    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,

    /// optionalParameters: {required SemanticsProperties properties} , hasDefaultValue:false, defaultValueCode:null
    required SemanticsProperties properties,

    /// optionalParameters: {bool container = false} , hasDefaultValue:true, defaultValueCode:false
    required bool container,

    /// optionalParameters: {bool explicitChildNodes = false} , hasDefaultValue:true, defaultValueCode:false
    required bool explicitChildNodes,

    /// optionalParameters: {bool excludeSemantics = false} , hasDefaultValue:true, defaultValueCode:false
    required bool excludeSemantics,

    /// optionalParameters: {TextDirection? textDirection} , hasDefaultValue:false, defaultValueCode:null
    TextDirection? textDirection,
  }) : super(
          child: child,
          properties: properties,
          container: container,
          explicitChildNodes: explicitChildNodes,
          excludeSemantics: excludeSemantics,
          textDirection: textDirection,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => RenderSemanticsAnnotations$Mate(
        child: p.getValue('child'),
        properties: p.getValue('properties'),
        container: p.getValue('container'),
        explicitChildNodes: p.getValue('explicitChildNodes'),
        excludeSemantics: p.getValue('excludeSemantics'),
        textDirection: p.getValue('textDirection'),
      ),
    );
    mateParams.set(name: 'child', init: child);
    mateParams.set(name: 'properties', init: properties);
    mateParams.set(name: 'container', init: container);
    mateParams.set(name: 'explicitChildNodes', init: explicitChildNodes);
    mateParams.set(name: 'excludeSemantics', init: excludeSemantics);
    mateParams.set(name: 'textDirection', init: textDirection);
  }
}

/// class RenderBlockSemantics extends RenderProxyBox
class RenderBlockSemantics$Mate extends RenderBlockSemantics with Mate<RenderBlockSemantics$Mate> {
  /// RenderBlockSemantics RenderBlockSemantics({RenderBox? child, bool blocking = true})
  RenderBlockSemantics$Mate({
    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,

    /// optionalParameters: {bool blocking = true} , hasDefaultValue:true, defaultValueCode:true
    required bool blocking,
  }) : super(
          child: child,
          blocking: blocking,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => RenderBlockSemantics$Mate(
        child: p.getValue('child'),
        blocking: p.getValue('blocking'),
      ),
    );
    mateParams.set(name: 'child', init: child);
    mateParams.set(name: 'blocking', init: blocking);
  }
}

/// class RenderMergeSemantics extends RenderProxyBox
class RenderMergeSemantics$Mate extends RenderMergeSemantics with Mate<RenderMergeSemantics$Mate> {
  /// RenderMergeSemantics RenderMergeSemantics({RenderBox? child})
  RenderMergeSemantics$Mate(
      {
      /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
      RenderBox? child})
      : super(child: child) {
    mateParams = Params(
      init: this,
      builder: (p) => RenderMergeSemantics$Mate(child: p.getValue('child')),
    );
    mateParams.set(name: 'child', init: child);
  }
}

/// class RenderExcludeSemantics extends RenderProxyBox
class RenderExcludeSemantics$Mate extends RenderExcludeSemantics with Mate<RenderExcludeSemantics$Mate> {
  /// RenderExcludeSemantics RenderExcludeSemantics({RenderBox? child, bool excluding = true})
  RenderExcludeSemantics$Mate({
    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,

    /// optionalParameters: {bool excluding = true} , hasDefaultValue:true, defaultValueCode:true
    required bool excluding,
  }) : super(
          child: child,
          excluding: excluding,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => RenderExcludeSemantics$Mate(
        child: p.getValue('child'),
        excluding: p.getValue('excluding'),
      ),
    );
    mateParams.set(name: 'child', init: child);
    mateParams.set(name: 'excluding', init: excluding);
  }
}

/// class RenderIndexedSemantics extends RenderProxyBox
class RenderIndexedSemantics$Mate extends RenderIndexedSemantics with Mate<RenderIndexedSemantics$Mate> {
  /// RenderIndexedSemantics RenderIndexedSemantics({RenderBox? child, required int index})
  RenderIndexedSemantics$Mate({
    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,

    /// optionalParameters: {required int index} , hasDefaultValue:false, defaultValueCode:null
    required int index,
  }) : super(
          child: child,
          index: index,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => RenderIndexedSemantics$Mate(
        child: p.getValue('child'),
        index: p.getValue('index'),
      ),
    );
    mateParams.set(name: 'child', init: child);
    mateParams.set(name: 'index', init: index);
  }
}

/// class RenderLeaderLayer extends RenderProxyBox
class RenderLeaderLayer$Mate extends RenderLeaderLayer with Mate<RenderLeaderLayer$Mate> {
  /// RenderLeaderLayer RenderLeaderLayer({required LayerLink link, RenderBox? child})
  RenderLeaderLayer$Mate({
    /// optionalParameters: {required LayerLink link} , hasDefaultValue:false, defaultValueCode:null
    required LayerLink link,

    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,
  }) : super(
          link: link,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => RenderLeaderLayer$Mate(
        link: p.getValue('link'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'link', init: link);
    mateParams.set(name: 'child', init: child);
  }
}

/// class RenderFollowerLayer extends RenderProxyBox
class RenderFollowerLayer$Mate extends RenderFollowerLayer with Mate<RenderFollowerLayer$Mate> {
  /// RenderFollowerLayer RenderFollowerLayer({required LayerLink link, bool showWhenUnlinked = true, Offset offset = Offset.zero, Alignment leaderAnchor = Alignment.topLeft, Alignment followerAnchor = Alignment.topLeft, RenderBox? child})
  RenderFollowerLayer$Mate({
    /// optionalParameters: {required LayerLink link} , hasDefaultValue:false, defaultValueCode:null
    required LayerLink link,

    /// optionalParameters: {bool showWhenUnlinked = true} , hasDefaultValue:true, defaultValueCode:true
    required bool showWhenUnlinked,

    /// optionalParameters: {Offset offset = Offset.zero} , hasDefaultValue:true, defaultValueCode:Offset.zero
    required Offset offset,

    /// optionalParameters: {Alignment leaderAnchor = Alignment.topLeft} , hasDefaultValue:true, defaultValueCode:Alignment.topLeft
    required Alignment leaderAnchor,

    /// optionalParameters: {Alignment followerAnchor = Alignment.topLeft} , hasDefaultValue:true, defaultValueCode:Alignment.topLeft
    required Alignment followerAnchor,

    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,
  }) : super(
          link: link,
          showWhenUnlinked: showWhenUnlinked,
          offset: offset,
          leaderAnchor: leaderAnchor,
          followerAnchor: followerAnchor,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => RenderFollowerLayer$Mate(
        link: p.getValue('link'),
        showWhenUnlinked: p.getValue('showWhenUnlinked'),
        offset: p.getValue('offset'),
        leaderAnchor: p.getValue('leaderAnchor'),
        followerAnchor: p.getValue('followerAnchor'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'link', init: link);
    mateParams.set(name: 'showWhenUnlinked', init: showWhenUnlinked);
    mateParams.set(name: 'offset', init: offset);
    mateParams.set(name: 'leaderAnchor', init: leaderAnchor);
    mateParams.set(name: 'followerAnchor', init: followerAnchor);
    mateParams.set(name: 'child', init: child);
  }
}

/// class RenderAnnotatedRegion<T extends Object> extends RenderProxyBox
class RenderAnnotatedRegion$Mate<T extends Object> extends RenderAnnotatedRegion<T>
    with Mate<RenderAnnotatedRegion$Mate> {
  /// RenderAnnotatedRegion<T> RenderAnnotatedRegion({required T value, required bool sized, RenderBox? child})
  RenderAnnotatedRegion$Mate({
    /// optionalParameters: {required T value} , hasDefaultValue:false, defaultValueCode:null
    required T value,

    /// optionalParameters: {required bool sized} , hasDefaultValue:false, defaultValueCode:null
    required bool sized,

    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,
  }) : super(
          value: value,
          sized: sized,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => RenderAnnotatedRegion$Mate(
        value: p.getValue('value'),
        sized: p.getValue('sized'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'value', init: value);
    mateParams.set(name: 'sized', init: sized);
    mateParams.set(name: 'child', init: child);
  }
}
