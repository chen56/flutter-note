// /// Generated by mate_flutter, please don't edit!

import 'dart:core';
import 'package:flutter/src/widgets/drag_target.dart';
import 'package:flutter/src/foundation/key.dart';
import 'package:flutter/src/widgets/framework.dart';
import 'package:flutter/src/painting/basic_types.dart';
import 'dart:ui';
import 'package:flutter/src/rendering/proxy_box.dart';
import 'package:flutter/src/gestures/recognizer.dart';
import 'package:note/mate.dart';
import 'package:flutter/src/gestures/velocity_tracker.dart';

/// class Draggable<T extends Object> extends StatefulWidget
class Draggable$Mate<T extends Object> extends Draggable<T> with WidgetMate<Draggable$Mate> {
  /// Draggable<T> Draggable({Key? key, required Widget child, required Widget feedback, T? data, Axis? axis, Widget? childWhenDragging, Offset feedbackOffset = Offset.zero, Offset Function(Draggable<Object>, BuildContext, Offset) dragAnchorStrategy = childDragAnchorStrategy, Axis? affinity, int? maxSimultaneousDrags, void Function()? onDragStarted, void Function(DragUpdateDetails)? onDragUpdate, void Function(Velocity, Offset)? onDraggableCanceled, void Function(DraggableDetails)? onDragEnd, void Function()? onDragCompleted, bool ignoringFeedbackSemantics = true, bool ignoringFeedbackPointer = true, bool rootOverlay = false, HitTestBehavior hitTestBehavior = HitTestBehavior.deferToChild, bool Function(int)? allowedButtonsFilter})
  Draggable$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required Widget child}
    required Widget child,

    /// param: {required Widget feedback}
    required Widget feedback,

    /// param: {T? data}
    T? data,

    /// param: {Axis? axis}
    Axis? axis,

    /// param: {Widget? childWhenDragging}
    Widget? childWhenDragging,

    /// param: {Offset feedbackOffset = Offset.zero}
    required Offset feedbackOffset,

    /// param: {Offset Function(Draggable<Object>, BuildContext, Offset) dragAnchorStrategy = childDragAnchorStrategy}
    required DragAnchorStrategy dragAnchorStrategy,

    /// param: {Axis? affinity}
    Axis? affinity,

    /// param: {int? maxSimultaneousDrags}
    int? maxSimultaneousDrags,

    /// param: {void Function()? onDragStarted}
    VoidCallback? onDragStarted,

    /// param: {void Function(DragUpdateDetails)? onDragUpdate}
    DragUpdateCallback? onDragUpdate,

    /// param: {void Function(Velocity, Offset)? onDraggableCanceled}
    DraggableCanceledCallback? onDraggableCanceled,

    /// param: {void Function(DraggableDetails)? onDragEnd}
    DragEndCallback? onDragEnd,

    /// param: {void Function()? onDragCompleted}
    VoidCallback? onDragCompleted,

    /// param: {bool ignoringFeedbackSemantics = true}
    required bool ignoringFeedbackSemantics,

    /// param: {bool ignoringFeedbackPointer = true}
    required bool ignoringFeedbackPointer,

    /// param: {bool rootOverlay = false}
    required bool rootOverlay,

    /// param: {HitTestBehavior hitTestBehavior = HitTestBehavior.deferToChild}
    required HitTestBehavior hitTestBehavior,

    /// param: {bool Function(int)? allowedButtonsFilter}
    AllowedButtonsFilter? allowedButtonsFilter,
  }) : super(
          key: key,
          child: child,
          feedback: feedback,
          data: data,
          axis: axis,
          childWhenDragging: childWhenDragging,
          feedbackOffset: feedbackOffset,
          dragAnchorStrategy: dragAnchorStrategy,
          affinity: affinity,
          maxSimultaneousDrags: maxSimultaneousDrags,
          onDragStarted: onDragStarted,
          onDragUpdate: onDragUpdate,
          onDraggableCanceled: onDraggableCanceled,
          onDragEnd: onDragEnd,
          onDragCompleted: onDragCompleted,
          ignoringFeedbackSemantics: ignoringFeedbackSemantics,
          ignoringFeedbackPointer: ignoringFeedbackPointer,
          rootOverlay: rootOverlay,
          hitTestBehavior: hitTestBehavior,
          allowedButtonsFilter: allowedButtonsFilter,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Draggable$Mate(
        key: p.getValue('key'),
        child: p.getValue('child'),
        feedback: p.getValue('feedback'),
        data: p.getValue('data'),
        axis: p.getValue('axis'),
        childWhenDragging: p.getValue('childWhenDragging'),
        feedbackOffset: p.getValue('feedbackOffset'),
        dragAnchorStrategy: p.getValue('dragAnchorStrategy'),
        affinity: p.getValue('affinity'),
        maxSimultaneousDrags: p.getValue('maxSimultaneousDrags'),
        onDragStarted: p.getValue('onDragStarted'),
        onDragUpdate: p.getValue('onDragUpdate'),
        onDraggableCanceled: p.getValue('onDraggableCanceled'),
        onDragEnd: p.getValue('onDragEnd'),
        onDragCompleted: p.getValue('onDragCompleted'),
        ignoringFeedbackSemantics: p.getValue('ignoringFeedbackSemantics'),
        ignoringFeedbackPointer: p.getValue('ignoringFeedbackPointer'),
        rootOverlay: p.getValue('rootOverlay'),
        hitTestBehavior: p.getValue('hitTestBehavior'),
        allowedButtonsFilter: p.getValue('allowedButtonsFilter'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'child', init: child);
    mateParams.set(name: 'feedback', init: feedback);
    mateParams.set(name: 'data', init: data);
    mateParams.set(name: 'axis', init: axis);
    mateParams.set(name: 'childWhenDragging', init: childWhenDragging);
    mateParams.set(name: 'feedbackOffset', init: feedbackOffset);
    mateParams.set(name: 'dragAnchorStrategy', init: dragAnchorStrategy);
    mateParams.set(name: 'affinity', init: affinity);
    mateParams.set(name: 'maxSimultaneousDrags', init: maxSimultaneousDrags);
    mateParams.set(name: 'onDragStarted', init: onDragStarted);
    mateParams.set(name: 'onDragUpdate', init: onDragUpdate);
    mateParams.set(name: 'onDraggableCanceled', init: onDraggableCanceled);
    mateParams.set(name: 'onDragEnd', init: onDragEnd);
    mateParams.set(name: 'onDragCompleted', init: onDragCompleted);
    mateParams.set(name: 'ignoringFeedbackSemantics', init: ignoringFeedbackSemantics);
    mateParams.set(name: 'ignoringFeedbackPointer', init: ignoringFeedbackPointer);
    mateParams.set(name: 'rootOverlay', init: rootOverlay);
    mateParams.set(name: 'hitTestBehavior', init: hitTestBehavior);
    mateParams.set(name: 'allowedButtonsFilter', init: allowedButtonsFilter);
  }
}

/// class LongPressDraggable<T extends Object> extends Draggable<T>
class LongPressDraggable$Mate<T extends Object> extends LongPressDraggable<T> with WidgetMate<LongPressDraggable$Mate> {
  /// LongPressDraggable<T> LongPressDraggable({Key? key, required Widget child, required Widget feedback, T? data, Axis? axis, Widget? childWhenDragging, Offset feedbackOffset = Offset.zero, Offset Function(Draggable<Object>, BuildContext, Offset) dragAnchorStrategy = childDragAnchorStrategy, int? maxSimultaneousDrags, void Function()? onDragStarted, void Function(DragUpdateDetails)? onDragUpdate, void Function(Velocity, Offset)? onDraggableCanceled, void Function(DraggableDetails)? onDragEnd, void Function()? onDragCompleted, bool hapticFeedbackOnStart = true, bool ignoringFeedbackSemantics = true, bool ignoringFeedbackPointer = true, Duration delay = kLongPressTimeout, bool Function(int)? allowedButtonsFilter})
  LongPressDraggable$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required Widget child}
    required Widget child,

    /// param: {required Widget feedback}
    required Widget feedback,

    /// param: {T? data}
    T? data,

    /// param: {Axis? axis}
    Axis? axis,

    /// param: {Widget? childWhenDragging}
    Widget? childWhenDragging,

    /// param: {Offset feedbackOffset = Offset.zero}
    required Offset feedbackOffset,

    /// param: {Offset Function(Draggable<Object>, BuildContext, Offset) dragAnchorStrategy = childDragAnchorStrategy}
    required DragAnchorStrategy dragAnchorStrategy,

    /// param: {int? maxSimultaneousDrags}
    int? maxSimultaneousDrags,

    /// param: {void Function()? onDragStarted}
    VoidCallback? onDragStarted,

    /// param: {void Function(DragUpdateDetails)? onDragUpdate}
    DragUpdateCallback? onDragUpdate,

    /// param: {void Function(Velocity, Offset)? onDraggableCanceled}
    DraggableCanceledCallback? onDraggableCanceled,

    /// param: {void Function(DraggableDetails)? onDragEnd}
    DragEndCallback? onDragEnd,

    /// param: {void Function()? onDragCompleted}
    VoidCallback? onDragCompleted,

    /// param: {bool hapticFeedbackOnStart = true}
    required bool hapticFeedbackOnStart,

    /// param: {bool ignoringFeedbackSemantics = true}
    required bool ignoringFeedbackSemantics,

    /// param: {bool ignoringFeedbackPointer = true}
    required bool ignoringFeedbackPointer,

    /// param: {Duration delay = kLongPressTimeout}
    required Duration delay,

    /// param: {bool Function(int)? allowedButtonsFilter}
    AllowedButtonsFilter? allowedButtonsFilter,
  }) : super(
          key: key,
          child: child,
          feedback: feedback,
          data: data,
          axis: axis,
          childWhenDragging: childWhenDragging,
          feedbackOffset: feedbackOffset,
          dragAnchorStrategy: dragAnchorStrategy,
          maxSimultaneousDrags: maxSimultaneousDrags,
          onDragStarted: onDragStarted,
          onDragUpdate: onDragUpdate,
          onDraggableCanceled: onDraggableCanceled,
          onDragEnd: onDragEnd,
          onDragCompleted: onDragCompleted,
          hapticFeedbackOnStart: hapticFeedbackOnStart,
          ignoringFeedbackSemantics: ignoringFeedbackSemantics,
          ignoringFeedbackPointer: ignoringFeedbackPointer,
          delay: delay,
          allowedButtonsFilter: allowedButtonsFilter,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => LongPressDraggable$Mate(
        key: p.getValue('key'),
        child: p.getValue('child'),
        feedback: p.getValue('feedback'),
        data: p.getValue('data'),
        axis: p.getValue('axis'),
        childWhenDragging: p.getValue('childWhenDragging'),
        feedbackOffset: p.getValue('feedbackOffset'),
        dragAnchorStrategy: p.getValue('dragAnchorStrategy'),
        maxSimultaneousDrags: p.getValue('maxSimultaneousDrags'),
        onDragStarted: p.getValue('onDragStarted'),
        onDragUpdate: p.getValue('onDragUpdate'),
        onDraggableCanceled: p.getValue('onDraggableCanceled'),
        onDragEnd: p.getValue('onDragEnd'),
        onDragCompleted: p.getValue('onDragCompleted'),
        hapticFeedbackOnStart: p.getValue('hapticFeedbackOnStart'),
        ignoringFeedbackSemantics: p.getValue('ignoringFeedbackSemantics'),
        ignoringFeedbackPointer: p.getValue('ignoringFeedbackPointer'),
        delay: p.getValue('delay'),
        allowedButtonsFilter: p.getValue('allowedButtonsFilter'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'child', init: child);
    mateParams.set(name: 'feedback', init: feedback);
    mateParams.set(name: 'data', init: data);
    mateParams.set(name: 'axis', init: axis);
    mateParams.set(name: 'childWhenDragging', init: childWhenDragging);
    mateParams.set(name: 'feedbackOffset', init: feedbackOffset);
    mateParams.set(name: 'dragAnchorStrategy', init: dragAnchorStrategy);
    mateParams.set(name: 'maxSimultaneousDrags', init: maxSimultaneousDrags);
    mateParams.set(name: 'onDragStarted', init: onDragStarted);
    mateParams.set(name: 'onDragUpdate', init: onDragUpdate);
    mateParams.set(name: 'onDraggableCanceled', init: onDraggableCanceled);
    mateParams.set(name: 'onDragEnd', init: onDragEnd);
    mateParams.set(name: 'onDragCompleted', init: onDragCompleted);
    mateParams.set(name: 'hapticFeedbackOnStart', init: hapticFeedbackOnStart);
    mateParams.set(name: 'ignoringFeedbackSemantics', init: ignoringFeedbackSemantics);
    mateParams.set(name: 'ignoringFeedbackPointer', init: ignoringFeedbackPointer);
    mateParams.set(name: 'delay', init: delay);
    mateParams.set(name: 'allowedButtonsFilter', init: allowedButtonsFilter);
  }
}

/// class DraggableDetails
class DraggableDetails$Mate extends DraggableDetails with Mate<DraggableDetails$Mate> {
  /// DraggableDetails DraggableDetails({bool wasAccepted = false, required Velocity velocity, required Offset offset})
  DraggableDetails$Mate({
    /// param: {bool wasAccepted = false}
    required bool wasAccepted,

    /// param: {required Velocity velocity}
    required Velocity velocity,

    /// param: {required Offset offset}
    required Offset offset,
  }) : super(
          wasAccepted: wasAccepted,
          velocity: velocity,
          offset: offset,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => DraggableDetails$Mate(
        wasAccepted: p.getValue('wasAccepted'),
        velocity: p.getValue('velocity'),
        offset: p.getValue('offset'),
      ),
    );
    mateParams.set(name: 'wasAccepted', init: wasAccepted);
    mateParams.set(name: 'velocity', init: velocity);
    mateParams.set(name: 'offset', init: offset);
  }
}

/// class DragTargetDetails<T>
class DragTargetDetails$Mate<T> extends DragTargetDetails<T> with Mate<DragTargetDetails$Mate> {
  /// DragTargetDetails<T> DragTargetDetails({required T data, required Offset offset})
  DragTargetDetails$Mate({
    /// param: {required T data}
    required T data,

    /// param: {required Offset offset}
    required Offset offset,
  }) : super(
          data: data,
          offset: offset,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => DragTargetDetails$Mate(
        data: p.getValue('data'),
        offset: p.getValue('offset'),
      ),
    );
    mateParams.set(name: 'data', init: data);
    mateParams.set(name: 'offset', init: offset);
  }
}

/// class DragTarget<T extends Object> extends StatefulWidget
class DragTarget$Mate<T extends Object> extends DragTarget<T> with WidgetMate<DragTarget$Mate> {
  /// DragTarget<T> DragTarget({Key? key, required Widget Function(BuildContext, List<T?>, List<dynamic>) builder, bool Function(T?)? onWillAccept, void Function(T)? onAccept, void Function(DragTargetDetails<T>)? onAcceptWithDetails, void Function(T?)? onLeave, void Function(DragTargetDetails<T>)? onMove, HitTestBehavior hitTestBehavior = HitTestBehavior.translucent})
  DragTarget$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required Widget Function(BuildContext, List<T?>, List<dynamic>) builder}
    required DragTargetBuilder<T> builder,

    /// param: {bool Function(T?)? onWillAccept}
    DragTargetWillAccept<T>? onWillAccept,

    /// param: {void Function(T)? onAccept}
    DragTargetAccept<T>? onAccept,

    /// param: {void Function(DragTargetDetails<T>)? onAcceptWithDetails}
    DragTargetAcceptWithDetails<T>? onAcceptWithDetails,

    /// param: {void Function(T?)? onLeave}
    DragTargetLeave<T>? onLeave,

    /// param: {void Function(DragTargetDetails<T>)? onMove}
    DragTargetMove<T>? onMove,

    /// param: {HitTestBehavior hitTestBehavior = HitTestBehavior.translucent}
    required HitTestBehavior hitTestBehavior,
  }) : super(
          key: key,
          builder: builder,
          onWillAccept: onWillAccept,
          onAccept: onAccept,
          onAcceptWithDetails: onAcceptWithDetails,
          onLeave: onLeave,
          onMove: onMove,
          hitTestBehavior: hitTestBehavior,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => DragTarget$Mate(
        key: p.getValue('key'),
        builder: p.getValue('builder'),
        onWillAccept: p.getValue('onWillAccept'),
        onAccept: p.getValue('onAccept'),
        onAcceptWithDetails: p.getValue('onAcceptWithDetails'),
        onLeave: p.getValue('onLeave'),
        onMove: p.getValue('onMove'),
        hitTestBehavior: p.getValue('hitTestBehavior'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'builder', init: builder);
    mateParams.set(name: 'onWillAccept', init: onWillAccept);
    mateParams.set(name: 'onAccept', init: onAccept);
    mateParams.set(name: 'onAcceptWithDetails', init: onAcceptWithDetails);
    mateParams.set(name: 'onLeave', init: onLeave);
    mateParams.set(name: 'onMove', init: onMove);
    mateParams.set(name: 'hitTestBehavior', init: hitTestBehavior);
  }
}
