// /// Generated by gen_maters.dart, please don't edit!

import 'package:flutter/src/widgets/basic.dart';
import 'package:flutter/src/foundation/key.dart';
import 'dart:ui';
import 'package:flutter/src/widgets/framework.dart';
import 'package:note/mate.dart';
import 'dart:core';
import 'package:flutter/src/rendering/proxy_box.dart';
import 'package:flutter/src/rendering/custom_paint.dart';
import 'package:flutter/src/painting/border_radius.dart';
import 'package:flutter/src/painting/box_border.dart';
import 'package:vector_math/vector_math_64.dart';
import 'package:flutter/src/painting/alignment.dart';
import 'package:flutter/src/rendering/layer.dart';
import 'package:flutter/src/painting/box_fit.dart';
import 'package:flutter/src/painting/edge_insets.dart';
import 'package:flutter/src/rendering/shifted_box.dart';
import 'package:flutter/src/rendering/custom_layout.dart';
import 'package:flutter/src/rendering/box.dart';
import 'package:flutter/src/painting/basic_types.dart';
import 'package:flutter/src/rendering/stack.dart';
import 'package:flutter/src/rendering/flex.dart';
import 'package:flutter/src/rendering/wrap.dart';
import 'package:flutter/src/rendering/flow.dart';
import 'package:flutter/src/painting/inline_span.dart';
import 'package:flutter/src/painting/text_painter.dart';
import 'package:flutter/src/painting/strut_style.dart';
import 'package:flutter/src/rendering/selection.dart';
import 'package:flutter/src/animation/animation.dart';
import 'package:flutter/src/painting/decoration_image.dart';
import 'package:flutter/src/services/asset_bundle.dart';
import 'package:flutter/src/services/mouse_tracking.dart';
import 'package:flutter/src/services/mouse_cursor.dart';
import 'package:flutter/src/semantics/semantics.dart';
export 'package:flutter/animation.dart';
export 'package:flutter/painting.dart';

/// class Directionality extends _UbiquitousInheritedWidget
class Directionality$Mate extends Directionality with WidgetMate<Directionality$Mate> {
  /// Directionality Directionality({Key? key, required TextDirection textDirection, required Widget child})
  Directionality$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {required TextDirection textDirection} , hasDefaultValue:false, defaultValueCode:null
    required TextDirection textDirection,

    /// optionalParameters: {required Widget child} , hasDefaultValue:false, defaultValueCode:null
    required Widget child,
  }) : super(
          key: key,
          textDirection: textDirection,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Directionality$Mate(
        key: p.getValue('key'),
        textDirection: p.getValue('textDirection'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'textDirection', init: textDirection);
    mateParams.set(name: 'child', init: child);
  }
}

/// class Opacity extends SingleChildRenderObjectWidget
class Opacity$Mate extends Opacity with WidgetMate<Opacity$Mate> {
  /// Opacity Opacity({Key? key, required double opacity, bool alwaysIncludeSemantics = false, Widget? child})
  Opacity$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {required double opacity} , hasDefaultValue:false, defaultValueCode:null
    required double opacity,

    /// optionalParameters: {bool alwaysIncludeSemantics = false} , hasDefaultValue:true, defaultValueCode:false
    required bool alwaysIncludeSemantics,

    /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
    Widget? child,
  }) : super(
          key: key,
          opacity: opacity,
          alwaysIncludeSemantics: alwaysIncludeSemantics,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Opacity$Mate(
        key: p.getValue('key'),
        opacity: p.getValue('opacity'),
        alwaysIncludeSemantics: p.getValue('alwaysIncludeSemantics'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'opacity', init: opacity);
    mateParams.set(name: 'alwaysIncludeSemantics', init: alwaysIncludeSemantics);
    mateParams.set(name: 'child', init: child);
  }
}

/// class ShaderMask extends SingleChildRenderObjectWidget
class ShaderMask$Mate extends ShaderMask with WidgetMate<ShaderMask$Mate> {
  /// ShaderMask ShaderMask({Key? key, required Shader Function(Rect) shaderCallback, BlendMode blendMode = BlendMode.modulate, Widget? child})
  ShaderMask$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {required Shader Function(Rect) shaderCallback} , hasDefaultValue:false, defaultValueCode:null
    required ShaderCallback shaderCallback,

    /// optionalParameters: {BlendMode blendMode = BlendMode.modulate} , hasDefaultValue:true, defaultValueCode:BlendMode.modulate
    required BlendMode blendMode,

    /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
    Widget? child,
  }) : super(
          key: key,
          shaderCallback: shaderCallback,
          blendMode: blendMode,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => ShaderMask$Mate(
        key: p.getValue('key'),
        shaderCallback: p.getValue('shaderCallback'),
        blendMode: p.getValue('blendMode'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'shaderCallback', init: shaderCallback);
    mateParams.set(name: 'blendMode', init: blendMode);
    mateParams.set(name: 'child', init: child);
  }
}

/// class BackdropFilter extends SingleChildRenderObjectWidget
class BackdropFilter$Mate extends BackdropFilter with WidgetMate<BackdropFilter$Mate> {
  /// BackdropFilter BackdropFilter({Key? key, required ImageFilter filter, Widget? child, BlendMode blendMode = BlendMode.srcOver})
  BackdropFilter$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {required ImageFilter filter} , hasDefaultValue:false, defaultValueCode:null
    required ImageFilter filter,

    /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
    Widget? child,

    /// optionalParameters: {BlendMode blendMode = BlendMode.srcOver} , hasDefaultValue:true, defaultValueCode:BlendMode.srcOver
    required BlendMode blendMode,
  }) : super(
          key: key,
          filter: filter,
          child: child,
          blendMode: blendMode,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => BackdropFilter$Mate(
        key: p.getValue('key'),
        filter: p.getValue('filter'),
        child: p.getValue('child'),
        blendMode: p.getValue('blendMode'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'filter', init: filter);
    mateParams.set(name: 'child', init: child);
    mateParams.set(name: 'blendMode', init: blendMode);
  }
}

/// class CustomPaint extends SingleChildRenderObjectWidget
class CustomPaint$Mate extends CustomPaint with WidgetMate<CustomPaint$Mate> {
  /// CustomPaint CustomPaint({Key? key, CustomPainter? painter, CustomPainter? foregroundPainter, Size size = Size.zero, bool isComplex = false, bool willChange = false, Widget? child})
  CustomPaint$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {CustomPainter? painter} , hasDefaultValue:false, defaultValueCode:null
    CustomPainter? painter,

    /// optionalParameters: {CustomPainter? foregroundPainter} , hasDefaultValue:false, defaultValueCode:null
    CustomPainter? foregroundPainter,

    /// optionalParameters: {Size size = Size.zero} , hasDefaultValue:true, defaultValueCode:Size.zero
    required Size size,

    /// optionalParameters: {bool isComplex = false} , hasDefaultValue:true, defaultValueCode:false
    required bool isComplex,

    /// optionalParameters: {bool willChange = false} , hasDefaultValue:true, defaultValueCode:false
    required bool willChange,

    /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
    Widget? child,
  }) : super(
          key: key,
          painter: painter,
          foregroundPainter: foregroundPainter,
          size: size,
          isComplex: isComplex,
          willChange: willChange,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => CustomPaint$Mate(
        key: p.getValue('key'),
        painter: p.getValue('painter'),
        foregroundPainter: p.getValue('foregroundPainter'),
        size: p.getValue('size'),
        isComplex: p.getValue('isComplex'),
        willChange: p.getValue('willChange'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'painter', init: painter);
    mateParams.set(name: 'foregroundPainter', init: foregroundPainter);
    mateParams.set(name: 'size', init: size);
    mateParams.set(name: 'isComplex', init: isComplex);
    mateParams.set(name: 'willChange', init: willChange);
    mateParams.set(name: 'child', init: child);
  }
}

/// class ClipRect extends SingleChildRenderObjectWidget
class ClipRect$Mate extends ClipRect with WidgetMate<ClipRect$Mate> {
  /// ClipRect ClipRect({Key? key, CustomClipper<Rect>? clipper, Clip clipBehavior = Clip.hardEdge, Widget? child})
  ClipRect$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {CustomClipper<Rect>? clipper} , hasDefaultValue:false, defaultValueCode:null
    CustomClipper<Rect>? clipper,

    /// optionalParameters: {Clip clipBehavior = Clip.hardEdge} , hasDefaultValue:true, defaultValueCode:Clip.hardEdge
    required Clip clipBehavior,

    /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
    Widget? child,
  }) : super(
          key: key,
          clipper: clipper,
          clipBehavior: clipBehavior,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => ClipRect$Mate(
        key: p.getValue('key'),
        clipper: p.getValue('clipper'),
        clipBehavior: p.getValue('clipBehavior'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'clipper', init: clipper);
    mateParams.set(name: 'clipBehavior', init: clipBehavior);
    mateParams.set(name: 'child', init: child);
  }
}

/// class ClipRRect extends SingleChildRenderObjectWidget
class ClipRRect$Mate extends ClipRRect with WidgetMate<ClipRRect$Mate> {
  /// ClipRRect ClipRRect({Key? key, BorderRadiusGeometry? borderRadius = BorderRadius.zero, CustomClipper<RRect>? clipper, Clip clipBehavior = Clip.antiAlias, Widget? child})
  ClipRRect$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {BorderRadiusGeometry? borderRadius = BorderRadius.zero} , hasDefaultValue:true, defaultValueCode:BorderRadius.zero
    BorderRadiusGeometry? borderRadius,

    /// optionalParameters: {CustomClipper<RRect>? clipper} , hasDefaultValue:false, defaultValueCode:null
    CustomClipper<RRect>? clipper,

    /// optionalParameters: {Clip clipBehavior = Clip.antiAlias} , hasDefaultValue:true, defaultValueCode:Clip.antiAlias
    required Clip clipBehavior,

    /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
    Widget? child,
  }) : super(
          key: key,
          borderRadius: borderRadius,
          clipper: clipper,
          clipBehavior: clipBehavior,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => ClipRRect$Mate(
        key: p.getValue('key'),
        borderRadius: p.getValue('borderRadius'),
        clipper: p.getValue('clipper'),
        clipBehavior: p.getValue('clipBehavior'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'borderRadius', init: borderRadius);
    mateParams.set(name: 'clipper', init: clipper);
    mateParams.set(name: 'clipBehavior', init: clipBehavior);
    mateParams.set(name: 'child', init: child);
  }
}

/// class ClipOval extends SingleChildRenderObjectWidget
class ClipOval$Mate extends ClipOval with WidgetMate<ClipOval$Mate> {
  /// ClipOval ClipOval({Key? key, CustomClipper<Rect>? clipper, Clip clipBehavior = Clip.antiAlias, Widget? child})
  ClipOval$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {CustomClipper<Rect>? clipper} , hasDefaultValue:false, defaultValueCode:null
    CustomClipper<Rect>? clipper,

    /// optionalParameters: {Clip clipBehavior = Clip.antiAlias} , hasDefaultValue:true, defaultValueCode:Clip.antiAlias
    required Clip clipBehavior,

    /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
    Widget? child,
  }) : super(
          key: key,
          clipper: clipper,
          clipBehavior: clipBehavior,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => ClipOval$Mate(
        key: p.getValue('key'),
        clipper: p.getValue('clipper'),
        clipBehavior: p.getValue('clipBehavior'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'clipper', init: clipper);
    mateParams.set(name: 'clipBehavior', init: clipBehavior);
    mateParams.set(name: 'child', init: child);
  }
}

/// class ClipPath extends SingleChildRenderObjectWidget
class ClipPath$Mate extends ClipPath with WidgetMate<ClipPath$Mate> {
  /// ClipPath ClipPath({Key? key, CustomClipper<Path>? clipper, Clip clipBehavior = Clip.antiAlias, Widget? child})
  ClipPath$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {CustomClipper<Path>? clipper} , hasDefaultValue:false, defaultValueCode:null
    CustomClipper<Path>? clipper,

    /// optionalParameters: {Clip clipBehavior = Clip.antiAlias} , hasDefaultValue:true, defaultValueCode:Clip.antiAlias
    required Clip clipBehavior,

    /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
    Widget? child,
  }) : super(
          key: key,
          clipper: clipper,
          clipBehavior: clipBehavior,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => ClipPath$Mate(
        key: p.getValue('key'),
        clipper: p.getValue('clipper'),
        clipBehavior: p.getValue('clipBehavior'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'clipper', init: clipper);
    mateParams.set(name: 'clipBehavior', init: clipBehavior);
    mateParams.set(name: 'child', init: child);
  }
}

/// class PhysicalModel extends SingleChildRenderObjectWidget
class PhysicalModel$Mate extends PhysicalModel with WidgetMate<PhysicalModel$Mate> {
  /// PhysicalModel PhysicalModel({Key? key, BoxShape shape = BoxShape.rectangle, Clip clipBehavior = Clip.none, BorderRadius? borderRadius, double elevation = 0.0, required Color color, Color shadowColor = const Color(0xFF000000), Widget? child})
  PhysicalModel$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {BoxShape shape = BoxShape.rectangle} , hasDefaultValue:true, defaultValueCode:BoxShape.rectangle
    required BoxShape shape,

    /// optionalParameters: {Clip clipBehavior = Clip.none} , hasDefaultValue:true, defaultValueCode:Clip.none
    required Clip clipBehavior,

    /// optionalParameters: {BorderRadius? borderRadius} , hasDefaultValue:false, defaultValueCode:null
    BorderRadius? borderRadius,

    /// optionalParameters: {double elevation = 0.0} , hasDefaultValue:true, defaultValueCode:0.0
    required double elevation,

    /// optionalParameters: {required Color color} , hasDefaultValue:false, defaultValueCode:null
    required Color color,

    /// optionalParameters: {Color shadowColor = const Color(0xFF000000)} , hasDefaultValue:true, defaultValueCode:const Color(0xFF000000)
    required Color shadowColor,

    /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
    Widget? child,
  }) : super(
          key: key,
          shape: shape,
          clipBehavior: clipBehavior,
          borderRadius: borderRadius,
          elevation: elevation,
          color: color,
          shadowColor: shadowColor,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => PhysicalModel$Mate(
        key: p.getValue('key'),
        shape: p.getValue('shape'),
        clipBehavior: p.getValue('clipBehavior'),
        borderRadius: p.getValue('borderRadius'),
        elevation: p.getValue('elevation'),
        color: p.getValue('color'),
        shadowColor: p.getValue('shadowColor'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'shape', init: shape);
    mateParams.set(name: 'clipBehavior', init: clipBehavior);
    mateParams.set(name: 'borderRadius', init: borderRadius);
    mateParams.set(name: 'elevation', init: elevation);
    mateParams.set(name: 'color', init: color);
    mateParams.set(name: 'shadowColor', init: shadowColor);
    mateParams.set(name: 'child', init: child);
  }
}

/// class PhysicalShape extends SingleChildRenderObjectWidget
class PhysicalShape$Mate extends PhysicalShape with WidgetMate<PhysicalShape$Mate> {
  /// PhysicalShape PhysicalShape({Key? key, required CustomClipper<Path> clipper, Clip clipBehavior = Clip.none, double elevation = 0.0, required Color color, Color shadowColor = const Color(0xFF000000), Widget? child})
  PhysicalShape$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {required CustomClipper<Path> clipper} , hasDefaultValue:false, defaultValueCode:null
    required CustomClipper<Path> clipper,

    /// optionalParameters: {Clip clipBehavior = Clip.none} , hasDefaultValue:true, defaultValueCode:Clip.none
    required Clip clipBehavior,

    /// optionalParameters: {double elevation = 0.0} , hasDefaultValue:true, defaultValueCode:0.0
    required double elevation,

    /// optionalParameters: {required Color color} , hasDefaultValue:false, defaultValueCode:null
    required Color color,

    /// optionalParameters: {Color shadowColor = const Color(0xFF000000)} , hasDefaultValue:true, defaultValueCode:const Color(0xFF000000)
    required Color shadowColor,

    /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
    Widget? child,
  }) : super(
          key: key,
          clipper: clipper,
          clipBehavior: clipBehavior,
          elevation: elevation,
          color: color,
          shadowColor: shadowColor,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => PhysicalShape$Mate(
        key: p.getValue('key'),
        clipper: p.getValue('clipper'),
        clipBehavior: p.getValue('clipBehavior'),
        elevation: p.getValue('elevation'),
        color: p.getValue('color'),
        shadowColor: p.getValue('shadowColor'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'clipper', init: clipper);
    mateParams.set(name: 'clipBehavior', init: clipBehavior);
    mateParams.set(name: 'elevation', init: elevation);
    mateParams.set(name: 'color', init: color);
    mateParams.set(name: 'shadowColor', init: shadowColor);
    mateParams.set(name: 'child', init: child);
  }
}

/// class Transform extends SingleChildRenderObjectWidget
class Transform$Mate extends Transform with WidgetMate<Transform$Mate> {
  /// Transform Transform({Key? key, required Matrix4 transform, Offset? origin, AlignmentGeometry? alignment, bool transformHitTests = true, FilterQuality? filterQuality, Widget? child})
  Transform$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {required Matrix4 transform} , hasDefaultValue:false, defaultValueCode:null
    required Matrix4 transform,

    /// optionalParameters: {Offset? origin} , hasDefaultValue:false, defaultValueCode:null
    Offset? origin,

    /// optionalParameters: {AlignmentGeometry? alignment} , hasDefaultValue:false, defaultValueCode:null
    AlignmentGeometry? alignment,

    /// optionalParameters: {bool transformHitTests = true} , hasDefaultValue:true, defaultValueCode:true
    required bool transformHitTests,

    /// optionalParameters: {FilterQuality? filterQuality} , hasDefaultValue:false, defaultValueCode:null
    FilterQuality? filterQuality,

    /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
    Widget? child,
  }) : super(
          key: key,
          transform: transform,
          origin: origin,
          alignment: alignment,
          transformHitTests: transformHitTests,
          filterQuality: filterQuality,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Transform$Mate(
        key: p.getValue('key'),
        transform: p.getValue('transform'),
        origin: p.getValue('origin'),
        alignment: p.getValue('alignment'),
        transformHitTests: p.getValue('transformHitTests'),
        filterQuality: p.getValue('filterQuality'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'transform', init: transform);
    mateParams.set(name: 'origin', init: origin);
    mateParams.set(name: 'alignment', init: alignment);
    mateParams.set(name: 'transformHitTests', init: transformHitTests);
    mateParams.set(name: 'filterQuality', init: filterQuality);
    mateParams.set(name: 'child', init: child);
  }

  /// Transform Transform.rotate({Key? key, required double angle, Offset? origin, AlignmentGeometry? alignment = Alignment.center, bool transformHitTests = true, FilterQuality? filterQuality, Widget? child})
  Transform$Mate.rotate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {required double angle} , hasDefaultValue:false, defaultValueCode:null
    required double angle,

    /// optionalParameters: {Offset? origin} , hasDefaultValue:false, defaultValueCode:null
    Offset? origin,

    /// optionalParameters: {AlignmentGeometry? alignment = Alignment.center} , hasDefaultValue:true, defaultValueCode:Alignment.center
    AlignmentGeometry? alignment,

    /// optionalParameters: {bool transformHitTests = true} , hasDefaultValue:true, defaultValueCode:true
    required bool transformHitTests,

    /// optionalParameters: {FilterQuality? filterQuality} , hasDefaultValue:false, defaultValueCode:null
    FilterQuality? filterQuality,

    /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
    Widget? child,
  }) : super.rotate(
          key: key,
          angle: angle,
          origin: origin,
          alignment: alignment,
          transformHitTests: transformHitTests,
          filterQuality: filterQuality,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Transform$Mate.rotate(
        key: p.getValue('key'),
        angle: p.getValue('angle'),
        origin: p.getValue('origin'),
        alignment: p.getValue('alignment'),
        transformHitTests: p.getValue('transformHitTests'),
        filterQuality: p.getValue('filterQuality'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'angle', init: angle);
    mateParams.set(name: 'origin', init: origin);
    mateParams.set(name: 'alignment', init: alignment);
    mateParams.set(name: 'transformHitTests', init: transformHitTests);
    mateParams.set(name: 'filterQuality', init: filterQuality);
    mateParams.set(name: 'child', init: child);
  }

  /// Transform Transform.translate({Key? key, required Offset offset, bool transformHitTests = true, FilterQuality? filterQuality, Widget? child})
  Transform$Mate.translate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {required Offset offset} , hasDefaultValue:false, defaultValueCode:null
    required Offset offset,

    /// optionalParameters: {bool transformHitTests = true} , hasDefaultValue:true, defaultValueCode:true
    required bool transformHitTests,

    /// optionalParameters: {FilterQuality? filterQuality} , hasDefaultValue:false, defaultValueCode:null
    FilterQuality? filterQuality,

    /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
    Widget? child,
  }) : super.translate(
          key: key,
          offset: offset,
          transformHitTests: transformHitTests,
          filterQuality: filterQuality,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Transform$Mate.translate(
        key: p.getValue('key'),
        offset: p.getValue('offset'),
        transformHitTests: p.getValue('transformHitTests'),
        filterQuality: p.getValue('filterQuality'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'offset', init: offset);
    mateParams.set(name: 'transformHitTests', init: transformHitTests);
    mateParams.set(name: 'filterQuality', init: filterQuality);
    mateParams.set(name: 'child', init: child);
  }

  /// Transform Transform.scale({Key? key, double? scale, double? scaleX, double? scaleY, Offset? origin, AlignmentGeometry? alignment = Alignment.center, bool transformHitTests = true, FilterQuality? filterQuality, Widget? child})
  Transform$Mate.scale({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {double? scale} , hasDefaultValue:false, defaultValueCode:null
    double? scale,

    /// optionalParameters: {double? scaleX} , hasDefaultValue:false, defaultValueCode:null
    double? scaleX,

    /// optionalParameters: {double? scaleY} , hasDefaultValue:false, defaultValueCode:null
    double? scaleY,

    /// optionalParameters: {Offset? origin} , hasDefaultValue:false, defaultValueCode:null
    Offset? origin,

    /// optionalParameters: {AlignmentGeometry? alignment = Alignment.center} , hasDefaultValue:true, defaultValueCode:Alignment.center
    AlignmentGeometry? alignment,

    /// optionalParameters: {bool transformHitTests = true} , hasDefaultValue:true, defaultValueCode:true
    required bool transformHitTests,

    /// optionalParameters: {FilterQuality? filterQuality} , hasDefaultValue:false, defaultValueCode:null
    FilterQuality? filterQuality,

    /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
    Widget? child,
  }) : super.scale(
          key: key,
          scale: scale,
          scaleX: scaleX,
          scaleY: scaleY,
          origin: origin,
          alignment: alignment,
          transformHitTests: transformHitTests,
          filterQuality: filterQuality,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Transform$Mate.scale(
        key: p.getValue('key'),
        scale: p.getValue('scale'),
        scaleX: p.getValue('scaleX'),
        scaleY: p.getValue('scaleY'),
        origin: p.getValue('origin'),
        alignment: p.getValue('alignment'),
        transformHitTests: p.getValue('transformHitTests'),
        filterQuality: p.getValue('filterQuality'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'scale', init: scale);
    mateParams.set(name: 'scaleX', init: scaleX);
    mateParams.set(name: 'scaleY', init: scaleY);
    mateParams.set(name: 'origin', init: origin);
    mateParams.set(name: 'alignment', init: alignment);
    mateParams.set(name: 'transformHitTests', init: transformHitTests);
    mateParams.set(name: 'filterQuality', init: filterQuality);
    mateParams.set(name: 'child', init: child);
  }

  /// Transform Transform.flip({Key? key, bool flipX = false, bool flipY = false, Offset? origin, bool transformHitTests = true, FilterQuality? filterQuality, Widget? child})
  Transform$Mate.flip({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {bool flipX = false} , hasDefaultValue:true, defaultValueCode:false
    required bool flipX,

    /// optionalParameters: {bool flipY = false} , hasDefaultValue:true, defaultValueCode:false
    required bool flipY,

    /// optionalParameters: {Offset? origin} , hasDefaultValue:false, defaultValueCode:null
    Offset? origin,

    /// optionalParameters: {bool transformHitTests = true} , hasDefaultValue:true, defaultValueCode:true
    required bool transformHitTests,

    /// optionalParameters: {FilterQuality? filterQuality} , hasDefaultValue:false, defaultValueCode:null
    FilterQuality? filterQuality,

    /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
    Widget? child,
  }) : super.flip(
          key: key,
          flipX: flipX,
          flipY: flipY,
          origin: origin,
          transformHitTests: transformHitTests,
          filterQuality: filterQuality,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Transform$Mate.flip(
        key: p.getValue('key'),
        flipX: p.getValue('flipX'),
        flipY: p.getValue('flipY'),
        origin: p.getValue('origin'),
        transformHitTests: p.getValue('transformHitTests'),
        filterQuality: p.getValue('filterQuality'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'flipX', init: flipX);
    mateParams.set(name: 'flipY', init: flipY);
    mateParams.set(name: 'origin', init: origin);
    mateParams.set(name: 'transformHitTests', init: transformHitTests);
    mateParams.set(name: 'filterQuality', init: filterQuality);
    mateParams.set(name: 'child', init: child);
  }
}

/// class CompositedTransformTarget extends SingleChildRenderObjectWidget
class CompositedTransformTarget$Mate extends CompositedTransformTarget with WidgetMate<CompositedTransformTarget$Mate> {
  /// CompositedTransformTarget CompositedTransformTarget({Key? key, required LayerLink link, Widget? child})
  CompositedTransformTarget$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {required LayerLink link} , hasDefaultValue:false, defaultValueCode:null
    required LayerLink link,

    /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
    Widget? child,
  }) : super(
          key: key,
          link: link,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => CompositedTransformTarget$Mate(
        key: p.getValue('key'),
        link: p.getValue('link'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'link', init: link);
    mateParams.set(name: 'child', init: child);
  }
}

/// class CompositedTransformFollower extends SingleChildRenderObjectWidget
class CompositedTransformFollower$Mate extends CompositedTransformFollower
    with WidgetMate<CompositedTransformFollower$Mate> {
  /// CompositedTransformFollower CompositedTransformFollower({Key? key, required LayerLink link, bool showWhenUnlinked = true, Offset offset = Offset.zero, Alignment targetAnchor = Alignment.topLeft, Alignment followerAnchor = Alignment.topLeft, Widget? child})
  CompositedTransformFollower$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {required LayerLink link} , hasDefaultValue:false, defaultValueCode:null
    required LayerLink link,

    /// optionalParameters: {bool showWhenUnlinked = true} , hasDefaultValue:true, defaultValueCode:true
    required bool showWhenUnlinked,

    /// optionalParameters: {Offset offset = Offset.zero} , hasDefaultValue:true, defaultValueCode:Offset.zero
    required Offset offset,

    /// optionalParameters: {Alignment targetAnchor = Alignment.topLeft} , hasDefaultValue:true, defaultValueCode:Alignment.topLeft
    required Alignment targetAnchor,

    /// optionalParameters: {Alignment followerAnchor = Alignment.topLeft} , hasDefaultValue:true, defaultValueCode:Alignment.topLeft
    required Alignment followerAnchor,

    /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
    Widget? child,
  }) : super(
          key: key,
          link: link,
          showWhenUnlinked: showWhenUnlinked,
          offset: offset,
          targetAnchor: targetAnchor,
          followerAnchor: followerAnchor,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => CompositedTransformFollower$Mate(
        key: p.getValue('key'),
        link: p.getValue('link'),
        showWhenUnlinked: p.getValue('showWhenUnlinked'),
        offset: p.getValue('offset'),
        targetAnchor: p.getValue('targetAnchor'),
        followerAnchor: p.getValue('followerAnchor'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'link', init: link);
    mateParams.set(name: 'showWhenUnlinked', init: showWhenUnlinked);
    mateParams.set(name: 'offset', init: offset);
    mateParams.set(name: 'targetAnchor', init: targetAnchor);
    mateParams.set(name: 'followerAnchor', init: followerAnchor);
    mateParams.set(name: 'child', init: child);
  }
}

/// class FittedBox extends SingleChildRenderObjectWidget
class FittedBox$Mate extends FittedBox with WidgetMate<FittedBox$Mate> {
  /// FittedBox FittedBox({Key? key, BoxFit fit = BoxFit.contain, AlignmentGeometry alignment = Alignment.center, Clip clipBehavior = Clip.none, Widget? child})
  FittedBox$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {BoxFit fit = BoxFit.contain} , hasDefaultValue:true, defaultValueCode:BoxFit.contain
    required BoxFit fit,

    /// optionalParameters: {AlignmentGeometry alignment = Alignment.center} , hasDefaultValue:true, defaultValueCode:Alignment.center
    required AlignmentGeometry alignment,

    /// optionalParameters: {Clip clipBehavior = Clip.none} , hasDefaultValue:true, defaultValueCode:Clip.none
    required Clip clipBehavior,

    /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
    Widget? child,
  }) : super(
          key: key,
          fit: fit,
          alignment: alignment,
          clipBehavior: clipBehavior,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => FittedBox$Mate(
        key: p.getValue('key'),
        fit: p.getValue('fit'),
        alignment: p.getValue('alignment'),
        clipBehavior: p.getValue('clipBehavior'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'fit', init: fit);
    mateParams.set(name: 'alignment', init: alignment);
    mateParams.set(name: 'clipBehavior', init: clipBehavior);
    mateParams.set(name: 'child', init: child);
  }
}

/// class FractionalTranslation extends SingleChildRenderObjectWidget
class FractionalTranslation$Mate extends FractionalTranslation with WidgetMate<FractionalTranslation$Mate> {
  /// FractionalTranslation FractionalTranslation({Key? key, required Offset translation, bool transformHitTests = true, Widget? child})
  FractionalTranslation$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {required Offset translation} , hasDefaultValue:false, defaultValueCode:null
    required Offset translation,

    /// optionalParameters: {bool transformHitTests = true} , hasDefaultValue:true, defaultValueCode:true
    required bool transformHitTests,

    /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
    Widget? child,
  }) : super(
          key: key,
          translation: translation,
          transformHitTests: transformHitTests,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => FractionalTranslation$Mate(
        key: p.getValue('key'),
        translation: p.getValue('translation'),
        transformHitTests: p.getValue('transformHitTests'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'translation', init: translation);
    mateParams.set(name: 'transformHitTests', init: transformHitTests);
    mateParams.set(name: 'child', init: child);
  }
}

/// class RotatedBox extends SingleChildRenderObjectWidget
class RotatedBox$Mate extends RotatedBox with WidgetMate<RotatedBox$Mate> {
  /// RotatedBox RotatedBox({Key? key, required int quarterTurns, Widget? child})
  RotatedBox$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {required int quarterTurns} , hasDefaultValue:false, defaultValueCode:null
    required int quarterTurns,

    /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
    Widget? child,
  }) : super(
          key: key,
          quarterTurns: quarterTurns,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => RotatedBox$Mate(
        key: p.getValue('key'),
        quarterTurns: p.getValue('quarterTurns'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'quarterTurns', init: quarterTurns);
    mateParams.set(name: 'child', init: child);
  }
}

/// class Padding extends SingleChildRenderObjectWidget
class Padding$Mate extends Padding with WidgetMate<Padding$Mate> {
  /// Padding Padding({Key? key, required EdgeInsetsGeometry padding, Widget? child})
  Padding$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {required EdgeInsetsGeometry padding} , hasDefaultValue:false, defaultValueCode:null
    required EdgeInsetsGeometry padding,

    /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
    Widget? child,
  }) : super(
          key: key,
          padding: padding,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Padding$Mate(
        key: p.getValue('key'),
        padding: p.getValue('padding'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'padding', init: padding);
    mateParams.set(name: 'child', init: child);
  }
}

/// class Align extends SingleChildRenderObjectWidget
class Align$Mate extends Align with WidgetMate<Align$Mate> {
  /// Align Align({Key? key, AlignmentGeometry alignment = Alignment.center, double? widthFactor, double? heightFactor, Widget? child})
  Align$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {AlignmentGeometry alignment = Alignment.center} , hasDefaultValue:true, defaultValueCode:Alignment.center
    required AlignmentGeometry alignment,

    /// optionalParameters: {double? widthFactor} , hasDefaultValue:false, defaultValueCode:null
    double? widthFactor,

    /// optionalParameters: {double? heightFactor} , hasDefaultValue:false, defaultValueCode:null
    double? heightFactor,

    /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
    Widget? child,
  }) : super(
          key: key,
          alignment: alignment,
          widthFactor: widthFactor,
          heightFactor: heightFactor,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Align$Mate(
        key: p.getValue('key'),
        alignment: p.getValue('alignment'),
        widthFactor: p.getValue('widthFactor'),
        heightFactor: p.getValue('heightFactor'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'alignment', init: alignment);
    mateParams.set(name: 'widthFactor', init: widthFactor);
    mateParams.set(name: 'heightFactor', init: heightFactor);
    mateParams.set(name: 'child', init: child);
  }
}

/// class Center extends Align
class Center$Mate extends Center with WidgetMate<Center$Mate> {
  /// Center Center({Key? key, double? widthFactor, double? heightFactor, Widget? child})
  Center$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {double? widthFactor} , hasDefaultValue:false, defaultValueCode:null
    double? widthFactor,

    /// optionalParameters: {double? heightFactor} , hasDefaultValue:false, defaultValueCode:null
    double? heightFactor,

    /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
    Widget? child,
  }) : super(
          key: key,
          widthFactor: widthFactor,
          heightFactor: heightFactor,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Center$Mate(
        key: p.getValue('key'),
        widthFactor: p.getValue('widthFactor'),
        heightFactor: p.getValue('heightFactor'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'widthFactor', init: widthFactor);
    mateParams.set(name: 'heightFactor', init: heightFactor);
    mateParams.set(name: 'child', init: child);
  }
}

/// class CustomSingleChildLayout extends SingleChildRenderObjectWidget
class CustomSingleChildLayout$Mate extends CustomSingleChildLayout with WidgetMate<CustomSingleChildLayout$Mate> {
  /// CustomSingleChildLayout CustomSingleChildLayout({Key? key, required SingleChildLayoutDelegate delegate, Widget? child})
  CustomSingleChildLayout$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {required SingleChildLayoutDelegate delegate} , hasDefaultValue:false, defaultValueCode:null
    required SingleChildLayoutDelegate delegate,

    /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
    Widget? child,
  }) : super(
          key: key,
          delegate: delegate,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => CustomSingleChildLayout$Mate(
        key: p.getValue('key'),
        delegate: p.getValue('delegate'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'delegate', init: delegate);
    mateParams.set(name: 'child', init: child);
  }
}

/// class LayoutId extends ParentDataWidget<MultiChildLayoutParentData>
class LayoutId$Mate extends LayoutId with WidgetMate<LayoutId$Mate> {
  /// LayoutId LayoutId({Key? key, required Object id, required Widget child})
  LayoutId$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {required Object id} , hasDefaultValue:false, defaultValueCode:null
    required Object id,

    /// optionalParameters: {required Widget child} , hasDefaultValue:false, defaultValueCode:null
    required Widget child,
  }) : super(
          key: key,
          id: id,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => LayoutId$Mate(
        key: p.getValue('key'),
        id: p.getValue('id'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'id', init: id);
    mateParams.set(name: 'child', init: child);
  }
}

/// class CustomMultiChildLayout extends MultiChildRenderObjectWidget
class CustomMultiChildLayout$Mate extends CustomMultiChildLayout with WidgetMate<CustomMultiChildLayout$Mate> {
  /// CustomMultiChildLayout CustomMultiChildLayout({Key? key, required MultiChildLayoutDelegate delegate, List<Widget> children = const <Widget>[]})
  CustomMultiChildLayout$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {required MultiChildLayoutDelegate delegate} , hasDefaultValue:false, defaultValueCode:null
    required MultiChildLayoutDelegate delegate,

    /// optionalParameters: {List<Widget> children = const <Widget>[]} , hasDefaultValue:true, defaultValueCode:const <Widget>[]
    required List<Widget> children,
  }) : super(
          key: key,
          delegate: delegate,
          children: children,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => CustomMultiChildLayout$Mate(
        key: p.getValue('key'),
        delegate: p.getValue('delegate'),
        children: p.getValue('children'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'delegate', init: delegate);
    mateParams.set(name: 'children', init: children);
  }
}

/// class SizedBox extends SingleChildRenderObjectWidget
class SizedBox$Mate extends SizedBox with WidgetMate<SizedBox$Mate> {
  /// SizedBox SizedBox({Key? key, double? width, double? height, Widget? child})
  SizedBox$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {double? width} , hasDefaultValue:false, defaultValueCode:null
    double? width,

    /// optionalParameters: {double? height} , hasDefaultValue:false, defaultValueCode:null
    double? height,

    /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
    Widget? child,
  }) : super(
          key: key,
          width: width,
          height: height,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => SizedBox$Mate(
        key: p.getValue('key'),
        width: p.getValue('width'),
        height: p.getValue('height'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'width', init: width);
    mateParams.set(name: 'height', init: height);
    mateParams.set(name: 'child', init: child);
  }

  /// SizedBox SizedBox.expand({Key? key, Widget? child})
  SizedBox$Mate.expand({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
    Widget? child,
  }) : super.expand(
          key: key,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => SizedBox$Mate.expand(
        key: p.getValue('key'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'child', init: child);
  }

  /// SizedBox SizedBox.shrink({Key? key, Widget? child})
  SizedBox$Mate.shrink({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
    Widget? child,
  }) : super.shrink(
          key: key,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => SizedBox$Mate.shrink(
        key: p.getValue('key'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'child', init: child);
  }

  /// SizedBox SizedBox.fromSize({Key? key, Widget? child, Size? size})
  SizedBox$Mate.fromSize({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
    Widget? child,

    /// optionalParameters: {Size? size} , hasDefaultValue:false, defaultValueCode:null
    Size? size,
  }) : super.fromSize(
          key: key,
          child: child,
          size: size,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => SizedBox$Mate.fromSize(
        key: p.getValue('key'),
        child: p.getValue('child'),
        size: p.getValue('size'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'child', init: child);
    mateParams.set(name: 'size', init: size);
  }

  /// SizedBox SizedBox.square({Key? key, Widget? child, double? dimension})
  SizedBox$Mate.square({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
    Widget? child,

    /// optionalParameters: {double? dimension} , hasDefaultValue:false, defaultValueCode:null
    double? dimension,
  }) : super.square(
          key: key,
          child: child,
          dimension: dimension,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => SizedBox$Mate.square(
        key: p.getValue('key'),
        child: p.getValue('child'),
        dimension: p.getValue('dimension'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'child', init: child);
    mateParams.set(name: 'dimension', init: dimension);
  }
}

/// class ConstrainedBox extends SingleChildRenderObjectWidget
class ConstrainedBox$Mate extends ConstrainedBox with WidgetMate<ConstrainedBox$Mate> {
  /// ConstrainedBox ConstrainedBox({Key? key, required BoxConstraints constraints, Widget? child})
  ConstrainedBox$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {required BoxConstraints constraints} , hasDefaultValue:false, defaultValueCode:null
    required BoxConstraints constraints,

    /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
    Widget? child,
  }) : super(
          key: key,
          constraints: constraints,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => ConstrainedBox$Mate(
        key: p.getValue('key'),
        constraints: p.getValue('constraints'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'constraints', init: constraints);
    mateParams.set(name: 'child', init: child);
  }
}

/// class ConstraintsTransformBox extends SingleChildRenderObjectWidget
class ConstraintsTransformBox$Mate extends ConstraintsTransformBox with WidgetMate<ConstraintsTransformBox$Mate> {
  /// ConstraintsTransformBox ConstraintsTransformBox({Key? key, Widget? child, TextDirection? textDirection, AlignmentGeometry alignment = Alignment.center, required BoxConstraints Function(BoxConstraints) constraintsTransform, Clip clipBehavior = Clip.none, String debugTransformType = ''})
  ConstraintsTransformBox$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
    Widget? child,

    /// optionalParameters: {TextDirection? textDirection} , hasDefaultValue:false, defaultValueCode:null
    TextDirection? textDirection,

    /// optionalParameters: {AlignmentGeometry alignment = Alignment.center} , hasDefaultValue:true, defaultValueCode:Alignment.center
    required AlignmentGeometry alignment,

    /// optionalParameters: {required BoxConstraints Function(BoxConstraints) constraintsTransform} , hasDefaultValue:false, defaultValueCode:null
    required BoxConstraintsTransform constraintsTransform,

    /// optionalParameters: {Clip clipBehavior = Clip.none} , hasDefaultValue:true, defaultValueCode:Clip.none
    required Clip clipBehavior,

    /// optionalParameters: {String debugTransformType = ''} , hasDefaultValue:true, defaultValueCode:''
    required String debugTransformType,
  }) : super(
          key: key,
          child: child,
          textDirection: textDirection,
          alignment: alignment,
          constraintsTransform: constraintsTransform,
          clipBehavior: clipBehavior,
          debugTransformType: debugTransformType,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => ConstraintsTransformBox$Mate(
        key: p.getValue('key'),
        child: p.getValue('child'),
        textDirection: p.getValue('textDirection'),
        alignment: p.getValue('alignment'),
        constraintsTransform: p.getValue('constraintsTransform'),
        clipBehavior: p.getValue('clipBehavior'),
        debugTransformType: p.getValue('debugTransformType'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'child', init: child);
    mateParams.set(name: 'textDirection', init: textDirection);
    mateParams.set(name: 'alignment', init: alignment);
    mateParams.set(name: 'constraintsTransform', init: constraintsTransform);
    mateParams.set(name: 'clipBehavior', init: clipBehavior);
    mateParams.set(name: 'debugTransformType', init: debugTransformType);
  }
}

/// class UnconstrainedBox extends StatelessWidget
class UnconstrainedBox$Mate extends UnconstrainedBox with WidgetMate<UnconstrainedBox$Mate> {
  /// UnconstrainedBox UnconstrainedBox({Key? key, Widget? child, TextDirection? textDirection, AlignmentGeometry alignment = Alignment.center, Axis? constrainedAxis, Clip clipBehavior = Clip.none})
  UnconstrainedBox$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
    Widget? child,

    /// optionalParameters: {TextDirection? textDirection} , hasDefaultValue:false, defaultValueCode:null
    TextDirection? textDirection,

    /// optionalParameters: {AlignmentGeometry alignment = Alignment.center} , hasDefaultValue:true, defaultValueCode:Alignment.center
    required AlignmentGeometry alignment,

    /// optionalParameters: {Axis? constrainedAxis} , hasDefaultValue:false, defaultValueCode:null
    Axis? constrainedAxis,

    /// optionalParameters: {Clip clipBehavior = Clip.none} , hasDefaultValue:true, defaultValueCode:Clip.none
    required Clip clipBehavior,
  }) : super(
          key: key,
          child: child,
          textDirection: textDirection,
          alignment: alignment,
          constrainedAxis: constrainedAxis,
          clipBehavior: clipBehavior,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => UnconstrainedBox$Mate(
        key: p.getValue('key'),
        child: p.getValue('child'),
        textDirection: p.getValue('textDirection'),
        alignment: p.getValue('alignment'),
        constrainedAxis: p.getValue('constrainedAxis'),
        clipBehavior: p.getValue('clipBehavior'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'child', init: child);
    mateParams.set(name: 'textDirection', init: textDirection);
    mateParams.set(name: 'alignment', init: alignment);
    mateParams.set(name: 'constrainedAxis', init: constrainedAxis);
    mateParams.set(name: 'clipBehavior', init: clipBehavior);
  }
}

/// class FractionallySizedBox extends SingleChildRenderObjectWidget
class FractionallySizedBox$Mate extends FractionallySizedBox with WidgetMate<FractionallySizedBox$Mate> {
  /// FractionallySizedBox FractionallySizedBox({Key? key, AlignmentGeometry alignment = Alignment.center, double? widthFactor, double? heightFactor, Widget? child})
  FractionallySizedBox$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {AlignmentGeometry alignment = Alignment.center} , hasDefaultValue:true, defaultValueCode:Alignment.center
    required AlignmentGeometry alignment,

    /// optionalParameters: {double? widthFactor} , hasDefaultValue:false, defaultValueCode:null
    double? widthFactor,

    /// optionalParameters: {double? heightFactor} , hasDefaultValue:false, defaultValueCode:null
    double? heightFactor,

    /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
    Widget? child,
  }) : super(
          key: key,
          alignment: alignment,
          widthFactor: widthFactor,
          heightFactor: heightFactor,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => FractionallySizedBox$Mate(
        key: p.getValue('key'),
        alignment: p.getValue('alignment'),
        widthFactor: p.getValue('widthFactor'),
        heightFactor: p.getValue('heightFactor'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'alignment', init: alignment);
    mateParams.set(name: 'widthFactor', init: widthFactor);
    mateParams.set(name: 'heightFactor', init: heightFactor);
    mateParams.set(name: 'child', init: child);
  }
}

/// class LimitedBox extends SingleChildRenderObjectWidget
class LimitedBox$Mate extends LimitedBox with WidgetMate<LimitedBox$Mate> {
  /// LimitedBox LimitedBox({Key? key, double maxWidth = double.infinity, double maxHeight = double.infinity, Widget? child})
  LimitedBox$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {double maxWidth = double.infinity} , hasDefaultValue:true, defaultValueCode:double.infinity
    required double maxWidth,

    /// optionalParameters: {double maxHeight = double.infinity} , hasDefaultValue:true, defaultValueCode:double.infinity
    required double maxHeight,

    /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
    Widget? child,
  }) : super(
          key: key,
          maxWidth: maxWidth,
          maxHeight: maxHeight,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => LimitedBox$Mate(
        key: p.getValue('key'),
        maxWidth: p.getValue('maxWidth'),
        maxHeight: p.getValue('maxHeight'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'maxWidth', init: maxWidth);
    mateParams.set(name: 'maxHeight', init: maxHeight);
    mateParams.set(name: 'child', init: child);
  }
}

/// class OverflowBox extends SingleChildRenderObjectWidget
class OverflowBox$Mate extends OverflowBox with WidgetMate<OverflowBox$Mate> {
  /// OverflowBox OverflowBox({Key? key, AlignmentGeometry alignment = Alignment.center, double? minWidth, double? maxWidth, double? minHeight, double? maxHeight, Widget? child})
  OverflowBox$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {AlignmentGeometry alignment = Alignment.center} , hasDefaultValue:true, defaultValueCode:Alignment.center
    required AlignmentGeometry alignment,

    /// optionalParameters: {double? minWidth} , hasDefaultValue:false, defaultValueCode:null
    double? minWidth,

    /// optionalParameters: {double? maxWidth} , hasDefaultValue:false, defaultValueCode:null
    double? maxWidth,

    /// optionalParameters: {double? minHeight} , hasDefaultValue:false, defaultValueCode:null
    double? minHeight,

    /// optionalParameters: {double? maxHeight} , hasDefaultValue:false, defaultValueCode:null
    double? maxHeight,

    /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
    Widget? child,
  }) : super(
          key: key,
          alignment: alignment,
          minWidth: minWidth,
          maxWidth: maxWidth,
          minHeight: minHeight,
          maxHeight: maxHeight,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => OverflowBox$Mate(
        key: p.getValue('key'),
        alignment: p.getValue('alignment'),
        minWidth: p.getValue('minWidth'),
        maxWidth: p.getValue('maxWidth'),
        minHeight: p.getValue('minHeight'),
        maxHeight: p.getValue('maxHeight'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'alignment', init: alignment);
    mateParams.set(name: 'minWidth', init: minWidth);
    mateParams.set(name: 'maxWidth', init: maxWidth);
    mateParams.set(name: 'minHeight', init: minHeight);
    mateParams.set(name: 'maxHeight', init: maxHeight);
    mateParams.set(name: 'child', init: child);
  }
}

/// class SizedOverflowBox extends SingleChildRenderObjectWidget
class SizedOverflowBox$Mate extends SizedOverflowBox with WidgetMate<SizedOverflowBox$Mate> {
  /// SizedOverflowBox SizedOverflowBox({Key? key, required Size size, AlignmentGeometry alignment = Alignment.center, Widget? child})
  SizedOverflowBox$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {required Size size} , hasDefaultValue:false, defaultValueCode:null
    required Size size,

    /// optionalParameters: {AlignmentGeometry alignment = Alignment.center} , hasDefaultValue:true, defaultValueCode:Alignment.center
    required AlignmentGeometry alignment,

    /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
    Widget? child,
  }) : super(
          key: key,
          size: size,
          alignment: alignment,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => SizedOverflowBox$Mate(
        key: p.getValue('key'),
        size: p.getValue('size'),
        alignment: p.getValue('alignment'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'size', init: size);
    mateParams.set(name: 'alignment', init: alignment);
    mateParams.set(name: 'child', init: child);
  }
}

/// class Offstage extends SingleChildRenderObjectWidget
class Offstage$Mate extends Offstage with WidgetMate<Offstage$Mate> {
  /// Offstage Offstage({Key? key, bool offstage = true, Widget? child})
  Offstage$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {bool offstage = true} , hasDefaultValue:true, defaultValueCode:true
    required bool offstage,

    /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
    Widget? child,
  }) : super(
          key: key,
          offstage: offstage,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Offstage$Mate(
        key: p.getValue('key'),
        offstage: p.getValue('offstage'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'offstage', init: offstage);
    mateParams.set(name: 'child', init: child);
  }
}

/// class AspectRatio extends SingleChildRenderObjectWidget
class AspectRatio$Mate extends AspectRatio with WidgetMate<AspectRatio$Mate> {
  /// AspectRatio AspectRatio({Key? key, required double aspectRatio, Widget? child})
  AspectRatio$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {required double aspectRatio} , hasDefaultValue:false, defaultValueCode:null
    required double aspectRatio,

    /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
    Widget? child,
  }) : super(
          key: key,
          aspectRatio: aspectRatio,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => AspectRatio$Mate(
        key: p.getValue('key'),
        aspectRatio: p.getValue('aspectRatio'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'aspectRatio', init: aspectRatio);
    mateParams.set(name: 'child', init: child);
  }
}

/// class IntrinsicWidth extends SingleChildRenderObjectWidget
class IntrinsicWidth$Mate extends IntrinsicWidth with WidgetMate<IntrinsicWidth$Mate> {
  /// IntrinsicWidth IntrinsicWidth({Key? key, double? stepWidth, double? stepHeight, Widget? child})
  IntrinsicWidth$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {double? stepWidth} , hasDefaultValue:false, defaultValueCode:null
    double? stepWidth,

    /// optionalParameters: {double? stepHeight} , hasDefaultValue:false, defaultValueCode:null
    double? stepHeight,

    /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
    Widget? child,
  }) : super(
          key: key,
          stepWidth: stepWidth,
          stepHeight: stepHeight,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => IntrinsicWidth$Mate(
        key: p.getValue('key'),
        stepWidth: p.getValue('stepWidth'),
        stepHeight: p.getValue('stepHeight'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'stepWidth', init: stepWidth);
    mateParams.set(name: 'stepHeight', init: stepHeight);
    mateParams.set(name: 'child', init: child);
  }
}

/// class IntrinsicHeight extends SingleChildRenderObjectWidget
class IntrinsicHeight$Mate extends IntrinsicHeight with WidgetMate<IntrinsicHeight$Mate> {
  /// IntrinsicHeight IntrinsicHeight({Key? key, Widget? child})
  IntrinsicHeight$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
    Widget? child,
  }) : super(
          key: key,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => IntrinsicHeight$Mate(
        key: p.getValue('key'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'child', init: child);
  }
}

/// class Baseline extends SingleChildRenderObjectWidget
class Baseline$Mate extends Baseline with WidgetMate<Baseline$Mate> {
  /// Baseline Baseline({Key? key, required double baseline, required TextBaseline baselineType, Widget? child})
  Baseline$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {required double baseline} , hasDefaultValue:false, defaultValueCode:null
    required double baseline,

    /// optionalParameters: {required TextBaseline baselineType} , hasDefaultValue:false, defaultValueCode:null
    required TextBaseline baselineType,

    /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
    Widget? child,
  }) : super(
          key: key,
          baseline: baseline,
          baselineType: baselineType,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Baseline$Mate(
        key: p.getValue('key'),
        baseline: p.getValue('baseline'),
        baselineType: p.getValue('baselineType'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'baseline', init: baseline);
    mateParams.set(name: 'baselineType', init: baselineType);
    mateParams.set(name: 'child', init: child);
  }
}

/// class SliverToBoxAdapter extends SingleChildRenderObjectWidget
class SliverToBoxAdapter$Mate extends SliverToBoxAdapter with WidgetMate<SliverToBoxAdapter$Mate> {
  /// SliverToBoxAdapter SliverToBoxAdapter({Key? key, Widget? child})
  SliverToBoxAdapter$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
    Widget? child,
  }) : super(
          key: key,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => SliverToBoxAdapter$Mate(
        key: p.getValue('key'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'child', init: child);
  }
}

/// class SliverPadding extends SingleChildRenderObjectWidget
class SliverPadding$Mate extends SliverPadding with WidgetMate<SliverPadding$Mate> {
  /// SliverPadding SliverPadding({Key? key, required EdgeInsetsGeometry padding, Widget? sliver})
  SliverPadding$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {required EdgeInsetsGeometry padding} , hasDefaultValue:false, defaultValueCode:null
    required EdgeInsetsGeometry padding,

    /// optionalParameters: {Widget? sliver} , hasDefaultValue:false, defaultValueCode:null
    Widget? sliver,
  }) : super(
          key: key,
          padding: padding,
          sliver: sliver,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => SliverPadding$Mate(
        key: p.getValue('key'),
        padding: p.getValue('padding'),
        sliver: p.getValue('sliver'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'padding', init: padding);
    mateParams.set(name: 'sliver', init: sliver);
  }
}

/// class ListBody extends MultiChildRenderObjectWidget
class ListBody$Mate extends ListBody with WidgetMate<ListBody$Mate> {
  /// ListBody ListBody({Key? key, Axis mainAxis = Axis.vertical, bool reverse = false, List<Widget> children = const <Widget>[]})
  ListBody$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {Axis mainAxis = Axis.vertical} , hasDefaultValue:true, defaultValueCode:Axis.vertical
    required Axis mainAxis,

    /// optionalParameters: {bool reverse = false} , hasDefaultValue:true, defaultValueCode:false
    required bool reverse,

    /// optionalParameters: {List<Widget> children = const <Widget>[]} , hasDefaultValue:true, defaultValueCode:const <Widget>[]
    required List<Widget> children,
  }) : super(
          key: key,
          mainAxis: mainAxis,
          reverse: reverse,
          children: children,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => ListBody$Mate(
        key: p.getValue('key'),
        mainAxis: p.getValue('mainAxis'),
        reverse: p.getValue('reverse'),
        children: p.getValue('children'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'mainAxis', init: mainAxis);
    mateParams.set(name: 'reverse', init: reverse);
    mateParams.set(name: 'children', init: children);
  }
}

/// class Stack extends MultiChildRenderObjectWidget
class Stack$Mate extends Stack with WidgetMate<Stack$Mate> {
  /// Stack Stack({Key? key, AlignmentGeometry alignment = AlignmentDirectional.topStart, TextDirection? textDirection, StackFit fit = StackFit.loose, Clip clipBehavior = Clip.hardEdge, List<Widget> children = const <Widget>[]})
  Stack$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {AlignmentGeometry alignment = AlignmentDirectional.topStart} , hasDefaultValue:true, defaultValueCode:AlignmentDirectional.topStart
    required AlignmentGeometry alignment,

    /// optionalParameters: {TextDirection? textDirection} , hasDefaultValue:false, defaultValueCode:null
    TextDirection? textDirection,

    /// optionalParameters: {StackFit fit = StackFit.loose} , hasDefaultValue:true, defaultValueCode:StackFit.loose
    required StackFit fit,

    /// optionalParameters: {Clip clipBehavior = Clip.hardEdge} , hasDefaultValue:true, defaultValueCode:Clip.hardEdge
    required Clip clipBehavior,

    /// optionalParameters: {List<Widget> children = const <Widget>[]} , hasDefaultValue:true, defaultValueCode:const <Widget>[]
    required List<Widget> children,
  }) : super(
          key: key,
          alignment: alignment,
          textDirection: textDirection,
          fit: fit,
          clipBehavior: clipBehavior,
          children: children,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Stack$Mate(
        key: p.getValue('key'),
        alignment: p.getValue('alignment'),
        textDirection: p.getValue('textDirection'),
        fit: p.getValue('fit'),
        clipBehavior: p.getValue('clipBehavior'),
        children: p.getValue('children'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'alignment', init: alignment);
    mateParams.set(name: 'textDirection', init: textDirection);
    mateParams.set(name: 'fit', init: fit);
    mateParams.set(name: 'clipBehavior', init: clipBehavior);
    mateParams.set(name: 'children', init: children);
  }
}

/// class IndexedStack extends Stack
class IndexedStack$Mate extends IndexedStack with WidgetMate<IndexedStack$Mate> {
  /// IndexedStack IndexedStack({Key? key, AlignmentGeometry alignment = AlignmentDirectional.topStart, TextDirection? textDirection, Clip clipBehavior = Clip.hardEdge, StackFit sizing = StackFit.loose, int? index = 0, List<Widget> children = const <Widget>[]})
  IndexedStack$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {AlignmentGeometry alignment = AlignmentDirectional.topStart} , hasDefaultValue:true, defaultValueCode:AlignmentDirectional.topStart
    required AlignmentGeometry alignment,

    /// optionalParameters: {TextDirection? textDirection} , hasDefaultValue:false, defaultValueCode:null
    TextDirection? textDirection,

    /// optionalParameters: {Clip clipBehavior = Clip.hardEdge} , hasDefaultValue:true, defaultValueCode:Clip.hardEdge
    required Clip clipBehavior,

    /// optionalParameters: {StackFit sizing = StackFit.loose} , hasDefaultValue:true, defaultValueCode:StackFit.loose
    required StackFit sizing,

    /// optionalParameters: {int? index = 0} , hasDefaultValue:true, defaultValueCode:0
    int? index,

    /// optionalParameters: {List<Widget> children = const <Widget>[]} , hasDefaultValue:true, defaultValueCode:const <Widget>[]
    required List<Widget> children,
  }) : super(
          key: key,
          alignment: alignment,
          textDirection: textDirection,
          clipBehavior: clipBehavior,
          sizing: sizing,
          index: index,
          children: children,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => IndexedStack$Mate(
        key: p.getValue('key'),
        alignment: p.getValue('alignment'),
        textDirection: p.getValue('textDirection'),
        clipBehavior: p.getValue('clipBehavior'),
        sizing: p.getValue('sizing'),
        index: p.getValue('index'),
        children: p.getValue('children'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'alignment', init: alignment);
    mateParams.set(name: 'textDirection', init: textDirection);
    mateParams.set(name: 'clipBehavior', init: clipBehavior);
    mateParams.set(name: 'sizing', init: sizing);
    mateParams.set(name: 'index', init: index);
    mateParams.set(name: 'children', init: children);
  }
}

/// class Positioned extends ParentDataWidget<StackParentData>
class Positioned$Mate extends Positioned with WidgetMate<Positioned$Mate> {
  /// Positioned Positioned({Key? key, double? left, double? top, double? right, double? bottom, double? width, double? height, required Widget child})
  Positioned$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {double? left} , hasDefaultValue:false, defaultValueCode:null
    double? left,

    /// optionalParameters: {double? top} , hasDefaultValue:false, defaultValueCode:null
    double? top,

    /// optionalParameters: {double? right} , hasDefaultValue:false, defaultValueCode:null
    double? right,

    /// optionalParameters: {double? bottom} , hasDefaultValue:false, defaultValueCode:null
    double? bottom,

    /// optionalParameters: {double? width} , hasDefaultValue:false, defaultValueCode:null
    double? width,

    /// optionalParameters: {double? height} , hasDefaultValue:false, defaultValueCode:null
    double? height,

    /// optionalParameters: {required Widget child} , hasDefaultValue:false, defaultValueCode:null
    required Widget child,
  }) : super(
          key: key,
          left: left,
          top: top,
          right: right,
          bottom: bottom,
          width: width,
          height: height,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Positioned$Mate(
        key: p.getValue('key'),
        left: p.getValue('left'),
        top: p.getValue('top'),
        right: p.getValue('right'),
        bottom: p.getValue('bottom'),
        width: p.getValue('width'),
        height: p.getValue('height'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'left', init: left);
    mateParams.set(name: 'top', init: top);
    mateParams.set(name: 'right', init: right);
    mateParams.set(name: 'bottom', init: bottom);
    mateParams.set(name: 'width', init: width);
    mateParams.set(name: 'height', init: height);
    mateParams.set(name: 'child', init: child);
  }

  /// Positioned Positioned.fromRect({Key? key, required Rect rect, required Widget child})
  Positioned$Mate.fromRect({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {required Rect rect} , hasDefaultValue:false, defaultValueCode:null
    required Rect rect,

    /// optionalParameters: {required Widget child} , hasDefaultValue:false, defaultValueCode:null
    required Widget child,
  }) : super.fromRect(
          key: key,
          rect: rect,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Positioned$Mate.fromRect(
        key: p.getValue('key'),
        rect: p.getValue('rect'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'rect', init: rect);
    mateParams.set(name: 'child', init: child);
  }

  /// Positioned Positioned.fromRelativeRect({Key? key, required RelativeRect rect, required Widget child})
  Positioned$Mate.fromRelativeRect({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {required RelativeRect rect} , hasDefaultValue:false, defaultValueCode:null
    required RelativeRect rect,

    /// optionalParameters: {required Widget child} , hasDefaultValue:false, defaultValueCode:null
    required Widget child,
  }) : super.fromRelativeRect(
          key: key,
          rect: rect,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Positioned$Mate.fromRelativeRect(
        key: p.getValue('key'),
        rect: p.getValue('rect'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'rect', init: rect);
    mateParams.set(name: 'child', init: child);
  }

  /// Positioned Positioned.fill({Key? key, double? left = 0.0, double? top = 0.0, double? right = 0.0, double? bottom = 0.0, required Widget child})
  Positioned$Mate.fill({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {double? left = 0.0} , hasDefaultValue:true, defaultValueCode:0.0
    double? left,

    /// optionalParameters: {double? top = 0.0} , hasDefaultValue:true, defaultValueCode:0.0
    double? top,

    /// optionalParameters: {double? right = 0.0} , hasDefaultValue:true, defaultValueCode:0.0
    double? right,

    /// optionalParameters: {double? bottom = 0.0} , hasDefaultValue:true, defaultValueCode:0.0
    double? bottom,

    /// optionalParameters: {required Widget child} , hasDefaultValue:false, defaultValueCode:null
    required Widget child,
  }) : super.fill(
          key: key,
          left: left,
          top: top,
          right: right,
          bottom: bottom,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Positioned$Mate.fill(
        key: p.getValue('key'),
        left: p.getValue('left'),
        top: p.getValue('top'),
        right: p.getValue('right'),
        bottom: p.getValue('bottom'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'left', init: left);
    mateParams.set(name: 'top', init: top);
    mateParams.set(name: 'right', init: right);
    mateParams.set(name: 'bottom', init: bottom);
    mateParams.set(name: 'child', init: child);
  }
}

/// class PositionedDirectional extends StatelessWidget
class PositionedDirectional$Mate extends PositionedDirectional with WidgetMate<PositionedDirectional$Mate> {
  /// PositionedDirectional PositionedDirectional({Key? key, double? start, double? top, double? end, double? bottom, double? width, double? height, required Widget child})
  PositionedDirectional$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {double? start} , hasDefaultValue:false, defaultValueCode:null
    double? start,

    /// optionalParameters: {double? top} , hasDefaultValue:false, defaultValueCode:null
    double? top,

    /// optionalParameters: {double? end} , hasDefaultValue:false, defaultValueCode:null
    double? end,

    /// optionalParameters: {double? bottom} , hasDefaultValue:false, defaultValueCode:null
    double? bottom,

    /// optionalParameters: {double? width} , hasDefaultValue:false, defaultValueCode:null
    double? width,

    /// optionalParameters: {double? height} , hasDefaultValue:false, defaultValueCode:null
    double? height,

    /// optionalParameters: {required Widget child} , hasDefaultValue:false, defaultValueCode:null
    required Widget child,
  }) : super(
          key: key,
          start: start,
          top: top,
          end: end,
          bottom: bottom,
          width: width,
          height: height,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => PositionedDirectional$Mate(
        key: p.getValue('key'),
        start: p.getValue('start'),
        top: p.getValue('top'),
        end: p.getValue('end'),
        bottom: p.getValue('bottom'),
        width: p.getValue('width'),
        height: p.getValue('height'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'start', init: start);
    mateParams.set(name: 'top', init: top);
    mateParams.set(name: 'end', init: end);
    mateParams.set(name: 'bottom', init: bottom);
    mateParams.set(name: 'width', init: width);
    mateParams.set(name: 'height', init: height);
    mateParams.set(name: 'child', init: child);
  }
}

/// class Flex extends MultiChildRenderObjectWidget
class Flex$Mate extends Flex with WidgetMate<Flex$Mate> {
  /// Flex Flex({Key? key, required Axis direction, MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start, MainAxisSize mainAxisSize = MainAxisSize.max, CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center, TextDirection? textDirection, VerticalDirection verticalDirection = VerticalDirection.down, TextBaseline? textBaseline, Clip clipBehavior = Clip.none, List<Widget> children = const <Widget>[]})
  Flex$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {required Axis direction} , hasDefaultValue:false, defaultValueCode:null
    required Axis direction,

    /// optionalParameters: {MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start} , hasDefaultValue:true, defaultValueCode:MainAxisAlignment.start
    required MainAxisAlignment mainAxisAlignment,

    /// optionalParameters: {MainAxisSize mainAxisSize = MainAxisSize.max} , hasDefaultValue:true, defaultValueCode:MainAxisSize.max
    required MainAxisSize mainAxisSize,

    /// optionalParameters: {CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center} , hasDefaultValue:true, defaultValueCode:CrossAxisAlignment.center
    required CrossAxisAlignment crossAxisAlignment,

    /// optionalParameters: {TextDirection? textDirection} , hasDefaultValue:false, defaultValueCode:null
    TextDirection? textDirection,

    /// optionalParameters: {VerticalDirection verticalDirection = VerticalDirection.down} , hasDefaultValue:true, defaultValueCode:VerticalDirection.down
    required VerticalDirection verticalDirection,

    /// optionalParameters: {TextBaseline? textBaseline} , hasDefaultValue:false, defaultValueCode:null
    TextBaseline? textBaseline,

    /// optionalParameters: {Clip clipBehavior = Clip.none} , hasDefaultValue:true, defaultValueCode:Clip.none
    required Clip clipBehavior,

    /// optionalParameters: {List<Widget> children = const <Widget>[]} , hasDefaultValue:true, defaultValueCode:const <Widget>[]
    required List<Widget> children,
  }) : super(
          key: key,
          direction: direction,
          mainAxisAlignment: mainAxisAlignment,
          mainAxisSize: mainAxisSize,
          crossAxisAlignment: crossAxisAlignment,
          textDirection: textDirection,
          verticalDirection: verticalDirection,
          textBaseline: textBaseline,
          clipBehavior: clipBehavior,
          children: children,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Flex$Mate(
        key: p.getValue('key'),
        direction: p.getValue('direction'),
        mainAxisAlignment: p.getValue('mainAxisAlignment'),
        mainAxisSize: p.getValue('mainAxisSize'),
        crossAxisAlignment: p.getValue('crossAxisAlignment'),
        textDirection: p.getValue('textDirection'),
        verticalDirection: p.getValue('verticalDirection'),
        textBaseline: p.getValue('textBaseline'),
        clipBehavior: p.getValue('clipBehavior'),
        children: p.getValue('children'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'direction', init: direction);
    mateParams.set(name: 'mainAxisAlignment', init: mainAxisAlignment);
    mateParams.set(name: 'mainAxisSize', init: mainAxisSize);
    mateParams.set(name: 'crossAxisAlignment', init: crossAxisAlignment);
    mateParams.set(name: 'textDirection', init: textDirection);
    mateParams.set(name: 'verticalDirection', init: verticalDirection);
    mateParams.set(name: 'textBaseline', init: textBaseline);
    mateParams.set(name: 'clipBehavior', init: clipBehavior);
    mateParams.set(name: 'children', init: children);
  }
}

/// class Row extends Flex
class Row$Mate extends Row with WidgetMate<Row$Mate> {
  /// Row Row({Key? key, MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start, MainAxisSize mainAxisSize = MainAxisSize.max, CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center, TextDirection? textDirection, VerticalDirection verticalDirection = VerticalDirection.down, TextBaseline? textBaseline, List<Widget> children = const <Widget>[]})
  Row$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start} , hasDefaultValue:true, defaultValueCode:MainAxisAlignment.start
    required MainAxisAlignment mainAxisAlignment,

    /// optionalParameters: {MainAxisSize mainAxisSize = MainAxisSize.max} , hasDefaultValue:true, defaultValueCode:MainAxisSize.max
    required MainAxisSize mainAxisSize,

    /// optionalParameters: {CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center} , hasDefaultValue:true, defaultValueCode:CrossAxisAlignment.center
    required CrossAxisAlignment crossAxisAlignment,

    /// optionalParameters: {TextDirection? textDirection} , hasDefaultValue:false, defaultValueCode:null
    TextDirection? textDirection,

    /// optionalParameters: {VerticalDirection verticalDirection = VerticalDirection.down} , hasDefaultValue:true, defaultValueCode:VerticalDirection.down
    required VerticalDirection verticalDirection,

    /// optionalParameters: {TextBaseline? textBaseline} , hasDefaultValue:false, defaultValueCode:null
    TextBaseline? textBaseline,

    /// optionalParameters: {List<Widget> children = const <Widget>[]} , hasDefaultValue:true, defaultValueCode:const <Widget>[]
    required List<Widget> children,
  }) : super(
          key: key,
          mainAxisAlignment: mainAxisAlignment,
          mainAxisSize: mainAxisSize,
          crossAxisAlignment: crossAxisAlignment,
          textDirection: textDirection,
          verticalDirection: verticalDirection,
          textBaseline: textBaseline,
          children: children,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Row$Mate(
        key: p.getValue('key'),
        mainAxisAlignment: p.getValue('mainAxisAlignment'),
        mainAxisSize: p.getValue('mainAxisSize'),
        crossAxisAlignment: p.getValue('crossAxisAlignment'),
        textDirection: p.getValue('textDirection'),
        verticalDirection: p.getValue('verticalDirection'),
        textBaseline: p.getValue('textBaseline'),
        children: p.getValue('children'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'mainAxisAlignment', init: mainAxisAlignment);
    mateParams.set(name: 'mainAxisSize', init: mainAxisSize);
    mateParams.set(name: 'crossAxisAlignment', init: crossAxisAlignment);
    mateParams.set(name: 'textDirection', init: textDirection);
    mateParams.set(name: 'verticalDirection', init: verticalDirection);
    mateParams.set(name: 'textBaseline', init: textBaseline);
    mateParams.set(name: 'children', init: children);
  }
}

/// class Column extends Flex
class Column$Mate extends Column with WidgetMate<Column$Mate> {
  /// Column Column({Key? key, MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start, MainAxisSize mainAxisSize = MainAxisSize.max, CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center, TextDirection? textDirection, VerticalDirection verticalDirection = VerticalDirection.down, TextBaseline? textBaseline, List<Widget> children = const <Widget>[]})
  Column$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start} , hasDefaultValue:true, defaultValueCode:MainAxisAlignment.start
    required MainAxisAlignment mainAxisAlignment,

    /// optionalParameters: {MainAxisSize mainAxisSize = MainAxisSize.max} , hasDefaultValue:true, defaultValueCode:MainAxisSize.max
    required MainAxisSize mainAxisSize,

    /// optionalParameters: {CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center} , hasDefaultValue:true, defaultValueCode:CrossAxisAlignment.center
    required CrossAxisAlignment crossAxisAlignment,

    /// optionalParameters: {TextDirection? textDirection} , hasDefaultValue:false, defaultValueCode:null
    TextDirection? textDirection,

    /// optionalParameters: {VerticalDirection verticalDirection = VerticalDirection.down} , hasDefaultValue:true, defaultValueCode:VerticalDirection.down
    required VerticalDirection verticalDirection,

    /// optionalParameters: {TextBaseline? textBaseline} , hasDefaultValue:false, defaultValueCode:null
    TextBaseline? textBaseline,

    /// optionalParameters: {List<Widget> children = const <Widget>[]} , hasDefaultValue:true, defaultValueCode:const <Widget>[]
    required List<Widget> children,
  }) : super(
          key: key,
          mainAxisAlignment: mainAxisAlignment,
          mainAxisSize: mainAxisSize,
          crossAxisAlignment: crossAxisAlignment,
          textDirection: textDirection,
          verticalDirection: verticalDirection,
          textBaseline: textBaseline,
          children: children,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Column$Mate(
        key: p.getValue('key'),
        mainAxisAlignment: p.getValue('mainAxisAlignment'),
        mainAxisSize: p.getValue('mainAxisSize'),
        crossAxisAlignment: p.getValue('crossAxisAlignment'),
        textDirection: p.getValue('textDirection'),
        verticalDirection: p.getValue('verticalDirection'),
        textBaseline: p.getValue('textBaseline'),
        children: p.getValue('children'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'mainAxisAlignment', init: mainAxisAlignment);
    mateParams.set(name: 'mainAxisSize', init: mainAxisSize);
    mateParams.set(name: 'crossAxisAlignment', init: crossAxisAlignment);
    mateParams.set(name: 'textDirection', init: textDirection);
    mateParams.set(name: 'verticalDirection', init: verticalDirection);
    mateParams.set(name: 'textBaseline', init: textBaseline);
    mateParams.set(name: 'children', init: children);
  }
}

/// class Flexible extends ParentDataWidget<FlexParentData>
class Flexible$Mate extends Flexible with WidgetMate<Flexible$Mate> {
  /// Flexible Flexible({Key? key, int flex = 1, FlexFit fit = FlexFit.loose, required Widget child})
  Flexible$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {int flex = 1} , hasDefaultValue:true, defaultValueCode:1
    required int flex,

    /// optionalParameters: {FlexFit fit = FlexFit.loose} , hasDefaultValue:true, defaultValueCode:FlexFit.loose
    required FlexFit fit,

    /// optionalParameters: {required Widget child} , hasDefaultValue:false, defaultValueCode:null
    required Widget child,
  }) : super(
          key: key,
          flex: flex,
          fit: fit,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Flexible$Mate(
        key: p.getValue('key'),
        flex: p.getValue('flex'),
        fit: p.getValue('fit'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'flex', init: flex);
    mateParams.set(name: 'fit', init: fit);
    mateParams.set(name: 'child', init: child);
  }
}

/// class Expanded extends Flexible
class Expanded$Mate extends Expanded with WidgetMate<Expanded$Mate> {
  /// Expanded Expanded({Key? key, int flex = 1, required Widget child})
  Expanded$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {int flex = 1} , hasDefaultValue:true, defaultValueCode:1
    required int flex,

    /// optionalParameters: {required Widget child} , hasDefaultValue:false, defaultValueCode:null
    required Widget child,
  }) : super(
          key: key,
          flex: flex,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Expanded$Mate(
        key: p.getValue('key'),
        flex: p.getValue('flex'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'flex', init: flex);
    mateParams.set(name: 'child', init: child);
  }
}

/// class Wrap extends MultiChildRenderObjectWidget
class Wrap$Mate extends Wrap with WidgetMate<Wrap$Mate> {
  /// Wrap Wrap({Key? key, Axis direction = Axis.horizontal, WrapAlignment alignment = WrapAlignment.start, double spacing = 0.0, WrapAlignment runAlignment = WrapAlignment.start, double runSpacing = 0.0, WrapCrossAlignment crossAxisAlignment = WrapCrossAlignment.start, TextDirection? textDirection, VerticalDirection verticalDirection = VerticalDirection.down, Clip clipBehavior = Clip.none, List<Widget> children = const <Widget>[]})
  Wrap$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {Axis direction = Axis.horizontal} , hasDefaultValue:true, defaultValueCode:Axis.horizontal
    required Axis direction,

    /// optionalParameters: {WrapAlignment alignment = WrapAlignment.start} , hasDefaultValue:true, defaultValueCode:WrapAlignment.start
    required WrapAlignment alignment,

    /// optionalParameters: {double spacing = 0.0} , hasDefaultValue:true, defaultValueCode:0.0
    required double spacing,

    /// optionalParameters: {WrapAlignment runAlignment = WrapAlignment.start} , hasDefaultValue:true, defaultValueCode:WrapAlignment.start
    required WrapAlignment runAlignment,

    /// optionalParameters: {double runSpacing = 0.0} , hasDefaultValue:true, defaultValueCode:0.0
    required double runSpacing,

    /// optionalParameters: {WrapCrossAlignment crossAxisAlignment = WrapCrossAlignment.start} , hasDefaultValue:true, defaultValueCode:WrapCrossAlignment.start
    required WrapCrossAlignment crossAxisAlignment,

    /// optionalParameters: {TextDirection? textDirection} , hasDefaultValue:false, defaultValueCode:null
    TextDirection? textDirection,

    /// optionalParameters: {VerticalDirection verticalDirection = VerticalDirection.down} , hasDefaultValue:true, defaultValueCode:VerticalDirection.down
    required VerticalDirection verticalDirection,

    /// optionalParameters: {Clip clipBehavior = Clip.none} , hasDefaultValue:true, defaultValueCode:Clip.none
    required Clip clipBehavior,

    /// optionalParameters: {List<Widget> children = const <Widget>[]} , hasDefaultValue:true, defaultValueCode:const <Widget>[]
    required List<Widget> children,
  }) : super(
          key: key,
          direction: direction,
          alignment: alignment,
          spacing: spacing,
          runAlignment: runAlignment,
          runSpacing: runSpacing,
          crossAxisAlignment: crossAxisAlignment,
          textDirection: textDirection,
          verticalDirection: verticalDirection,
          clipBehavior: clipBehavior,
          children: children,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Wrap$Mate(
        key: p.getValue('key'),
        direction: p.getValue('direction'),
        alignment: p.getValue('alignment'),
        spacing: p.getValue('spacing'),
        runAlignment: p.getValue('runAlignment'),
        runSpacing: p.getValue('runSpacing'),
        crossAxisAlignment: p.getValue('crossAxisAlignment'),
        textDirection: p.getValue('textDirection'),
        verticalDirection: p.getValue('verticalDirection'),
        clipBehavior: p.getValue('clipBehavior'),
        children: p.getValue('children'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'direction', init: direction);
    mateParams.set(name: 'alignment', init: alignment);
    mateParams.set(name: 'spacing', init: spacing);
    mateParams.set(name: 'runAlignment', init: runAlignment);
    mateParams.set(name: 'runSpacing', init: runSpacing);
    mateParams.set(name: 'crossAxisAlignment', init: crossAxisAlignment);
    mateParams.set(name: 'textDirection', init: textDirection);
    mateParams.set(name: 'verticalDirection', init: verticalDirection);
    mateParams.set(name: 'clipBehavior', init: clipBehavior);
    mateParams.set(name: 'children', init: children);
  }
}

/// class Flow extends MultiChildRenderObjectWidget
class Flow$Mate extends Flow with WidgetMate<Flow$Mate> {
  /// Flow Flow({Key? key, required FlowDelegate delegate, List<Widget> children = const <Widget>[], Clip clipBehavior = Clip.hardEdge})
  Flow$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {required FlowDelegate delegate} , hasDefaultValue:false, defaultValueCode:null
    required FlowDelegate delegate,

    /// optionalParameters: {List<Widget> children = const <Widget>[]} , hasDefaultValue:true, defaultValueCode:const <Widget>[]
    required List<Widget> children,

    /// optionalParameters: {Clip clipBehavior = Clip.hardEdge} , hasDefaultValue:true, defaultValueCode:Clip.hardEdge
    required Clip clipBehavior,
  }) : super(
          key: key,
          delegate: delegate,
          children: children,
          clipBehavior: clipBehavior,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Flow$Mate(
        key: p.getValue('key'),
        delegate: p.getValue('delegate'),
        children: p.getValue('children'),
        clipBehavior: p.getValue('clipBehavior'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'delegate', init: delegate);
    mateParams.set(name: 'children', init: children);
    mateParams.set(name: 'clipBehavior', init: clipBehavior);
  }

  /// Flow Flow.unwrapped({Key? key, required FlowDelegate delegate, List<Widget> children = const <Widget>[], Clip clipBehavior = Clip.hardEdge})
  Flow$Mate.unwrapped({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {required FlowDelegate delegate} , hasDefaultValue:false, defaultValueCode:null
    required FlowDelegate delegate,

    /// optionalParameters: {List<Widget> children = const <Widget>[]} , hasDefaultValue:true, defaultValueCode:const <Widget>[]
    required List<Widget> children,

    /// optionalParameters: {Clip clipBehavior = Clip.hardEdge} , hasDefaultValue:true, defaultValueCode:Clip.hardEdge
    required Clip clipBehavior,
  }) : super.unwrapped(
          key: key,
          delegate: delegate,
          children: children,
          clipBehavior: clipBehavior,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Flow$Mate.unwrapped(
        key: p.getValue('key'),
        delegate: p.getValue('delegate'),
        children: p.getValue('children'),
        clipBehavior: p.getValue('clipBehavior'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'delegate', init: delegate);
    mateParams.set(name: 'children', init: children);
    mateParams.set(name: 'clipBehavior', init: clipBehavior);
  }
}

/// class RichText extends MultiChildRenderObjectWidget
class RichText$Mate extends RichText with WidgetMate<RichText$Mate> {
  /// RichText RichText({Key? key, required InlineSpan text, TextAlign textAlign = TextAlign.start, TextDirection? textDirection, bool softWrap = true, TextOverflow overflow = TextOverflow.clip, double textScaleFactor = 1.0, int? maxLines, Locale? locale, StrutStyle? strutStyle, TextWidthBasis textWidthBasis = TextWidthBasis.parent, TextHeightBehavior? textHeightBehavior, SelectionRegistrar? selectionRegistrar, Color? selectionColor})
  RichText$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {required InlineSpan text} , hasDefaultValue:false, defaultValueCode:null
    required InlineSpan text,

    /// optionalParameters: {TextAlign textAlign = TextAlign.start} , hasDefaultValue:true, defaultValueCode:TextAlign.start
    required TextAlign textAlign,

    /// optionalParameters: {TextDirection? textDirection} , hasDefaultValue:false, defaultValueCode:null
    TextDirection? textDirection,

    /// optionalParameters: {bool softWrap = true} , hasDefaultValue:true, defaultValueCode:true
    required bool softWrap,

    /// optionalParameters: {TextOverflow overflow = TextOverflow.clip} , hasDefaultValue:true, defaultValueCode:TextOverflow.clip
    required TextOverflow overflow,

    /// optionalParameters: {double textScaleFactor = 1.0} , hasDefaultValue:true, defaultValueCode:1.0
    required double textScaleFactor,

    /// optionalParameters: {int? maxLines} , hasDefaultValue:false, defaultValueCode:null
    int? maxLines,

    /// optionalParameters: {Locale? locale} , hasDefaultValue:false, defaultValueCode:null
    Locale? locale,

    /// optionalParameters: {StrutStyle? strutStyle} , hasDefaultValue:false, defaultValueCode:null
    StrutStyle? strutStyle,

    /// optionalParameters: {TextWidthBasis textWidthBasis = TextWidthBasis.parent} , hasDefaultValue:true, defaultValueCode:TextWidthBasis.parent
    required TextWidthBasis textWidthBasis,

    /// optionalParameters: {TextHeightBehavior? textHeightBehavior} , hasDefaultValue:false, defaultValueCode:null
    TextHeightBehavior? textHeightBehavior,

    /// optionalParameters: {SelectionRegistrar? selectionRegistrar} , hasDefaultValue:false, defaultValueCode:null
    SelectionRegistrar? selectionRegistrar,

    /// optionalParameters: {Color? selectionColor} , hasDefaultValue:false, defaultValueCode:null
    Color? selectionColor,
  }) : super(
          key: key,
          text: text,
          textAlign: textAlign,
          textDirection: textDirection,
          softWrap: softWrap,
          overflow: overflow,
          textScaleFactor: textScaleFactor,
          maxLines: maxLines,
          locale: locale,
          strutStyle: strutStyle,
          textWidthBasis: textWidthBasis,
          textHeightBehavior: textHeightBehavior,
          selectionRegistrar: selectionRegistrar,
          selectionColor: selectionColor,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => RichText$Mate(
        key: p.getValue('key'),
        text: p.getValue('text'),
        textAlign: p.getValue('textAlign'),
        textDirection: p.getValue('textDirection'),
        softWrap: p.getValue('softWrap'),
        overflow: p.getValue('overflow'),
        textScaleFactor: p.getValue('textScaleFactor'),
        maxLines: p.getValue('maxLines'),
        locale: p.getValue('locale'),
        strutStyle: p.getValue('strutStyle'),
        textWidthBasis: p.getValue('textWidthBasis'),
        textHeightBehavior: p.getValue('textHeightBehavior'),
        selectionRegistrar: p.getValue('selectionRegistrar'),
        selectionColor: p.getValue('selectionColor'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'text', init: text);
    mateParams.set(name: 'textAlign', init: textAlign);
    mateParams.set(name: 'textDirection', init: textDirection);
    mateParams.set(name: 'softWrap', init: softWrap);
    mateParams.set(name: 'overflow', init: overflow);
    mateParams.set(name: 'textScaleFactor', init: textScaleFactor);
    mateParams.set(name: 'maxLines', init: maxLines);
    mateParams.set(name: 'locale', init: locale);
    mateParams.set(name: 'strutStyle', init: strutStyle);
    mateParams.set(name: 'textWidthBasis', init: textWidthBasis);
    mateParams.set(name: 'textHeightBehavior', init: textHeightBehavior);
    mateParams.set(name: 'selectionRegistrar', init: selectionRegistrar);
    mateParams.set(name: 'selectionColor', init: selectionColor);
  }
}

/// class RawImage extends LeafRenderObjectWidget
class RawImage$Mate extends RawImage with WidgetMate<RawImage$Mate> {
  /// RawImage RawImage({Key? key, Image? image, String? debugImageLabel, double? width, double? height, double scale = 1.0, Color? color, Animation<double>? opacity, BlendMode? colorBlendMode, BoxFit? fit, AlignmentGeometry alignment = Alignment.center, ImageRepeat repeat = ImageRepeat.noRepeat, Rect? centerSlice, bool matchTextDirection = false, bool invertColors = false, FilterQuality filterQuality = FilterQuality.low, bool isAntiAlias = false})
  RawImage$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {Image? image} , hasDefaultValue:false, defaultValueCode:null
    Image? image,

    /// optionalParameters: {String? debugImageLabel} , hasDefaultValue:false, defaultValueCode:null
    String? debugImageLabel,

    /// optionalParameters: {double? width} , hasDefaultValue:false, defaultValueCode:null
    double? width,

    /// optionalParameters: {double? height} , hasDefaultValue:false, defaultValueCode:null
    double? height,

    /// optionalParameters: {double scale = 1.0} , hasDefaultValue:true, defaultValueCode:1.0
    required double scale,

    /// optionalParameters: {Color? color} , hasDefaultValue:false, defaultValueCode:null
    Color? color,

    /// optionalParameters: {Animation<double>? opacity} , hasDefaultValue:false, defaultValueCode:null
    Animation<double>? opacity,

    /// optionalParameters: {BlendMode? colorBlendMode} , hasDefaultValue:false, defaultValueCode:null
    BlendMode? colorBlendMode,

    /// optionalParameters: {BoxFit? fit} , hasDefaultValue:false, defaultValueCode:null
    BoxFit? fit,

    /// optionalParameters: {AlignmentGeometry alignment = Alignment.center} , hasDefaultValue:true, defaultValueCode:Alignment.center
    required AlignmentGeometry alignment,

    /// optionalParameters: {ImageRepeat repeat = ImageRepeat.noRepeat} , hasDefaultValue:true, defaultValueCode:ImageRepeat.noRepeat
    required ImageRepeat repeat,

    /// optionalParameters: {Rect? centerSlice} , hasDefaultValue:false, defaultValueCode:null
    Rect? centerSlice,

    /// optionalParameters: {bool matchTextDirection = false} , hasDefaultValue:true, defaultValueCode:false
    required bool matchTextDirection,

    /// optionalParameters: {bool invertColors = false} , hasDefaultValue:true, defaultValueCode:false
    required bool invertColors,

    /// optionalParameters: {FilterQuality filterQuality = FilterQuality.low} , hasDefaultValue:true, defaultValueCode:FilterQuality.low
    required FilterQuality filterQuality,

    /// optionalParameters: {bool isAntiAlias = false} , hasDefaultValue:true, defaultValueCode:false
    required bool isAntiAlias,
  }) : super(
          key: key,
          image: image,
          debugImageLabel: debugImageLabel,
          width: width,
          height: height,
          scale: scale,
          color: color,
          opacity: opacity,
          colorBlendMode: colorBlendMode,
          fit: fit,
          alignment: alignment,
          repeat: repeat,
          centerSlice: centerSlice,
          matchTextDirection: matchTextDirection,
          invertColors: invertColors,
          filterQuality: filterQuality,
          isAntiAlias: isAntiAlias,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => RawImage$Mate(
        key: p.getValue('key'),
        image: p.getValue('image'),
        debugImageLabel: p.getValue('debugImageLabel'),
        width: p.getValue('width'),
        height: p.getValue('height'),
        scale: p.getValue('scale'),
        color: p.getValue('color'),
        opacity: p.getValue('opacity'),
        colorBlendMode: p.getValue('colorBlendMode'),
        fit: p.getValue('fit'),
        alignment: p.getValue('alignment'),
        repeat: p.getValue('repeat'),
        centerSlice: p.getValue('centerSlice'),
        matchTextDirection: p.getValue('matchTextDirection'),
        invertColors: p.getValue('invertColors'),
        filterQuality: p.getValue('filterQuality'),
        isAntiAlias: p.getValue('isAntiAlias'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'image', init: image);
    mateParams.set(name: 'debugImageLabel', init: debugImageLabel);
    mateParams.set(name: 'width', init: width);
    mateParams.set(name: 'height', init: height);
    mateParams.set(name: 'scale', init: scale);
    mateParams.set(name: 'color', init: color);
    mateParams.set(name: 'opacity', init: opacity);
    mateParams.set(name: 'colorBlendMode', init: colorBlendMode);
    mateParams.set(name: 'fit', init: fit);
    mateParams.set(name: 'alignment', init: alignment);
    mateParams.set(name: 'repeat', init: repeat);
    mateParams.set(name: 'centerSlice', init: centerSlice);
    mateParams.set(name: 'matchTextDirection', init: matchTextDirection);
    mateParams.set(name: 'invertColors', init: invertColors);
    mateParams.set(name: 'filterQuality', init: filterQuality);
    mateParams.set(name: 'isAntiAlias', init: isAntiAlias);
  }
}

/// class DefaultAssetBundle extends InheritedWidget
class DefaultAssetBundle$Mate extends DefaultAssetBundle with WidgetMate<DefaultAssetBundle$Mate> {
  /// DefaultAssetBundle DefaultAssetBundle({Key? key, required AssetBundle bundle, required Widget child})
  DefaultAssetBundle$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {required AssetBundle bundle} , hasDefaultValue:false, defaultValueCode:null
    required AssetBundle bundle,

    /// optionalParameters: {required Widget child} , hasDefaultValue:false, defaultValueCode:null
    required Widget child,
  }) : super(
          key: key,
          bundle: bundle,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => DefaultAssetBundle$Mate(
        key: p.getValue('key'),
        bundle: p.getValue('bundle'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'bundle', init: bundle);
    mateParams.set(name: 'child', init: child);
  }
}

/// class WidgetToRenderBoxAdapter extends LeafRenderObjectWidget
class WidgetToRenderBoxAdapter$Mate extends WidgetToRenderBoxAdapter with WidgetMate<WidgetToRenderBoxAdapter$Mate> {
  /// WidgetToRenderBoxAdapter WidgetToRenderBoxAdapter({required RenderBox renderBox, void Function()? onBuild, void Function()? onUnmount})
  WidgetToRenderBoxAdapter$Mate({
    /// optionalParameters: {required RenderBox renderBox} , hasDefaultValue:false, defaultValueCode:null
    required RenderBox renderBox,

    /// optionalParameters: {void Function()? onBuild} , hasDefaultValue:false, defaultValueCode:null
    VoidCallback? onBuild,

    /// optionalParameters: {void Function()? onUnmount} , hasDefaultValue:false, defaultValueCode:null
    VoidCallback? onUnmount,
  }) : super(
          renderBox: renderBox,
          onBuild: onBuild,
          onUnmount: onUnmount,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => WidgetToRenderBoxAdapter$Mate(
        renderBox: p.getValue('renderBox'),
        onBuild: p.getValue('onBuild'),
        onUnmount: p.getValue('onUnmount'),
      ),
    );
    mateParams.set(name: 'renderBox', init: renderBox);
    mateParams.set(name: 'onBuild', init: onBuild);
    mateParams.set(name: 'onUnmount', init: onUnmount);
  }
}

/// class Listener extends SingleChildRenderObjectWidget
class Listener$Mate extends Listener with WidgetMate<Listener$Mate> {
  /// Listener Listener({Key? key, void Function(PointerDownEvent)? onPointerDown, void Function(PointerMoveEvent)? onPointerMove, void Function(PointerUpEvent)? onPointerUp, void Function(PointerHoverEvent)? onPointerHover, void Function(PointerCancelEvent)? onPointerCancel, void Function(PointerPanZoomStartEvent)? onPointerPanZoomStart, void Function(PointerPanZoomUpdateEvent)? onPointerPanZoomUpdate, void Function(PointerPanZoomEndEvent)? onPointerPanZoomEnd, void Function(PointerSignalEvent)? onPointerSignal, HitTestBehavior behavior = HitTestBehavior.deferToChild, Widget? child})
  Listener$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {void Function(PointerDownEvent)? onPointerDown} , hasDefaultValue:false, defaultValueCode:null
    PointerDownEventListener? onPointerDown,

    /// optionalParameters: {void Function(PointerMoveEvent)? onPointerMove} , hasDefaultValue:false, defaultValueCode:null
    PointerMoveEventListener? onPointerMove,

    /// optionalParameters: {void Function(PointerUpEvent)? onPointerUp} , hasDefaultValue:false, defaultValueCode:null
    PointerUpEventListener? onPointerUp,

    /// optionalParameters: {void Function(PointerHoverEvent)? onPointerHover} , hasDefaultValue:false, defaultValueCode:null
    PointerHoverEventListener? onPointerHover,

    /// optionalParameters: {void Function(PointerCancelEvent)? onPointerCancel} , hasDefaultValue:false, defaultValueCode:null
    PointerCancelEventListener? onPointerCancel,

    /// optionalParameters: {void Function(PointerPanZoomStartEvent)? onPointerPanZoomStart} , hasDefaultValue:false, defaultValueCode:null
    PointerPanZoomStartEventListener? onPointerPanZoomStart,

    /// optionalParameters: {void Function(PointerPanZoomUpdateEvent)? onPointerPanZoomUpdate} , hasDefaultValue:false, defaultValueCode:null
    PointerPanZoomUpdateEventListener? onPointerPanZoomUpdate,

    /// optionalParameters: {void Function(PointerPanZoomEndEvent)? onPointerPanZoomEnd} , hasDefaultValue:false, defaultValueCode:null
    PointerPanZoomEndEventListener? onPointerPanZoomEnd,

    /// optionalParameters: {void Function(PointerSignalEvent)? onPointerSignal} , hasDefaultValue:false, defaultValueCode:null
    PointerSignalEventListener? onPointerSignal,

    /// optionalParameters: {HitTestBehavior behavior = HitTestBehavior.deferToChild} , hasDefaultValue:true, defaultValueCode:HitTestBehavior.deferToChild
    required HitTestBehavior behavior,

    /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
    Widget? child,
  }) : super(
          key: key,
          onPointerDown: onPointerDown,
          onPointerMove: onPointerMove,
          onPointerUp: onPointerUp,
          onPointerHover: onPointerHover,
          onPointerCancel: onPointerCancel,
          onPointerPanZoomStart: onPointerPanZoomStart,
          onPointerPanZoomUpdate: onPointerPanZoomUpdate,
          onPointerPanZoomEnd: onPointerPanZoomEnd,
          onPointerSignal: onPointerSignal,
          behavior: behavior,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Listener$Mate(
        key: p.getValue('key'),
        onPointerDown: p.getValue('onPointerDown'),
        onPointerMove: p.getValue('onPointerMove'),
        onPointerUp: p.getValue('onPointerUp'),
        onPointerHover: p.getValue('onPointerHover'),
        onPointerCancel: p.getValue('onPointerCancel'),
        onPointerPanZoomStart: p.getValue('onPointerPanZoomStart'),
        onPointerPanZoomUpdate: p.getValue('onPointerPanZoomUpdate'),
        onPointerPanZoomEnd: p.getValue('onPointerPanZoomEnd'),
        onPointerSignal: p.getValue('onPointerSignal'),
        behavior: p.getValue('behavior'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'onPointerDown', init: onPointerDown);
    mateParams.set(name: 'onPointerMove', init: onPointerMove);
    mateParams.set(name: 'onPointerUp', init: onPointerUp);
    mateParams.set(name: 'onPointerHover', init: onPointerHover);
    mateParams.set(name: 'onPointerCancel', init: onPointerCancel);
    mateParams.set(name: 'onPointerPanZoomStart', init: onPointerPanZoomStart);
    mateParams.set(name: 'onPointerPanZoomUpdate', init: onPointerPanZoomUpdate);
    mateParams.set(name: 'onPointerPanZoomEnd', init: onPointerPanZoomEnd);
    mateParams.set(name: 'onPointerSignal', init: onPointerSignal);
    mateParams.set(name: 'behavior', init: behavior);
    mateParams.set(name: 'child', init: child);
  }
}

/// class MouseRegion extends SingleChildRenderObjectWidget
class MouseRegion$Mate extends MouseRegion with WidgetMate<MouseRegion$Mate> {
  /// MouseRegion MouseRegion({Key? key, void Function(PointerEnterEvent)? onEnter, void Function(PointerExitEvent)? onExit, void Function(PointerHoverEvent)? onHover, MouseCursor cursor = MouseCursor.defer, bool opaque = true, HitTestBehavior? hitTestBehavior, Widget? child})
  MouseRegion$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {void Function(PointerEnterEvent)? onEnter} , hasDefaultValue:false, defaultValueCode:null
    PointerEnterEventListener? onEnter,

    /// optionalParameters: {void Function(PointerExitEvent)? onExit} , hasDefaultValue:false, defaultValueCode:null
    PointerExitEventListener? onExit,

    /// optionalParameters: {void Function(PointerHoverEvent)? onHover} , hasDefaultValue:false, defaultValueCode:null
    PointerHoverEventListener? onHover,

    /// optionalParameters: {MouseCursor cursor = MouseCursor.defer} , hasDefaultValue:true, defaultValueCode:MouseCursor.defer
    required MouseCursor cursor,

    /// optionalParameters: {bool opaque = true} , hasDefaultValue:true, defaultValueCode:true
    required bool opaque,

    /// optionalParameters: {HitTestBehavior? hitTestBehavior} , hasDefaultValue:false, defaultValueCode:null
    HitTestBehavior? hitTestBehavior,

    /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
    Widget? child,
  }) : super(
          key: key,
          onEnter: onEnter,
          onExit: onExit,
          onHover: onHover,
          cursor: cursor,
          opaque: opaque,
          hitTestBehavior: hitTestBehavior,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => MouseRegion$Mate(
        key: p.getValue('key'),
        onEnter: p.getValue('onEnter'),
        onExit: p.getValue('onExit'),
        onHover: p.getValue('onHover'),
        cursor: p.getValue('cursor'),
        opaque: p.getValue('opaque'),
        hitTestBehavior: p.getValue('hitTestBehavior'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'onEnter', init: onEnter);
    mateParams.set(name: 'onExit', init: onExit);
    mateParams.set(name: 'onHover', init: onHover);
    mateParams.set(name: 'cursor', init: cursor);
    mateParams.set(name: 'opaque', init: opaque);
    mateParams.set(name: 'hitTestBehavior', init: hitTestBehavior);
    mateParams.set(name: 'child', init: child);
  }
}

/// class RepaintBoundary extends SingleChildRenderObjectWidget
class RepaintBoundary$Mate extends RepaintBoundary with WidgetMate<RepaintBoundary$Mate> {
  /// RepaintBoundary RepaintBoundary({Key? key, Widget? child})
  RepaintBoundary$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
    Widget? child,
  }) : super(
          key: key,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => RepaintBoundary$Mate(
        key: p.getValue('key'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'child', init: child);
  }
}

/// class IgnorePointer extends SingleChildRenderObjectWidget
class IgnorePointer$Mate extends IgnorePointer with WidgetMate<IgnorePointer$Mate> {
  /// IgnorePointer IgnorePointer({Key? key, bool ignoring = true, bool? ignoringSemantics, Widget? child})
  IgnorePointer$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {bool ignoring = true} , hasDefaultValue:true, defaultValueCode:true
    required bool ignoring,

    /// optionalParameters: {bool? ignoringSemantics} , hasDefaultValue:false, defaultValueCode:null
    bool? ignoringSemantics,

    /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
    Widget? child,
  }) : super(
          key: key,
          ignoring: ignoring,
          ignoringSemantics: ignoringSemantics,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => IgnorePointer$Mate(
        key: p.getValue('key'),
        ignoring: p.getValue('ignoring'),
        ignoringSemantics: p.getValue('ignoringSemantics'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'ignoring', init: ignoring);
    mateParams.set(name: 'ignoringSemantics', init: ignoringSemantics);
    mateParams.set(name: 'child', init: child);
  }
}

/// class AbsorbPointer extends SingleChildRenderObjectWidget
class AbsorbPointer$Mate extends AbsorbPointer with WidgetMate<AbsorbPointer$Mate> {
  /// AbsorbPointer AbsorbPointer({Key? key, bool absorbing = true, Widget? child, bool? ignoringSemantics})
  AbsorbPointer$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {bool absorbing = true} , hasDefaultValue:true, defaultValueCode:true
    required bool absorbing,

    /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
    Widget? child,

    /// optionalParameters: {bool? ignoringSemantics} , hasDefaultValue:false, defaultValueCode:null
    bool? ignoringSemantics,
  }) : super(
          key: key,
          absorbing: absorbing,
          child: child,
          ignoringSemantics: ignoringSemantics,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => AbsorbPointer$Mate(
        key: p.getValue('key'),
        absorbing: p.getValue('absorbing'),
        child: p.getValue('child'),
        ignoringSemantics: p.getValue('ignoringSemantics'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'absorbing', init: absorbing);
    mateParams.set(name: 'child', init: child);
    mateParams.set(name: 'ignoringSemantics', init: ignoringSemantics);
  }
}

/// class MetaData extends SingleChildRenderObjectWidget
class MetaData$Mate extends MetaData with WidgetMate<MetaData$Mate> {
  /// MetaData MetaData({Key? key, dynamic metaData, HitTestBehavior behavior = HitTestBehavior.deferToChild, Widget? child})
  MetaData$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {dynamic metaData} , hasDefaultValue:false, defaultValueCode:null
    required dynamic metaData,

    /// optionalParameters: {HitTestBehavior behavior = HitTestBehavior.deferToChild} , hasDefaultValue:true, defaultValueCode:HitTestBehavior.deferToChild
    required HitTestBehavior behavior,

    /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
    Widget? child,
  }) : super(
          key: key,
          metaData: metaData,
          behavior: behavior,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => MetaData$Mate(
        key: p.getValue('key'),
        metaData: p.getValue('metaData'),
        behavior: p.getValue('behavior'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'metaData', init: metaData);
    mateParams.set(name: 'behavior', init: behavior);
    mateParams.set(name: 'child', init: child);
  }
}

/// class Semantics extends SingleChildRenderObjectWidget
class Semantics$Mate extends Semantics with WidgetMate<Semantics$Mate> {
  /// Semantics Semantics({Key? key, Widget? child, bool container = false, bool explicitChildNodes = false, bool excludeSemantics = false, bool? enabled, bool? checked, bool? mixed, bool? selected, bool? toggled, bool? button, bool? slider, bool? keyboardKey, bool? link, bool? header, bool? textField, bool? readOnly, bool? focusable, bool? focused, bool? inMutuallyExclusiveGroup, bool? obscured, bool? multiline, bool? scopesRoute, bool? namesRoute, bool? hidden, bool? image, bool? liveRegion, int? maxValueLength, int? currentValueLength, String? label, AttributedString? attributedLabel, String? value, AttributedString? attributedValue, String? increasedValue, AttributedString? attributedIncreasedValue, String? decreasedValue, AttributedString? attributedDecreasedValue, String? hint, AttributedString? attributedHint, String? tooltip, String? onTapHint, String? onLongPressHint, TextDirection? textDirection, SemanticsSortKey? sortKey, SemanticsTag? tagForChildren, void Function()? onTap, void Function()? onLongPress, void Function()? onScrollLeft, void Function()? onScrollRight, void Function()? onScrollUp, void Function()? onScrollDown, void Function()? onIncrease, void Function()? onDecrease, void Function()? onCopy, void Function()? onCut, void Function()? onPaste, void Function()? onDismiss, void Function(bool)? onMoveCursorForwardByCharacter, void Function(bool)? onMoveCursorBackwardByCharacter, void Function(TextSelection)? onSetSelection, void Function(String)? onSetText, void Function()? onDidGainAccessibilityFocus, void Function()? onDidLoseAccessibilityFocus, Map<CustomSemanticsAction, void Function()>? customSemanticsActions})
  Semantics$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
    Widget? child,

    /// optionalParameters: {bool container = false} , hasDefaultValue:true, defaultValueCode:false
    required bool container,

    /// optionalParameters: {bool explicitChildNodes = false} , hasDefaultValue:true, defaultValueCode:false
    required bool explicitChildNodes,

    /// optionalParameters: {bool excludeSemantics = false} , hasDefaultValue:true, defaultValueCode:false
    required bool excludeSemantics,

    /// optionalParameters: {bool? enabled} , hasDefaultValue:false, defaultValueCode:null
    bool? enabled,

    /// optionalParameters: {bool? checked} , hasDefaultValue:false, defaultValueCode:null
    bool? checked,

    /// optionalParameters: {bool? mixed} , hasDefaultValue:false, defaultValueCode:null
    bool? mixed,

    /// optionalParameters: {bool? selected} , hasDefaultValue:false, defaultValueCode:null
    bool? selected,

    /// optionalParameters: {bool? toggled} , hasDefaultValue:false, defaultValueCode:null
    bool? toggled,

    /// optionalParameters: {bool? button} , hasDefaultValue:false, defaultValueCode:null
    bool? button,

    /// optionalParameters: {bool? slider} , hasDefaultValue:false, defaultValueCode:null
    bool? slider,

    /// optionalParameters: {bool? keyboardKey} , hasDefaultValue:false, defaultValueCode:null
    bool? keyboardKey,

    /// optionalParameters: {bool? link} , hasDefaultValue:false, defaultValueCode:null
    bool? link,

    /// optionalParameters: {bool? header} , hasDefaultValue:false, defaultValueCode:null
    bool? header,

    /// optionalParameters: {bool? textField} , hasDefaultValue:false, defaultValueCode:null
    bool? textField,

    /// optionalParameters: {bool? readOnly} , hasDefaultValue:false, defaultValueCode:null
    bool? readOnly,

    /// optionalParameters: {bool? focusable} , hasDefaultValue:false, defaultValueCode:null
    bool? focusable,

    /// optionalParameters: {bool? focused} , hasDefaultValue:false, defaultValueCode:null
    bool? focused,

    /// optionalParameters: {bool? inMutuallyExclusiveGroup} , hasDefaultValue:false, defaultValueCode:null
    bool? inMutuallyExclusiveGroup,

    /// optionalParameters: {bool? obscured} , hasDefaultValue:false, defaultValueCode:null
    bool? obscured,

    /// optionalParameters: {bool? multiline} , hasDefaultValue:false, defaultValueCode:null
    bool? multiline,

    /// optionalParameters: {bool? scopesRoute} , hasDefaultValue:false, defaultValueCode:null
    bool? scopesRoute,

    /// optionalParameters: {bool? namesRoute} , hasDefaultValue:false, defaultValueCode:null
    bool? namesRoute,

    /// optionalParameters: {bool? hidden} , hasDefaultValue:false, defaultValueCode:null
    bool? hidden,

    /// optionalParameters: {bool? image} , hasDefaultValue:false, defaultValueCode:null
    bool? image,

    /// optionalParameters: {bool? liveRegion} , hasDefaultValue:false, defaultValueCode:null
    bool? liveRegion,

    /// optionalParameters: {int? maxValueLength} , hasDefaultValue:false, defaultValueCode:null
    int? maxValueLength,

    /// optionalParameters: {int? currentValueLength} , hasDefaultValue:false, defaultValueCode:null
    int? currentValueLength,

    /// optionalParameters: {String? label} , hasDefaultValue:false, defaultValueCode:null
    String? label,

    /// optionalParameters: {AttributedString? attributedLabel} , hasDefaultValue:false, defaultValueCode:null
    AttributedString? attributedLabel,

    /// optionalParameters: {String? value} , hasDefaultValue:false, defaultValueCode:null
    String? value,

    /// optionalParameters: {AttributedString? attributedValue} , hasDefaultValue:false, defaultValueCode:null
    AttributedString? attributedValue,

    /// optionalParameters: {String? increasedValue} , hasDefaultValue:false, defaultValueCode:null
    String? increasedValue,

    /// optionalParameters: {AttributedString? attributedIncreasedValue} , hasDefaultValue:false, defaultValueCode:null
    AttributedString? attributedIncreasedValue,

    /// optionalParameters: {String? decreasedValue} , hasDefaultValue:false, defaultValueCode:null
    String? decreasedValue,

    /// optionalParameters: {AttributedString? attributedDecreasedValue} , hasDefaultValue:false, defaultValueCode:null
    AttributedString? attributedDecreasedValue,

    /// optionalParameters: {String? hint} , hasDefaultValue:false, defaultValueCode:null
    String? hint,

    /// optionalParameters: {AttributedString? attributedHint} , hasDefaultValue:false, defaultValueCode:null
    AttributedString? attributedHint,

    /// optionalParameters: {String? tooltip} , hasDefaultValue:false, defaultValueCode:null
    String? tooltip,

    /// optionalParameters: {String? onTapHint} , hasDefaultValue:false, defaultValueCode:null
    String? onTapHint,

    /// optionalParameters: {String? onLongPressHint} , hasDefaultValue:false, defaultValueCode:null
    String? onLongPressHint,

    /// optionalParameters: {TextDirection? textDirection} , hasDefaultValue:false, defaultValueCode:null
    TextDirection? textDirection,

    /// optionalParameters: {SemanticsSortKey? sortKey} , hasDefaultValue:false, defaultValueCode:null
    SemanticsSortKey? sortKey,

    /// optionalParameters: {SemanticsTag? tagForChildren} , hasDefaultValue:false, defaultValueCode:null
    SemanticsTag? tagForChildren,

    /// optionalParameters: {void Function()? onTap} , hasDefaultValue:false, defaultValueCode:null
    VoidCallback? onTap,

    /// optionalParameters: {void Function()? onLongPress} , hasDefaultValue:false, defaultValueCode:null
    VoidCallback? onLongPress,

    /// optionalParameters: {void Function()? onScrollLeft} , hasDefaultValue:false, defaultValueCode:null
    VoidCallback? onScrollLeft,

    /// optionalParameters: {void Function()? onScrollRight} , hasDefaultValue:false, defaultValueCode:null
    VoidCallback? onScrollRight,

    /// optionalParameters: {void Function()? onScrollUp} , hasDefaultValue:false, defaultValueCode:null
    VoidCallback? onScrollUp,

    /// optionalParameters: {void Function()? onScrollDown} , hasDefaultValue:false, defaultValueCode:null
    VoidCallback? onScrollDown,

    /// optionalParameters: {void Function()? onIncrease} , hasDefaultValue:false, defaultValueCode:null
    VoidCallback? onIncrease,

    /// optionalParameters: {void Function()? onDecrease} , hasDefaultValue:false, defaultValueCode:null
    VoidCallback? onDecrease,

    /// optionalParameters: {void Function()? onCopy} , hasDefaultValue:false, defaultValueCode:null
    VoidCallback? onCopy,

    /// optionalParameters: {void Function()? onCut} , hasDefaultValue:false, defaultValueCode:null
    VoidCallback? onCut,

    /// optionalParameters: {void Function()? onPaste} , hasDefaultValue:false, defaultValueCode:null
    VoidCallback? onPaste,

    /// optionalParameters: {void Function()? onDismiss} , hasDefaultValue:false, defaultValueCode:null
    VoidCallback? onDismiss,

    /// optionalParameters: {void Function(bool)? onMoveCursorForwardByCharacter} , hasDefaultValue:false, defaultValueCode:null
    MoveCursorHandler? onMoveCursorForwardByCharacter,

    /// optionalParameters: {void Function(bool)? onMoveCursorBackwardByCharacter} , hasDefaultValue:false, defaultValueCode:null
    MoveCursorHandler? onMoveCursorBackwardByCharacter,

    /// optionalParameters: {void Function(TextSelection)? onSetSelection} , hasDefaultValue:false, defaultValueCode:null
    SetSelectionHandler? onSetSelection,

    /// optionalParameters: {void Function(String)? onSetText} , hasDefaultValue:false, defaultValueCode:null
    SetTextHandler? onSetText,

    /// optionalParameters: {void Function()? onDidGainAccessibilityFocus} , hasDefaultValue:false, defaultValueCode:null
    VoidCallback? onDidGainAccessibilityFocus,

    /// optionalParameters: {void Function()? onDidLoseAccessibilityFocus} , hasDefaultValue:false, defaultValueCode:null
    VoidCallback? onDidLoseAccessibilityFocus,

    /// optionalParameters: {Map<CustomSemanticsAction, void Function()>? customSemanticsActions} , hasDefaultValue:false, defaultValueCode:null
    Map<CustomSemanticsAction, VoidCallback>? customSemanticsActions,
  }) : super(
          key: key,
          child: child,
          container: container,
          explicitChildNodes: explicitChildNodes,
          excludeSemantics: excludeSemantics,
          enabled: enabled,
          checked: checked,
          mixed: mixed,
          selected: selected,
          toggled: toggled,
          button: button,
          slider: slider,
          keyboardKey: keyboardKey,
          link: link,
          header: header,
          textField: textField,
          readOnly: readOnly,
          focusable: focusable,
          focused: focused,
          inMutuallyExclusiveGroup: inMutuallyExclusiveGroup,
          obscured: obscured,
          multiline: multiline,
          scopesRoute: scopesRoute,
          namesRoute: namesRoute,
          hidden: hidden,
          image: image,
          liveRegion: liveRegion,
          maxValueLength: maxValueLength,
          currentValueLength: currentValueLength,
          label: label,
          attributedLabel: attributedLabel,
          value: value,
          attributedValue: attributedValue,
          increasedValue: increasedValue,
          attributedIncreasedValue: attributedIncreasedValue,
          decreasedValue: decreasedValue,
          attributedDecreasedValue: attributedDecreasedValue,
          hint: hint,
          attributedHint: attributedHint,
          tooltip: tooltip,
          onTapHint: onTapHint,
          onLongPressHint: onLongPressHint,
          textDirection: textDirection,
          sortKey: sortKey,
          tagForChildren: tagForChildren,
          onTap: onTap,
          onLongPress: onLongPress,
          onScrollLeft: onScrollLeft,
          onScrollRight: onScrollRight,
          onScrollUp: onScrollUp,
          onScrollDown: onScrollDown,
          onIncrease: onIncrease,
          onDecrease: onDecrease,
          onCopy: onCopy,
          onCut: onCut,
          onPaste: onPaste,
          onDismiss: onDismiss,
          onMoveCursorForwardByCharacter: onMoveCursorForwardByCharacter,
          onMoveCursorBackwardByCharacter: onMoveCursorBackwardByCharacter,
          onSetSelection: onSetSelection,
          onSetText: onSetText,
          onDidGainAccessibilityFocus: onDidGainAccessibilityFocus,
          onDidLoseAccessibilityFocus: onDidLoseAccessibilityFocus,
          customSemanticsActions: customSemanticsActions,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Semantics$Mate(
        key: p.getValue('key'),
        child: p.getValue('child'),
        container: p.getValue('container'),
        explicitChildNodes: p.getValue('explicitChildNodes'),
        excludeSemantics: p.getValue('excludeSemantics'),
        enabled: p.getValue('enabled'),
        checked: p.getValue('checked'),
        mixed: p.getValue('mixed'),
        selected: p.getValue('selected'),
        toggled: p.getValue('toggled'),
        button: p.getValue('button'),
        slider: p.getValue('slider'),
        keyboardKey: p.getValue('keyboardKey'),
        link: p.getValue('link'),
        header: p.getValue('header'),
        textField: p.getValue('textField'),
        readOnly: p.getValue('readOnly'),
        focusable: p.getValue('focusable'),
        focused: p.getValue('focused'),
        inMutuallyExclusiveGroup: p.getValue('inMutuallyExclusiveGroup'),
        obscured: p.getValue('obscured'),
        multiline: p.getValue('multiline'),
        scopesRoute: p.getValue('scopesRoute'),
        namesRoute: p.getValue('namesRoute'),
        hidden: p.getValue('hidden'),
        image: p.getValue('image'),
        liveRegion: p.getValue('liveRegion'),
        maxValueLength: p.getValue('maxValueLength'),
        currentValueLength: p.getValue('currentValueLength'),
        label: p.getValue('label'),
        attributedLabel: p.getValue('attributedLabel'),
        value: p.getValue('value'),
        attributedValue: p.getValue('attributedValue'),
        increasedValue: p.getValue('increasedValue'),
        attributedIncreasedValue: p.getValue('attributedIncreasedValue'),
        decreasedValue: p.getValue('decreasedValue'),
        attributedDecreasedValue: p.getValue('attributedDecreasedValue'),
        hint: p.getValue('hint'),
        attributedHint: p.getValue('attributedHint'),
        tooltip: p.getValue('tooltip'),
        onTapHint: p.getValue('onTapHint'),
        onLongPressHint: p.getValue('onLongPressHint'),
        textDirection: p.getValue('textDirection'),
        sortKey: p.getValue('sortKey'),
        tagForChildren: p.getValue('tagForChildren'),
        onTap: p.getValue('onTap'),
        onLongPress: p.getValue('onLongPress'),
        onScrollLeft: p.getValue('onScrollLeft'),
        onScrollRight: p.getValue('onScrollRight'),
        onScrollUp: p.getValue('onScrollUp'),
        onScrollDown: p.getValue('onScrollDown'),
        onIncrease: p.getValue('onIncrease'),
        onDecrease: p.getValue('onDecrease'),
        onCopy: p.getValue('onCopy'),
        onCut: p.getValue('onCut'),
        onPaste: p.getValue('onPaste'),
        onDismiss: p.getValue('onDismiss'),
        onMoveCursorForwardByCharacter: p.getValue('onMoveCursorForwardByCharacter'),
        onMoveCursorBackwardByCharacter: p.getValue('onMoveCursorBackwardByCharacter'),
        onSetSelection: p.getValue('onSetSelection'),
        onSetText: p.getValue('onSetText'),
        onDidGainAccessibilityFocus: p.getValue('onDidGainAccessibilityFocus'),
        onDidLoseAccessibilityFocus: p.getValue('onDidLoseAccessibilityFocus'),
        customSemanticsActions: p.getValue('customSemanticsActions'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'child', init: child);
    mateParams.set(name: 'container', init: container);
    mateParams.set(name: 'explicitChildNodes', init: explicitChildNodes);
    mateParams.set(name: 'excludeSemantics', init: excludeSemantics);
    mateParams.set(name: 'enabled', init: enabled);
    mateParams.set(name: 'checked', init: checked);
    mateParams.set(name: 'mixed', init: mixed);
    mateParams.set(name: 'selected', init: selected);
    mateParams.set(name: 'toggled', init: toggled);
    mateParams.set(name: 'button', init: button);
    mateParams.set(name: 'slider', init: slider);
    mateParams.set(name: 'keyboardKey', init: keyboardKey);
    mateParams.set(name: 'link', init: link);
    mateParams.set(name: 'header', init: header);
    mateParams.set(name: 'textField', init: textField);
    mateParams.set(name: 'readOnly', init: readOnly);
    mateParams.set(name: 'focusable', init: focusable);
    mateParams.set(name: 'focused', init: focused);
    mateParams.set(name: 'inMutuallyExclusiveGroup', init: inMutuallyExclusiveGroup);
    mateParams.set(name: 'obscured', init: obscured);
    mateParams.set(name: 'multiline', init: multiline);
    mateParams.set(name: 'scopesRoute', init: scopesRoute);
    mateParams.set(name: 'namesRoute', init: namesRoute);
    mateParams.set(name: 'hidden', init: hidden);
    mateParams.set(name: 'image', init: image);
    mateParams.set(name: 'liveRegion', init: liveRegion);
    mateParams.set(name: 'maxValueLength', init: maxValueLength);
    mateParams.set(name: 'currentValueLength', init: currentValueLength);
    mateParams.set(name: 'label', init: label);
    mateParams.set(name: 'attributedLabel', init: attributedLabel);
    mateParams.set(name: 'value', init: value);
    mateParams.set(name: 'attributedValue', init: attributedValue);
    mateParams.set(name: 'increasedValue', init: increasedValue);
    mateParams.set(name: 'attributedIncreasedValue', init: attributedIncreasedValue);
    mateParams.set(name: 'decreasedValue', init: decreasedValue);
    mateParams.set(name: 'attributedDecreasedValue', init: attributedDecreasedValue);
    mateParams.set(name: 'hint', init: hint);
    mateParams.set(name: 'attributedHint', init: attributedHint);
    mateParams.set(name: 'tooltip', init: tooltip);
    mateParams.set(name: 'onTapHint', init: onTapHint);
    mateParams.set(name: 'onLongPressHint', init: onLongPressHint);
    mateParams.set(name: 'textDirection', init: textDirection);
    mateParams.set(name: 'sortKey', init: sortKey);
    mateParams.set(name: 'tagForChildren', init: tagForChildren);
    mateParams.set(name: 'onTap', init: onTap);
    mateParams.set(name: 'onLongPress', init: onLongPress);
    mateParams.set(name: 'onScrollLeft', init: onScrollLeft);
    mateParams.set(name: 'onScrollRight', init: onScrollRight);
    mateParams.set(name: 'onScrollUp', init: onScrollUp);
    mateParams.set(name: 'onScrollDown', init: onScrollDown);
    mateParams.set(name: 'onIncrease', init: onIncrease);
    mateParams.set(name: 'onDecrease', init: onDecrease);
    mateParams.set(name: 'onCopy', init: onCopy);
    mateParams.set(name: 'onCut', init: onCut);
    mateParams.set(name: 'onPaste', init: onPaste);
    mateParams.set(name: 'onDismiss', init: onDismiss);
    mateParams.set(name: 'onMoveCursorForwardByCharacter', init: onMoveCursorForwardByCharacter);
    mateParams.set(name: 'onMoveCursorBackwardByCharacter', init: onMoveCursorBackwardByCharacter);
    mateParams.set(name: 'onSetSelection', init: onSetSelection);
    mateParams.set(name: 'onSetText', init: onSetText);
    mateParams.set(name: 'onDidGainAccessibilityFocus', init: onDidGainAccessibilityFocus);
    mateParams.set(name: 'onDidLoseAccessibilityFocus', init: onDidLoseAccessibilityFocus);
    mateParams.set(name: 'customSemanticsActions', init: customSemanticsActions);
  }

  /// Semantics Semantics.fromProperties({Key? key, Widget? child, bool container = false, bool explicitChildNodes = false, bool excludeSemantics = false, required SemanticsProperties properties})
  Semantics$Mate.fromProperties({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
    Widget? child,

    /// optionalParameters: {bool container = false} , hasDefaultValue:true, defaultValueCode:false
    required bool container,

    /// optionalParameters: {bool explicitChildNodes = false} , hasDefaultValue:true, defaultValueCode:false
    required bool explicitChildNodes,

    /// optionalParameters: {bool excludeSemantics = false} , hasDefaultValue:true, defaultValueCode:false
    required bool excludeSemantics,

    /// optionalParameters: {required SemanticsProperties properties} , hasDefaultValue:false, defaultValueCode:null
    required SemanticsProperties properties,
  }) : super.fromProperties(
          key: key,
          child: child,
          container: container,
          explicitChildNodes: explicitChildNodes,
          excludeSemantics: excludeSemantics,
          properties: properties,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Semantics$Mate.fromProperties(
        key: p.getValue('key'),
        child: p.getValue('child'),
        container: p.getValue('container'),
        explicitChildNodes: p.getValue('explicitChildNodes'),
        excludeSemantics: p.getValue('excludeSemantics'),
        properties: p.getValue('properties'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'child', init: child);
    mateParams.set(name: 'container', init: container);
    mateParams.set(name: 'explicitChildNodes', init: explicitChildNodes);
    mateParams.set(name: 'excludeSemantics', init: excludeSemantics);
    mateParams.set(name: 'properties', init: properties);
  }
}

/// class MergeSemantics extends SingleChildRenderObjectWidget
class MergeSemantics$Mate extends MergeSemantics with WidgetMate<MergeSemantics$Mate> {
  /// MergeSemantics MergeSemantics({Key? key, Widget? child})
  MergeSemantics$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
    Widget? child,
  }) : super(
          key: key,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => MergeSemantics$Mate(
        key: p.getValue('key'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'child', init: child);
  }
}

/// class BlockSemantics extends SingleChildRenderObjectWidget
class BlockSemantics$Mate extends BlockSemantics with WidgetMate<BlockSemantics$Mate> {
  /// BlockSemantics BlockSemantics({Key? key, bool blocking = true, Widget? child})
  BlockSemantics$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {bool blocking = true} , hasDefaultValue:true, defaultValueCode:true
    required bool blocking,

    /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
    Widget? child,
  }) : super(
          key: key,
          blocking: blocking,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => BlockSemantics$Mate(
        key: p.getValue('key'),
        blocking: p.getValue('blocking'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'blocking', init: blocking);
    mateParams.set(name: 'child', init: child);
  }
}

/// class ExcludeSemantics extends SingleChildRenderObjectWidget
class ExcludeSemantics$Mate extends ExcludeSemantics with WidgetMate<ExcludeSemantics$Mate> {
  /// ExcludeSemantics ExcludeSemantics({Key? key, bool excluding = true, Widget? child})
  ExcludeSemantics$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {bool excluding = true} , hasDefaultValue:true, defaultValueCode:true
    required bool excluding,

    /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
    Widget? child,
  }) : super(
          key: key,
          excluding: excluding,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => ExcludeSemantics$Mate(
        key: p.getValue('key'),
        excluding: p.getValue('excluding'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'excluding', init: excluding);
    mateParams.set(name: 'child', init: child);
  }
}

/// class IndexedSemantics extends SingleChildRenderObjectWidget
class IndexedSemantics$Mate extends IndexedSemantics with WidgetMate<IndexedSemantics$Mate> {
  /// IndexedSemantics IndexedSemantics({Key? key, required int index, Widget? child})
  IndexedSemantics$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {required int index} , hasDefaultValue:false, defaultValueCode:null
    required int index,

    /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
    Widget? child,
  }) : super(
          key: key,
          index: index,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => IndexedSemantics$Mate(
        key: p.getValue('key'),
        index: p.getValue('index'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'index', init: index);
    mateParams.set(name: 'child', init: child);
  }
}

/// class KeyedSubtree extends StatelessWidget
class KeyedSubtree$Mate extends KeyedSubtree with WidgetMate<KeyedSubtree$Mate> {
  /// KeyedSubtree KeyedSubtree({Key? key, required Widget child})
  KeyedSubtree$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {required Widget child} , hasDefaultValue:false, defaultValueCode:null
    required Widget child,
  }) : super(
          key: key,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => KeyedSubtree$Mate(
        key: p.getValue('key'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'child', init: child);
  }
}

/// class Builder extends StatelessWidget
class Builder$Mate extends Builder with WidgetMate<Builder$Mate> {
  /// Builder Builder({Key? key, required Widget Function(BuildContext) builder})
  Builder$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {required Widget Function(BuildContext) builder} , hasDefaultValue:false, defaultValueCode:null
    required WidgetBuilder builder,
  }) : super(
          key: key,
          builder: builder,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Builder$Mate(
        key: p.getValue('key'),
        builder: p.getValue('builder'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'builder', init: builder);
  }
}

/// class StatefulBuilder extends StatefulWidget
class StatefulBuilder$Mate extends StatefulBuilder with WidgetMate<StatefulBuilder$Mate> {
  /// StatefulBuilder StatefulBuilder({Key? key, required Widget Function(BuildContext, void Function(void Function())) builder})
  StatefulBuilder$Mate({
    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,

    /// optionalParameters: {required Widget Function(BuildContext, void Function(void Function())) builder} , hasDefaultValue:false, defaultValueCode:null
    required StatefulWidgetBuilder builder,
  }) : super(
          key: key,
          builder: builder,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => StatefulBuilder$Mate(
        key: p.getValue('key'),
        builder: p.getValue('builder'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'builder', init: builder);
  }
}

/// class ColoredBox extends SingleChildRenderObjectWidget
class ColoredBox$Mate extends ColoredBox with WidgetMate<ColoredBox$Mate> {
  /// ColoredBox ColoredBox({required Color color, Widget? child, Key? key})
  ColoredBox$Mate({
    /// optionalParameters: {required Color color} , hasDefaultValue:false, defaultValueCode:null
    required Color color,

    /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
    Widget? child,

    /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
    Key? key,
  }) : super(
          color: color,
          child: child,
          key: key,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => ColoredBox$Mate(
        color: p.getValue('color'),
        child: p.getValue('child'),
        key: p.getValue('key'),
      ),
    );
    mateParams.set(name: 'color', init: color);
    mateParams.set(name: 'child', init: child);
    mateParams.set(name: 'key', init: key);
  }
}
