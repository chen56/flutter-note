// /// Generated by mate_flutter, please don't edit!

import 'package:flutter/src/widgets/basic.dart';
import 'package:flutter/src/foundation/key.dart';
import 'dart:ui';
import 'package:flutter/src/widgets/framework.dart';
import 'package:note/mate.dart';
import 'dart:core';
import 'package:flutter/src/rendering/proxy_box.dart';
import 'package:flutter/src/rendering/custom_paint.dart';
import 'package:flutter/src/painting/border_radius.dart';
import 'package:flutter/src/painting/box_border.dart';
import 'package:vector_math/vector_math_64.dart';
import 'package:flutter/src/painting/alignment.dart';
import 'package:flutter/src/rendering/layer.dart';
import 'package:flutter/src/painting/box_fit.dart';
import 'package:flutter/src/painting/edge_insets.dart';
import 'package:flutter/src/rendering/shifted_box.dart';
import 'package:flutter/src/rendering/custom_layout.dart';
import 'package:flutter/src/rendering/box.dart';
import 'package:flutter/src/painting/basic_types.dart';
import 'package:flutter/src/rendering/stack.dart';
import 'package:flutter/src/rendering/flex.dart';
import 'package:flutter/src/rendering/wrap.dart';
import 'package:flutter/src/rendering/flow.dart';
import 'package:flutter/src/painting/inline_span.dart';
import 'package:flutter/src/painting/text_painter.dart';
import 'package:flutter/src/painting/strut_style.dart';
import 'package:flutter/src/rendering/selection.dart';
import 'package:flutter/src/animation/animation.dart';
import 'package:flutter/src/painting/decoration_image.dart';
import 'package:flutter/src/services/asset_bundle.dart';
import 'package:flutter/src/services/mouse_tracking.dart';
import 'package:flutter/src/services/mouse_cursor.dart';
import 'package:flutter/src/semantics/semantics.dart';
export 'package:flutter/animation.dart';
export 'package:flutter/foundation.dart'
    show ChangeNotifier, FlutterErrorDetails, Listenable, TargetPlatform, ValueNotifier;
export 'package:flutter/painting.dart';
export 'package:flutter/rendering.dart'
    show
        AlignmentGeometryTween,
        AlignmentTween,
        Axis,
        BoxConstraints,
        BoxConstraintsTransform,
        CrossAxisAlignment,
        CustomClipper,
        CustomPainter,
        CustomPainterSemantics,
        DecorationPosition,
        FlexFit,
        FlowDelegate,
        FlowPaintingContext,
        FractionalOffsetTween,
        HitTestBehavior,
        LayerLink,
        MainAxisAlignment,
        MainAxisSize,
        MouseCursor,
        MultiChildLayoutDelegate,
        PaintingContext,
        PointerCancelEvent,
        PointerCancelEventListener,
        PointerDownEvent,
        PointerDownEventListener,
        PointerEvent,
        PointerMoveEvent,
        PointerMoveEventListener,
        PointerUpEvent,
        PointerUpEventListener,
        RelativeRect,
        SemanticsBuilderCallback,
        ShaderCallback,
        ShapeBorderClipper,
        SingleChildLayoutDelegate,
        StackFit,
        SystemMouseCursors,
        TextOverflow,
        ValueChanged,
        ValueGetter,
        WrapAlignment,
        WrapCrossAlignment;
export 'package:flutter/services.dart' show AssetBundle;

/// class Directionality extends _UbiquitousInheritedWidget
class Directionality$Mate extends Directionality with WidgetMate<Directionality$Mate> {
  /// Directionality Directionality({Key? key, required TextDirection textDirection, required Widget child})
  Directionality$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required TextDirection textDirection}
    required TextDirection textDirection,

    /// param: {required Widget child}
    required Widget child,
  }) : super(
          key: key,
          textDirection: textDirection,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Directionality$Mate(
        key: p.getValue('key'),
        textDirection: p.getValue('textDirection'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'textDirection', init: textDirection);
    mateParams.set(name: 'child', init: child);
  }
}

/// class Opacity extends SingleChildRenderObjectWidget
class Opacity$Mate extends Opacity with WidgetMate<Opacity$Mate> {
  /// Opacity Opacity({Key? key, required double opacity, bool alwaysIncludeSemantics = false, Widget? child})
  Opacity$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required double opacity}
    required double opacity,

    /// param: {bool alwaysIncludeSemantics = false}
    required bool alwaysIncludeSemantics,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          opacity: opacity,
          alwaysIncludeSemantics: alwaysIncludeSemantics,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Opacity$Mate(
        key: p.getValue('key'),
        opacity: p.getValue('opacity'),
        alwaysIncludeSemantics: p.getValue('alwaysIncludeSemantics'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'opacity', init: opacity);
    mateParams.set(name: 'alwaysIncludeSemantics', init: alwaysIncludeSemantics);
    mateParams.set(name: 'child', init: child);
  }
}

/// class ShaderMask extends SingleChildRenderObjectWidget
class ShaderMask$Mate extends ShaderMask with WidgetMate<ShaderMask$Mate> {
  /// ShaderMask ShaderMask({Key? key, required Shader Function(Rect) shaderCallback, BlendMode blendMode = BlendMode.modulate, Widget? child})
  ShaderMask$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required Shader Function(Rect) shaderCallback}
    required ShaderCallback shaderCallback,

    /// param: {BlendMode blendMode = BlendMode.modulate}
    required BlendMode blendMode,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          shaderCallback: shaderCallback,
          blendMode: blendMode,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => ShaderMask$Mate(
        key: p.getValue('key'),
        shaderCallback: p.getValue('shaderCallback'),
        blendMode: p.getValue('blendMode'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'shaderCallback', init: shaderCallback);
    mateParams.set(name: 'blendMode', init: blendMode);
    mateParams.set(name: 'child', init: child);
  }
}

/// class BackdropFilter extends SingleChildRenderObjectWidget
class BackdropFilter$Mate extends BackdropFilter with WidgetMate<BackdropFilter$Mate> {
  /// BackdropFilter BackdropFilter({Key? key, required ImageFilter filter, Widget? child, BlendMode blendMode = BlendMode.srcOver})
  BackdropFilter$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required ImageFilter filter}
    required ImageFilter filter,

    /// param: {Widget? child}
    Widget? child,

    /// param: {BlendMode blendMode = BlendMode.srcOver}
    required BlendMode blendMode,
  }) : super(
          key: key,
          filter: filter,
          child: child,
          blendMode: blendMode,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => BackdropFilter$Mate(
        key: p.getValue('key'),
        filter: p.getValue('filter'),
        child: p.getValue('child'),
        blendMode: p.getValue('blendMode'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'filter', init: filter);
    mateParams.set(name: 'child', init: child);
    mateParams.set(name: 'blendMode', init: blendMode);
  }
}

/// class CustomPaint extends SingleChildRenderObjectWidget
class CustomPaint$Mate extends CustomPaint with WidgetMate<CustomPaint$Mate> {
  /// CustomPaint CustomPaint({Key? key, CustomPainter? painter, CustomPainter? foregroundPainter, Size size = Size.zero, bool isComplex = false, bool willChange = false, Widget? child})
  CustomPaint$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {CustomPainter? painter}
    CustomPainter? painter,

    /// param: {CustomPainter? foregroundPainter}
    CustomPainter? foregroundPainter,

    /// param: {Size size = Size.zero}
    required Size size,

    /// param: {bool isComplex = false}
    required bool isComplex,

    /// param: {bool willChange = false}
    required bool willChange,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          painter: painter,
          foregroundPainter: foregroundPainter,
          size: size,
          isComplex: isComplex,
          willChange: willChange,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => CustomPaint$Mate(
        key: p.getValue('key'),
        painter: p.getValue('painter'),
        foregroundPainter: p.getValue('foregroundPainter'),
        size: p.getValue('size'),
        isComplex: p.getValue('isComplex'),
        willChange: p.getValue('willChange'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'painter', init: painter);
    mateParams.set(name: 'foregroundPainter', init: foregroundPainter);
    mateParams.set(name: 'size', init: size);
    mateParams.set(name: 'isComplex', init: isComplex);
    mateParams.set(name: 'willChange', init: willChange);
    mateParams.set(name: 'child', init: child);
  }
}

/// class ClipRect extends SingleChildRenderObjectWidget
class ClipRect$Mate extends ClipRect with WidgetMate<ClipRect$Mate> {
  /// ClipRect ClipRect({Key? key, CustomClipper<Rect>? clipper, Clip clipBehavior = Clip.hardEdge, Widget? child})
  ClipRect$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {CustomClipper<Rect>? clipper}
    CustomClipper<Rect>? clipper,

    /// param: {Clip clipBehavior = Clip.hardEdge}
    required Clip clipBehavior,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          clipper: clipper,
          clipBehavior: clipBehavior,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => ClipRect$Mate(
        key: p.getValue('key'),
        clipper: p.getValue('clipper'),
        clipBehavior: p.getValue('clipBehavior'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'clipper', init: clipper);
    mateParams.set(name: 'clipBehavior', init: clipBehavior);
    mateParams.set(name: 'child', init: child);
  }
}

/// class ClipRRect extends SingleChildRenderObjectWidget
class ClipRRect$Mate extends ClipRRect with WidgetMate<ClipRRect$Mate> {
  /// ClipRRect ClipRRect({Key? key, BorderRadiusGeometry? borderRadius = BorderRadius.zero, CustomClipper<RRect>? clipper, Clip clipBehavior = Clip.antiAlias, Widget? child})
  ClipRRect$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {BorderRadiusGeometry? borderRadius = BorderRadius.zero}
    BorderRadiusGeometry? borderRadius,

    /// param: {CustomClipper<RRect>? clipper}
    CustomClipper<RRect>? clipper,

    /// param: {Clip clipBehavior = Clip.antiAlias}
    required Clip clipBehavior,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          borderRadius: borderRadius,
          clipper: clipper,
          clipBehavior: clipBehavior,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => ClipRRect$Mate(
        key: p.getValue('key'),
        borderRadius: p.getValue('borderRadius'),
        clipper: p.getValue('clipper'),
        clipBehavior: p.getValue('clipBehavior'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'borderRadius', init: borderRadius);
    mateParams.set(name: 'clipper', init: clipper);
    mateParams.set(name: 'clipBehavior', init: clipBehavior);
    mateParams.set(name: 'child', init: child);
  }
}

/// class ClipOval extends SingleChildRenderObjectWidget
class ClipOval$Mate extends ClipOval with WidgetMate<ClipOval$Mate> {
  /// ClipOval ClipOval({Key? key, CustomClipper<Rect>? clipper, Clip clipBehavior = Clip.antiAlias, Widget? child})
  ClipOval$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {CustomClipper<Rect>? clipper}
    CustomClipper<Rect>? clipper,

    /// param: {Clip clipBehavior = Clip.antiAlias}
    required Clip clipBehavior,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          clipper: clipper,
          clipBehavior: clipBehavior,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => ClipOval$Mate(
        key: p.getValue('key'),
        clipper: p.getValue('clipper'),
        clipBehavior: p.getValue('clipBehavior'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'clipper', init: clipper);
    mateParams.set(name: 'clipBehavior', init: clipBehavior);
    mateParams.set(name: 'child', init: child);
  }
}

/// class ClipPath extends SingleChildRenderObjectWidget
class ClipPath$Mate extends ClipPath with WidgetMate<ClipPath$Mate> {
  /// ClipPath ClipPath({Key? key, CustomClipper<Path>? clipper, Clip clipBehavior = Clip.antiAlias, Widget? child})
  ClipPath$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {CustomClipper<Path>? clipper}
    CustomClipper<Path>? clipper,

    /// param: {Clip clipBehavior = Clip.antiAlias}
    required Clip clipBehavior,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          clipper: clipper,
          clipBehavior: clipBehavior,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => ClipPath$Mate(
        key: p.getValue('key'),
        clipper: p.getValue('clipper'),
        clipBehavior: p.getValue('clipBehavior'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'clipper', init: clipper);
    mateParams.set(name: 'clipBehavior', init: clipBehavior);
    mateParams.set(name: 'child', init: child);
  }
}

/// class PhysicalModel extends SingleChildRenderObjectWidget
class PhysicalModel$Mate extends PhysicalModel with WidgetMate<PhysicalModel$Mate> {
  /// PhysicalModel PhysicalModel({Key? key, BoxShape shape = BoxShape.rectangle, Clip clipBehavior = Clip.none, BorderRadius? borderRadius, double elevation = 0.0, required Color color, Color shadowColor = const Color(0xFF000000), Widget? child})
  PhysicalModel$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {BoxShape shape = BoxShape.rectangle}
    required BoxShape shape,

    /// param: {Clip clipBehavior = Clip.none}
    required Clip clipBehavior,

    /// param: {BorderRadius? borderRadius}
    BorderRadius? borderRadius,

    /// param: {double elevation = 0.0}
    required double elevation,

    /// param: {required Color color}
    required Color color,

    /// param: {Color shadowColor = const Color(0xFF000000)}
    required Color shadowColor,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          shape: shape,
          clipBehavior: clipBehavior,
          borderRadius: borderRadius,
          elevation: elevation,
          color: color,
          shadowColor: shadowColor,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => PhysicalModel$Mate(
        key: p.getValue('key'),
        shape: p.getValue('shape'),
        clipBehavior: p.getValue('clipBehavior'),
        borderRadius: p.getValue('borderRadius'),
        elevation: p.getValue('elevation'),
        color: p.getValue('color'),
        shadowColor: p.getValue('shadowColor'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'shape', init: shape);
    mateParams.set(name: 'clipBehavior', init: clipBehavior);
    mateParams.set(name: 'borderRadius', init: borderRadius);
    mateParams.set(name: 'elevation', init: elevation);
    mateParams.set(name: 'color', init: color);
    mateParams.set(name: 'shadowColor', init: shadowColor);
    mateParams.set(name: 'child', init: child);
  }
}

/// class PhysicalShape extends SingleChildRenderObjectWidget
class PhysicalShape$Mate extends PhysicalShape with WidgetMate<PhysicalShape$Mate> {
  /// PhysicalShape PhysicalShape({Key? key, required CustomClipper<Path> clipper, Clip clipBehavior = Clip.none, double elevation = 0.0, required Color color, Color shadowColor = const Color(0xFF000000), Widget? child})
  PhysicalShape$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required CustomClipper<Path> clipper}
    required CustomClipper<Path> clipper,

    /// param: {Clip clipBehavior = Clip.none}
    required Clip clipBehavior,

    /// param: {double elevation = 0.0}
    required double elevation,

    /// param: {required Color color}
    required Color color,

    /// param: {Color shadowColor = const Color(0xFF000000)}
    required Color shadowColor,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          clipper: clipper,
          clipBehavior: clipBehavior,
          elevation: elevation,
          color: color,
          shadowColor: shadowColor,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => PhysicalShape$Mate(
        key: p.getValue('key'),
        clipper: p.getValue('clipper'),
        clipBehavior: p.getValue('clipBehavior'),
        elevation: p.getValue('elevation'),
        color: p.getValue('color'),
        shadowColor: p.getValue('shadowColor'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'clipper', init: clipper);
    mateParams.set(name: 'clipBehavior', init: clipBehavior);
    mateParams.set(name: 'elevation', init: elevation);
    mateParams.set(name: 'color', init: color);
    mateParams.set(name: 'shadowColor', init: shadowColor);
    mateParams.set(name: 'child', init: child);
  }
}

/// class Transform extends SingleChildRenderObjectWidget
class Transform$Mate extends Transform with WidgetMate<Transform$Mate> {
  /// Transform Transform({Key? key, required Matrix4 transform, Offset? origin, AlignmentGeometry? alignment, bool transformHitTests = true, FilterQuality? filterQuality, Widget? child})
  Transform$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required Matrix4 transform}
    required Matrix4 transform,

    /// param: {Offset? origin}
    Offset? origin,

    /// param: {AlignmentGeometry? alignment}
    AlignmentGeometry? alignment,

    /// param: {bool transformHitTests = true}
    required bool transformHitTests,

    /// param: {FilterQuality? filterQuality}
    FilterQuality? filterQuality,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          transform: transform,
          origin: origin,
          alignment: alignment,
          transformHitTests: transformHitTests,
          filterQuality: filterQuality,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Transform$Mate(
        key: p.getValue('key'),
        transform: p.getValue('transform'),
        origin: p.getValue('origin'),
        alignment: p.getValue('alignment'),
        transformHitTests: p.getValue('transformHitTests'),
        filterQuality: p.getValue('filterQuality'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'transform', init: transform);
    mateParams.set(name: 'origin', init: origin);
    mateParams.set(name: 'alignment', init: alignment);
    mateParams.set(name: 'transformHitTests', init: transformHitTests);
    mateParams.set(name: 'filterQuality', init: filterQuality);
    mateParams.set(name: 'child', init: child);
  }

  /// Transform Transform.rotate({Key? key, required double angle, Offset? origin, AlignmentGeometry? alignment = Alignment.center, bool transformHitTests = true, FilterQuality? filterQuality, Widget? child})
  Transform$Mate.rotate({
    /// param: {Key? key}
    Key? key,

    /// param: {required double angle}
    required double angle,

    /// param: {Offset? origin}
    Offset? origin,

    /// param: {AlignmentGeometry? alignment = Alignment.center}
    AlignmentGeometry? alignment,

    /// param: {bool transformHitTests = true}
    required bool transformHitTests,

    /// param: {FilterQuality? filterQuality}
    FilterQuality? filterQuality,

    /// param: {Widget? child}
    Widget? child,
  }) : super.rotate(
          key: key,
          angle: angle,
          origin: origin,
          alignment: alignment,
          transformHitTests: transformHitTests,
          filterQuality: filterQuality,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Transform$Mate.rotate(
        key: p.getValue('key'),
        angle: p.getValue('angle'),
        origin: p.getValue('origin'),
        alignment: p.getValue('alignment'),
        transformHitTests: p.getValue('transformHitTests'),
        filterQuality: p.getValue('filterQuality'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'angle', init: angle);
    mateParams.set(name: 'origin', init: origin);
    mateParams.set(name: 'alignment', init: alignment);
    mateParams.set(name: 'transformHitTests', init: transformHitTests);
    mateParams.set(name: 'filterQuality', init: filterQuality);
    mateParams.set(name: 'child', init: child);
  }

  /// Transform Transform.translate({Key? key, required Offset offset, bool transformHitTests = true, FilterQuality? filterQuality, Widget? child})
  Transform$Mate.translate({
    /// param: {Key? key}
    Key? key,

    /// param: {required Offset offset}
    required Offset offset,

    /// param: {bool transformHitTests = true}
    required bool transformHitTests,

    /// param: {FilterQuality? filterQuality}
    FilterQuality? filterQuality,

    /// param: {Widget? child}
    Widget? child,
  }) : super.translate(
          key: key,
          offset: offset,
          transformHitTests: transformHitTests,
          filterQuality: filterQuality,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Transform$Mate.translate(
        key: p.getValue('key'),
        offset: p.getValue('offset'),
        transformHitTests: p.getValue('transformHitTests'),
        filterQuality: p.getValue('filterQuality'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'offset', init: offset);
    mateParams.set(name: 'transformHitTests', init: transformHitTests);
    mateParams.set(name: 'filterQuality', init: filterQuality);
    mateParams.set(name: 'child', init: child);
  }

  /// Transform Transform.scale({Key? key, double? scale, double? scaleX, double? scaleY, Offset? origin, AlignmentGeometry? alignment = Alignment.center, bool transformHitTests = true, FilterQuality? filterQuality, Widget? child})
  Transform$Mate.scale({
    /// param: {Key? key}
    Key? key,

    /// param: {double? scale}
    double? scale,

    /// param: {double? scaleX}
    double? scaleX,

    /// param: {double? scaleY}
    double? scaleY,

    /// param: {Offset? origin}
    Offset? origin,

    /// param: {AlignmentGeometry? alignment = Alignment.center}
    AlignmentGeometry? alignment,

    /// param: {bool transformHitTests = true}
    required bool transformHitTests,

    /// param: {FilterQuality? filterQuality}
    FilterQuality? filterQuality,

    /// param: {Widget? child}
    Widget? child,
  }) : super.scale(
          key: key,
          scale: scale,
          scaleX: scaleX,
          scaleY: scaleY,
          origin: origin,
          alignment: alignment,
          transformHitTests: transformHitTests,
          filterQuality: filterQuality,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Transform$Mate.scale(
        key: p.getValue('key'),
        scale: p.getValue('scale'),
        scaleX: p.getValue('scaleX'),
        scaleY: p.getValue('scaleY'),
        origin: p.getValue('origin'),
        alignment: p.getValue('alignment'),
        transformHitTests: p.getValue('transformHitTests'),
        filterQuality: p.getValue('filterQuality'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'scale', init: scale);
    mateParams.set(name: 'scaleX', init: scaleX);
    mateParams.set(name: 'scaleY', init: scaleY);
    mateParams.set(name: 'origin', init: origin);
    mateParams.set(name: 'alignment', init: alignment);
    mateParams.set(name: 'transformHitTests', init: transformHitTests);
    mateParams.set(name: 'filterQuality', init: filterQuality);
    mateParams.set(name: 'child', init: child);
  }

  /// Transform Transform.flip({Key? key, bool flipX = false, bool flipY = false, Offset? origin, bool transformHitTests = true, FilterQuality? filterQuality, Widget? child})
  Transform$Mate.flip({
    /// param: {Key? key}
    Key? key,

    /// param: {bool flipX = false}
    required bool flipX,

    /// param: {bool flipY = false}
    required bool flipY,

    /// param: {Offset? origin}
    Offset? origin,

    /// param: {bool transformHitTests = true}
    required bool transformHitTests,

    /// param: {FilterQuality? filterQuality}
    FilterQuality? filterQuality,

    /// param: {Widget? child}
    Widget? child,
  }) : super.flip(
          key: key,
          flipX: flipX,
          flipY: flipY,
          origin: origin,
          transformHitTests: transformHitTests,
          filterQuality: filterQuality,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Transform$Mate.flip(
        key: p.getValue('key'),
        flipX: p.getValue('flipX'),
        flipY: p.getValue('flipY'),
        origin: p.getValue('origin'),
        transformHitTests: p.getValue('transformHitTests'),
        filterQuality: p.getValue('filterQuality'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'flipX', init: flipX);
    mateParams.set(name: 'flipY', init: flipY);
    mateParams.set(name: 'origin', init: origin);
    mateParams.set(name: 'transformHitTests', init: transformHitTests);
    mateParams.set(name: 'filterQuality', init: filterQuality);
    mateParams.set(name: 'child', init: child);
  }
}

/// class CompositedTransformTarget extends SingleChildRenderObjectWidget
class CompositedTransformTarget$Mate extends CompositedTransformTarget with WidgetMate<CompositedTransformTarget$Mate> {
  /// CompositedTransformTarget CompositedTransformTarget({Key? key, required LayerLink link, Widget? child})
  CompositedTransformTarget$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required LayerLink link}
    required LayerLink link,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          link: link,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => CompositedTransformTarget$Mate(
        key: p.getValue('key'),
        link: p.getValue('link'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'link', init: link);
    mateParams.set(name: 'child', init: child);
  }
}

/// class CompositedTransformFollower extends SingleChildRenderObjectWidget
class CompositedTransformFollower$Mate extends CompositedTransformFollower
    with WidgetMate<CompositedTransformFollower$Mate> {
  /// CompositedTransformFollower CompositedTransformFollower({Key? key, required LayerLink link, bool showWhenUnlinked = true, Offset offset = Offset.zero, Alignment targetAnchor = Alignment.topLeft, Alignment followerAnchor = Alignment.topLeft, Widget? child})
  CompositedTransformFollower$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required LayerLink link}
    required LayerLink link,

    /// param: {bool showWhenUnlinked = true}
    required bool showWhenUnlinked,

    /// param: {Offset offset = Offset.zero}
    required Offset offset,

    /// param: {Alignment targetAnchor = Alignment.topLeft}
    required Alignment targetAnchor,

    /// param: {Alignment followerAnchor = Alignment.topLeft}
    required Alignment followerAnchor,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          link: link,
          showWhenUnlinked: showWhenUnlinked,
          offset: offset,
          targetAnchor: targetAnchor,
          followerAnchor: followerAnchor,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => CompositedTransformFollower$Mate(
        key: p.getValue('key'),
        link: p.getValue('link'),
        showWhenUnlinked: p.getValue('showWhenUnlinked'),
        offset: p.getValue('offset'),
        targetAnchor: p.getValue('targetAnchor'),
        followerAnchor: p.getValue('followerAnchor'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'link', init: link);
    mateParams.set(name: 'showWhenUnlinked', init: showWhenUnlinked);
    mateParams.set(name: 'offset', init: offset);
    mateParams.set(name: 'targetAnchor', init: targetAnchor);
    mateParams.set(name: 'followerAnchor', init: followerAnchor);
    mateParams.set(name: 'child', init: child);
  }
}

/// class FittedBox extends SingleChildRenderObjectWidget
class FittedBox$Mate extends FittedBox with WidgetMate<FittedBox$Mate> {
  /// FittedBox FittedBox({Key? key, BoxFit fit = BoxFit.contain, AlignmentGeometry alignment = Alignment.center, Clip clipBehavior = Clip.none, Widget? child})
  FittedBox$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {BoxFit fit = BoxFit.contain}
    required BoxFit fit,

    /// param: {AlignmentGeometry alignment = Alignment.center}
    required AlignmentGeometry alignment,

    /// param: {Clip clipBehavior = Clip.none}
    required Clip clipBehavior,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          fit: fit,
          alignment: alignment,
          clipBehavior: clipBehavior,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => FittedBox$Mate(
        key: p.getValue('key'),
        fit: p.getValue('fit'),
        alignment: p.getValue('alignment'),
        clipBehavior: p.getValue('clipBehavior'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'fit', init: fit);
    mateParams.set(name: 'alignment', init: alignment);
    mateParams.set(name: 'clipBehavior', init: clipBehavior);
    mateParams.set(name: 'child', init: child);
  }
}

/// class FractionalTranslation extends SingleChildRenderObjectWidget
class FractionalTranslation$Mate extends FractionalTranslation with WidgetMate<FractionalTranslation$Mate> {
  /// FractionalTranslation FractionalTranslation({Key? key, required Offset translation, bool transformHitTests = true, Widget? child})
  FractionalTranslation$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required Offset translation}
    required Offset translation,

    /// param: {bool transformHitTests = true}
    required bool transformHitTests,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          translation: translation,
          transformHitTests: transformHitTests,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => FractionalTranslation$Mate(
        key: p.getValue('key'),
        translation: p.getValue('translation'),
        transformHitTests: p.getValue('transformHitTests'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'translation', init: translation);
    mateParams.set(name: 'transformHitTests', init: transformHitTests);
    mateParams.set(name: 'child', init: child);
  }
}

/// class RotatedBox extends SingleChildRenderObjectWidget
class RotatedBox$Mate extends RotatedBox with WidgetMate<RotatedBox$Mate> {
  /// RotatedBox RotatedBox({Key? key, required int quarterTurns, Widget? child})
  RotatedBox$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required int quarterTurns}
    required int quarterTurns,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          quarterTurns: quarterTurns,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => RotatedBox$Mate(
        key: p.getValue('key'),
        quarterTurns: p.getValue('quarterTurns'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'quarterTurns', init: quarterTurns);
    mateParams.set(name: 'child', init: child);
  }
}

/// class Padding extends SingleChildRenderObjectWidget
class Padding$Mate extends Padding with WidgetMate<Padding$Mate> {
  /// Padding Padding({Key? key, required EdgeInsetsGeometry padding, Widget? child})
  Padding$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required EdgeInsetsGeometry padding}
    required EdgeInsetsGeometry padding,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          padding: padding,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Padding$Mate(
        key: p.getValue('key'),
        padding: p.getValue('padding'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'padding', init: padding);
    mateParams.set(name: 'child', init: child);
  }
}

/// class Align extends SingleChildRenderObjectWidget
class Align$Mate extends Align with WidgetMate<Align$Mate> {
  /// Align Align({Key? key, AlignmentGeometry alignment = Alignment.center, double? widthFactor, double? heightFactor, Widget? child})
  Align$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {AlignmentGeometry alignment = Alignment.center}
    required AlignmentGeometry alignment,

    /// param: {double? widthFactor}
    double? widthFactor,

    /// param: {double? heightFactor}
    double? heightFactor,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          alignment: alignment,
          widthFactor: widthFactor,
          heightFactor: heightFactor,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Align$Mate(
        key: p.getValue('key'),
        alignment: p.getValue('alignment'),
        widthFactor: p.getValue('widthFactor'),
        heightFactor: p.getValue('heightFactor'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'alignment', init: alignment);
    mateParams.set(name: 'widthFactor', init: widthFactor);
    mateParams.set(name: 'heightFactor', init: heightFactor);
    mateParams.set(name: 'child', init: child);
  }
}

/// class Center extends Align
class Center$Mate extends Center with WidgetMate<Center$Mate> {
  /// Center Center({Key? key, double? widthFactor, double? heightFactor, Widget? child})
  Center$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {double? widthFactor}
    double? widthFactor,

    /// param: {double? heightFactor}
    double? heightFactor,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          widthFactor: widthFactor,
          heightFactor: heightFactor,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Center$Mate(
        key: p.getValue('key'),
        widthFactor: p.getValue('widthFactor'),
        heightFactor: p.getValue('heightFactor'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'widthFactor', init: widthFactor);
    mateParams.set(name: 'heightFactor', init: heightFactor);
    mateParams.set(name: 'child', init: child);
  }
}

/// class CustomSingleChildLayout extends SingleChildRenderObjectWidget
class CustomSingleChildLayout$Mate extends CustomSingleChildLayout with WidgetMate<CustomSingleChildLayout$Mate> {
  /// CustomSingleChildLayout CustomSingleChildLayout({Key? key, required SingleChildLayoutDelegate delegate, Widget? child})
  CustomSingleChildLayout$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required SingleChildLayoutDelegate delegate}
    required SingleChildLayoutDelegate delegate,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          delegate: delegate,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => CustomSingleChildLayout$Mate(
        key: p.getValue('key'),
        delegate: p.getValue('delegate'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'delegate', init: delegate);
    mateParams.set(name: 'child', init: child);
  }
}

/// class LayoutId extends ParentDataWidget<MultiChildLayoutParentData>
class LayoutId$Mate extends LayoutId with WidgetMate<LayoutId$Mate> {
  /// LayoutId LayoutId({Key? key, required Object id, required Widget child})
  LayoutId$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required Object id}
    required Object id,

    /// param: {required Widget child}
    required Widget child,
  }) : super(
          key: key,
          id: id,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => LayoutId$Mate(
        key: p.getValue('key'),
        id: p.getValue('id'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'id', init: id);
    mateParams.set(name: 'child', init: child);
  }
}

/// class CustomMultiChildLayout extends MultiChildRenderObjectWidget
class CustomMultiChildLayout$Mate extends CustomMultiChildLayout with WidgetMate<CustomMultiChildLayout$Mate> {
  /// CustomMultiChildLayout CustomMultiChildLayout({Key? key, required MultiChildLayoutDelegate delegate, List<Widget> children = const <Widget>[]})
  CustomMultiChildLayout$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required MultiChildLayoutDelegate delegate}
    required MultiChildLayoutDelegate delegate,

    /// param: {List<Widget> children = const <Widget>[]}
    required List<Widget> children,
  }) : super(
          key: key,
          delegate: delegate,
          children: children,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => CustomMultiChildLayout$Mate(
        key: p.getValue('key'),
        delegate: p.getValue('delegate'),
        children: p.getValue('children'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'delegate', init: delegate);
    mateParams.set(name: 'children', init: children);
  }
}

/// class SizedBox extends SingleChildRenderObjectWidget
class SizedBox$Mate extends SizedBox with WidgetMate<SizedBox$Mate> {
  /// SizedBox SizedBox({Key? key, double? width, double? height, Widget? child})
  SizedBox$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {double? width}
    double? width,

    /// param: {double? height}
    double? height,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          width: width,
          height: height,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => SizedBox$Mate(
        key: p.getValue('key'),
        width: p.getValue('width'),
        height: p.getValue('height'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'width', init: width);
    mateParams.set(name: 'height', init: height);
    mateParams.set(name: 'child', init: child);
  }

  /// SizedBox SizedBox.expand({Key? key, Widget? child})
  SizedBox$Mate.expand({
    /// param: {Key? key}
    Key? key,

    /// param: {Widget? child}
    Widget? child,
  }) : super.expand(
          key: key,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => SizedBox$Mate.expand(
        key: p.getValue('key'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'child', init: child);
  }

  /// SizedBox SizedBox.shrink({Key? key, Widget? child})
  SizedBox$Mate.shrink({
    /// param: {Key? key}
    Key? key,

    /// param: {Widget? child}
    Widget? child,
  }) : super.shrink(
          key: key,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => SizedBox$Mate.shrink(
        key: p.getValue('key'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'child', init: child);
  }

  /// SizedBox SizedBox.fromSize({Key? key, Widget? child, Size? size})
  SizedBox$Mate.fromSize({
    /// param: {Key? key}
    Key? key,

    /// param: {Widget? child}
    Widget? child,

    /// param: {Size? size}
    Size? size,
  }) : super.fromSize(
          key: key,
          child: child,
          size: size,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => SizedBox$Mate.fromSize(
        key: p.getValue('key'),
        child: p.getValue('child'),
        size: p.getValue('size'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'child', init: child);
    mateParams.set(name: 'size', init: size);
  }

  /// SizedBox SizedBox.square({Key? key, Widget? child, double? dimension})
  SizedBox$Mate.square({
    /// param: {Key? key}
    Key? key,

    /// param: {Widget? child}
    Widget? child,

    /// param: {double? dimension}
    double? dimension,
  }) : super.square(
          key: key,
          child: child,
          dimension: dimension,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => SizedBox$Mate.square(
        key: p.getValue('key'),
        child: p.getValue('child'),
        dimension: p.getValue('dimension'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'child', init: child);
    mateParams.set(name: 'dimension', init: dimension);
  }
}

/// class ConstrainedBox extends SingleChildRenderObjectWidget
class ConstrainedBox$Mate extends ConstrainedBox with WidgetMate<ConstrainedBox$Mate> {
  /// ConstrainedBox ConstrainedBox({Key? key, required BoxConstraints constraints, Widget? child})
  ConstrainedBox$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required BoxConstraints constraints}
    required BoxConstraints constraints,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          constraints: constraints,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => ConstrainedBox$Mate(
        key: p.getValue('key'),
        constraints: p.getValue('constraints'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'constraints', init: constraints);
    mateParams.set(name: 'child', init: child);
  }
}

/// class ConstraintsTransformBox extends SingleChildRenderObjectWidget
class ConstraintsTransformBox$Mate extends ConstraintsTransformBox with WidgetMate<ConstraintsTransformBox$Mate> {
  /// ConstraintsTransformBox ConstraintsTransformBox({Key? key, Widget? child, TextDirection? textDirection, AlignmentGeometry alignment = Alignment.center, required BoxConstraints Function(BoxConstraints) constraintsTransform, Clip clipBehavior = Clip.none, String debugTransformType = ''})
  ConstraintsTransformBox$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {Widget? child}
    Widget? child,

    /// param: {TextDirection? textDirection}
    TextDirection? textDirection,

    /// param: {AlignmentGeometry alignment = Alignment.center}
    required AlignmentGeometry alignment,

    /// param: {required BoxConstraints Function(BoxConstraints) constraintsTransform}
    required BoxConstraintsTransform constraintsTransform,

    /// param: {Clip clipBehavior = Clip.none}
    required Clip clipBehavior,

    /// param: {String debugTransformType = ''}
    required String debugTransformType,
  }) : super(
          key: key,
          child: child,
          textDirection: textDirection,
          alignment: alignment,
          constraintsTransform: constraintsTransform,
          clipBehavior: clipBehavior,
          debugTransformType: debugTransformType,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => ConstraintsTransformBox$Mate(
        key: p.getValue('key'),
        child: p.getValue('child'),
        textDirection: p.getValue('textDirection'),
        alignment: p.getValue('alignment'),
        constraintsTransform: p.getValue('constraintsTransform'),
        clipBehavior: p.getValue('clipBehavior'),
        debugTransformType: p.getValue('debugTransformType'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'child', init: child);
    mateParams.set(name: 'textDirection', init: textDirection);
    mateParams.set(name: 'alignment', init: alignment);
    mateParams.set(name: 'constraintsTransform', init: constraintsTransform);
    mateParams.set(name: 'clipBehavior', init: clipBehavior);
    mateParams.set(name: 'debugTransformType', init: debugTransformType);
  }
}

/// class UnconstrainedBox extends StatelessWidget
class UnconstrainedBox$Mate extends UnconstrainedBox with WidgetMate<UnconstrainedBox$Mate> {
  /// UnconstrainedBox UnconstrainedBox({Key? key, Widget? child, TextDirection? textDirection, AlignmentGeometry alignment = Alignment.center, Axis? constrainedAxis, Clip clipBehavior = Clip.none})
  UnconstrainedBox$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {Widget? child}
    Widget? child,

    /// param: {TextDirection? textDirection}
    TextDirection? textDirection,

    /// param: {AlignmentGeometry alignment = Alignment.center}
    required AlignmentGeometry alignment,

    /// param: {Axis? constrainedAxis}
    Axis? constrainedAxis,

    /// param: {Clip clipBehavior = Clip.none}
    required Clip clipBehavior,
  }) : super(
          key: key,
          child: child,
          textDirection: textDirection,
          alignment: alignment,
          constrainedAxis: constrainedAxis,
          clipBehavior: clipBehavior,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => UnconstrainedBox$Mate(
        key: p.getValue('key'),
        child: p.getValue('child'),
        textDirection: p.getValue('textDirection'),
        alignment: p.getValue('alignment'),
        constrainedAxis: p.getValue('constrainedAxis'),
        clipBehavior: p.getValue('clipBehavior'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'child', init: child);
    mateParams.set(name: 'textDirection', init: textDirection);
    mateParams.set(name: 'alignment', init: alignment);
    mateParams.set(name: 'constrainedAxis', init: constrainedAxis);
    mateParams.set(name: 'clipBehavior', init: clipBehavior);
  }
}

/// class FractionallySizedBox extends SingleChildRenderObjectWidget
class FractionallySizedBox$Mate extends FractionallySizedBox with WidgetMate<FractionallySizedBox$Mate> {
  /// FractionallySizedBox FractionallySizedBox({Key? key, AlignmentGeometry alignment = Alignment.center, double? widthFactor, double? heightFactor, Widget? child})
  FractionallySizedBox$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {AlignmentGeometry alignment = Alignment.center}
    required AlignmentGeometry alignment,

    /// param: {double? widthFactor}
    double? widthFactor,

    /// param: {double? heightFactor}
    double? heightFactor,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          alignment: alignment,
          widthFactor: widthFactor,
          heightFactor: heightFactor,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => FractionallySizedBox$Mate(
        key: p.getValue('key'),
        alignment: p.getValue('alignment'),
        widthFactor: p.getValue('widthFactor'),
        heightFactor: p.getValue('heightFactor'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'alignment', init: alignment);
    mateParams.set(name: 'widthFactor', init: widthFactor);
    mateParams.set(name: 'heightFactor', init: heightFactor);
    mateParams.set(name: 'child', init: child);
  }
}

/// class LimitedBox extends SingleChildRenderObjectWidget
class LimitedBox$Mate extends LimitedBox with WidgetMate<LimitedBox$Mate> {
  /// LimitedBox LimitedBox({Key? key, double maxWidth = double.infinity, double maxHeight = double.infinity, Widget? child})
  LimitedBox$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {double maxWidth = double.infinity}
    required double maxWidth,

    /// param: {double maxHeight = double.infinity}
    required double maxHeight,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          maxWidth: maxWidth,
          maxHeight: maxHeight,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => LimitedBox$Mate(
        key: p.getValue('key'),
        maxWidth: p.getValue('maxWidth'),
        maxHeight: p.getValue('maxHeight'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'maxWidth', init: maxWidth);
    mateParams.set(name: 'maxHeight', init: maxHeight);
    mateParams.set(name: 'child', init: child);
  }
}

/// class OverflowBox extends SingleChildRenderObjectWidget
class OverflowBox$Mate extends OverflowBox with WidgetMate<OverflowBox$Mate> {
  /// OverflowBox OverflowBox({Key? key, AlignmentGeometry alignment = Alignment.center, double? minWidth, double? maxWidth, double? minHeight, double? maxHeight, Widget? child})
  OverflowBox$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {AlignmentGeometry alignment = Alignment.center}
    required AlignmentGeometry alignment,

    /// param: {double? minWidth}
    double? minWidth,

    /// param: {double? maxWidth}
    double? maxWidth,

    /// param: {double? minHeight}
    double? minHeight,

    /// param: {double? maxHeight}
    double? maxHeight,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          alignment: alignment,
          minWidth: minWidth,
          maxWidth: maxWidth,
          minHeight: minHeight,
          maxHeight: maxHeight,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => OverflowBox$Mate(
        key: p.getValue('key'),
        alignment: p.getValue('alignment'),
        minWidth: p.getValue('minWidth'),
        maxWidth: p.getValue('maxWidth'),
        minHeight: p.getValue('minHeight'),
        maxHeight: p.getValue('maxHeight'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'alignment', init: alignment);
    mateParams.set(name: 'minWidth', init: minWidth);
    mateParams.set(name: 'maxWidth', init: maxWidth);
    mateParams.set(name: 'minHeight', init: minHeight);
    mateParams.set(name: 'maxHeight', init: maxHeight);
    mateParams.set(name: 'child', init: child);
  }
}

/// class SizedOverflowBox extends SingleChildRenderObjectWidget
class SizedOverflowBox$Mate extends SizedOverflowBox with WidgetMate<SizedOverflowBox$Mate> {
  /// SizedOverflowBox SizedOverflowBox({Key? key, required Size size, AlignmentGeometry alignment = Alignment.center, Widget? child})
  SizedOverflowBox$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required Size size}
    required Size size,

    /// param: {AlignmentGeometry alignment = Alignment.center}
    required AlignmentGeometry alignment,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          size: size,
          alignment: alignment,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => SizedOverflowBox$Mate(
        key: p.getValue('key'),
        size: p.getValue('size'),
        alignment: p.getValue('alignment'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'size', init: size);
    mateParams.set(name: 'alignment', init: alignment);
    mateParams.set(name: 'child', init: child);
  }
}

/// class Offstage extends SingleChildRenderObjectWidget
class Offstage$Mate extends Offstage with WidgetMate<Offstage$Mate> {
  /// Offstage Offstage({Key? key, bool offstage = true, Widget? child})
  Offstage$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {bool offstage = true}
    required bool offstage,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          offstage: offstage,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Offstage$Mate(
        key: p.getValue('key'),
        offstage: p.getValue('offstage'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'offstage', init: offstage);
    mateParams.set(name: 'child', init: child);
  }
}

/// class AspectRatio extends SingleChildRenderObjectWidget
class AspectRatio$Mate extends AspectRatio with WidgetMate<AspectRatio$Mate> {
  /// AspectRatio AspectRatio({Key? key, required double aspectRatio, Widget? child})
  AspectRatio$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required double aspectRatio}
    required double aspectRatio,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          aspectRatio: aspectRatio,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => AspectRatio$Mate(
        key: p.getValue('key'),
        aspectRatio: p.getValue('aspectRatio'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'aspectRatio', init: aspectRatio);
    mateParams.set(name: 'child', init: child);
  }
}

/// class IntrinsicWidth extends SingleChildRenderObjectWidget
class IntrinsicWidth$Mate extends IntrinsicWidth with WidgetMate<IntrinsicWidth$Mate> {
  /// IntrinsicWidth IntrinsicWidth({Key? key, double? stepWidth, double? stepHeight, Widget? child})
  IntrinsicWidth$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {double? stepWidth}
    double? stepWidth,

    /// param: {double? stepHeight}
    double? stepHeight,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          stepWidth: stepWidth,
          stepHeight: stepHeight,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => IntrinsicWidth$Mate(
        key: p.getValue('key'),
        stepWidth: p.getValue('stepWidth'),
        stepHeight: p.getValue('stepHeight'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'stepWidth', init: stepWidth);
    mateParams.set(name: 'stepHeight', init: stepHeight);
    mateParams.set(name: 'child', init: child);
  }
}

/// class IntrinsicHeight extends SingleChildRenderObjectWidget
class IntrinsicHeight$Mate extends IntrinsicHeight with WidgetMate<IntrinsicHeight$Mate> {
  /// IntrinsicHeight IntrinsicHeight({Key? key, Widget? child})
  IntrinsicHeight$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => IntrinsicHeight$Mate(
        key: p.getValue('key'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'child', init: child);
  }
}

/// class Baseline extends SingleChildRenderObjectWidget
class Baseline$Mate extends Baseline with WidgetMate<Baseline$Mate> {
  /// Baseline Baseline({Key? key, required double baseline, required TextBaseline baselineType, Widget? child})
  Baseline$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required double baseline}
    required double baseline,

    /// param: {required TextBaseline baselineType}
    required TextBaseline baselineType,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          baseline: baseline,
          baselineType: baselineType,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Baseline$Mate(
        key: p.getValue('key'),
        baseline: p.getValue('baseline'),
        baselineType: p.getValue('baselineType'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'baseline', init: baseline);
    mateParams.set(name: 'baselineType', init: baselineType);
    mateParams.set(name: 'child', init: child);
  }
}

/// class SliverToBoxAdapter extends SingleChildRenderObjectWidget
class SliverToBoxAdapter$Mate extends SliverToBoxAdapter with WidgetMate<SliverToBoxAdapter$Mate> {
  /// SliverToBoxAdapter SliverToBoxAdapter({Key? key, Widget? child})
  SliverToBoxAdapter$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => SliverToBoxAdapter$Mate(
        key: p.getValue('key'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'child', init: child);
  }
}

/// class SliverPadding extends SingleChildRenderObjectWidget
class SliverPadding$Mate extends SliverPadding with WidgetMate<SliverPadding$Mate> {
  /// SliverPadding SliverPadding({Key? key, required EdgeInsetsGeometry padding, Widget? sliver})
  SliverPadding$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required EdgeInsetsGeometry padding}
    required EdgeInsetsGeometry padding,

    /// param: {Widget? sliver}
    Widget? sliver,
  }) : super(
          key: key,
          padding: padding,
          sliver: sliver,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => SliverPadding$Mate(
        key: p.getValue('key'),
        padding: p.getValue('padding'),
        sliver: p.getValue('sliver'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'padding', init: padding);
    mateParams.set(name: 'sliver', init: sliver);
  }
}

/// class ListBody extends MultiChildRenderObjectWidget
class ListBody$Mate extends ListBody with WidgetMate<ListBody$Mate> {
  /// ListBody ListBody({Key? key, Axis mainAxis = Axis.vertical, bool reverse = false, List<Widget> children = const <Widget>[]})
  ListBody$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {Axis mainAxis = Axis.vertical}
    required Axis mainAxis,

    /// param: {bool reverse = false}
    required bool reverse,

    /// param: {List<Widget> children = const <Widget>[]}
    required List<Widget> children,
  }) : super(
          key: key,
          mainAxis: mainAxis,
          reverse: reverse,
          children: children,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => ListBody$Mate(
        key: p.getValue('key'),
        mainAxis: p.getValue('mainAxis'),
        reverse: p.getValue('reverse'),
        children: p.getValue('children'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'mainAxis', init: mainAxis);
    mateParams.set(name: 'reverse', init: reverse);
    mateParams.set(name: 'children', init: children);
  }
}

/// class Stack extends MultiChildRenderObjectWidget
class Stack$Mate extends Stack with WidgetMate<Stack$Mate> {
  /// Stack Stack({Key? key, AlignmentGeometry alignment = AlignmentDirectional.topStart, TextDirection? textDirection, StackFit fit = StackFit.loose, Clip clipBehavior = Clip.hardEdge, List<Widget> children = const <Widget>[]})
  Stack$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {AlignmentGeometry alignment = AlignmentDirectional.topStart}
    required AlignmentGeometry alignment,

    /// param: {TextDirection? textDirection}
    TextDirection? textDirection,

    /// param: {StackFit fit = StackFit.loose}
    required StackFit fit,

    /// param: {Clip clipBehavior = Clip.hardEdge}
    required Clip clipBehavior,

    /// param: {List<Widget> children = const <Widget>[]}
    required List<Widget> children,
  }) : super(
          key: key,
          alignment: alignment,
          textDirection: textDirection,
          fit: fit,
          clipBehavior: clipBehavior,
          children: children,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Stack$Mate(
        key: p.getValue('key'),
        alignment: p.getValue('alignment'),
        textDirection: p.getValue('textDirection'),
        fit: p.getValue('fit'),
        clipBehavior: p.getValue('clipBehavior'),
        children: p.getValue('children'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'alignment', init: alignment);
    mateParams.set(name: 'textDirection', init: textDirection);
    mateParams.set(name: 'fit', init: fit);
    mateParams.set(name: 'clipBehavior', init: clipBehavior);
    mateParams.set(name: 'children', init: children);
  }
}

/// class IndexedStack extends Stack
class IndexedStack$Mate extends IndexedStack with WidgetMate<IndexedStack$Mate> {
  /// IndexedStack IndexedStack({Key? key, AlignmentGeometry alignment = AlignmentDirectional.topStart, TextDirection? textDirection, Clip clipBehavior = Clip.hardEdge, StackFit sizing = StackFit.loose, int? index = 0, List<Widget> children = const <Widget>[]})
  IndexedStack$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {AlignmentGeometry alignment = AlignmentDirectional.topStart}
    required AlignmentGeometry alignment,

    /// param: {TextDirection? textDirection}
    TextDirection? textDirection,

    /// param: {Clip clipBehavior = Clip.hardEdge}
    required Clip clipBehavior,

    /// param: {StackFit sizing = StackFit.loose}
    required StackFit sizing,

    /// param: {int? index = 0}
    int? index,

    /// param: {List<Widget> children = const <Widget>[]}
    required List<Widget> children,
  }) : super(
          key: key,
          alignment: alignment,
          textDirection: textDirection,
          clipBehavior: clipBehavior,
          sizing: sizing,
          index: index,
          children: children,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => IndexedStack$Mate(
        key: p.getValue('key'),
        alignment: p.getValue('alignment'),
        textDirection: p.getValue('textDirection'),
        clipBehavior: p.getValue('clipBehavior'),
        sizing: p.getValue('sizing'),
        index: p.getValue('index'),
        children: p.getValue('children'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'alignment', init: alignment);
    mateParams.set(name: 'textDirection', init: textDirection);
    mateParams.set(name: 'clipBehavior', init: clipBehavior);
    mateParams.set(name: 'sizing', init: sizing);
    mateParams.set(name: 'index', init: index);
    mateParams.set(name: 'children', init: children);
  }
}

/// class Positioned extends ParentDataWidget<StackParentData>
class Positioned$Mate extends Positioned with WidgetMate<Positioned$Mate> {
  /// Positioned Positioned({Key? key, double? left, double? top, double? right, double? bottom, double? width, double? height, required Widget child})
  Positioned$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {double? left}
    double? left,

    /// param: {double? top}
    double? top,

    /// param: {double? right}
    double? right,

    /// param: {double? bottom}
    double? bottom,

    /// param: {double? width}
    double? width,

    /// param: {double? height}
    double? height,

    /// param: {required Widget child}
    required Widget child,
  }) : super(
          key: key,
          left: left,
          top: top,
          right: right,
          bottom: bottom,
          width: width,
          height: height,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Positioned$Mate(
        key: p.getValue('key'),
        left: p.getValue('left'),
        top: p.getValue('top'),
        right: p.getValue('right'),
        bottom: p.getValue('bottom'),
        width: p.getValue('width'),
        height: p.getValue('height'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'left', init: left);
    mateParams.set(name: 'top', init: top);
    mateParams.set(name: 'right', init: right);
    mateParams.set(name: 'bottom', init: bottom);
    mateParams.set(name: 'width', init: width);
    mateParams.set(name: 'height', init: height);
    mateParams.set(name: 'child', init: child);
  }

  /// Positioned Positioned.fromRect({Key? key, required Rect rect, required Widget child})
  Positioned$Mate.fromRect({
    /// param: {Key? key}
    Key? key,

    /// param: {required Rect rect}
    required Rect rect,

    /// param: {required Widget child}
    required Widget child,
  }) : super.fromRect(
          key: key,
          rect: rect,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Positioned$Mate.fromRect(
        key: p.getValue('key'),
        rect: p.getValue('rect'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'rect', init: rect);
    mateParams.set(name: 'child', init: child);
  }

  /// Positioned Positioned.fromRelativeRect({Key? key, required RelativeRect rect, required Widget child})
  Positioned$Mate.fromRelativeRect({
    /// param: {Key? key}
    Key? key,

    /// param: {required RelativeRect rect}
    required RelativeRect rect,

    /// param: {required Widget child}
    required Widget child,
  }) : super.fromRelativeRect(
          key: key,
          rect: rect,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Positioned$Mate.fromRelativeRect(
        key: p.getValue('key'),
        rect: p.getValue('rect'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'rect', init: rect);
    mateParams.set(name: 'child', init: child);
  }

  /// Positioned Positioned.fill({Key? key, double? left = 0.0, double? top = 0.0, double? right = 0.0, double? bottom = 0.0, required Widget child})
  Positioned$Mate.fill({
    /// param: {Key? key}
    Key? key,

    /// param: {double? left = 0.0}
    double? left,

    /// param: {double? top = 0.0}
    double? top,

    /// param: {double? right = 0.0}
    double? right,

    /// param: {double? bottom = 0.0}
    double? bottom,

    /// param: {required Widget child}
    required Widget child,
  }) : super.fill(
          key: key,
          left: left,
          top: top,
          right: right,
          bottom: bottom,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Positioned$Mate.fill(
        key: p.getValue('key'),
        left: p.getValue('left'),
        top: p.getValue('top'),
        right: p.getValue('right'),
        bottom: p.getValue('bottom'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'left', init: left);
    mateParams.set(name: 'top', init: top);
    mateParams.set(name: 'right', init: right);
    mateParams.set(name: 'bottom', init: bottom);
    mateParams.set(name: 'child', init: child);
  }
}

/// class PositionedDirectional extends StatelessWidget
class PositionedDirectional$Mate extends PositionedDirectional with WidgetMate<PositionedDirectional$Mate> {
  /// PositionedDirectional PositionedDirectional({Key? key, double? start, double? top, double? end, double? bottom, double? width, double? height, required Widget child})
  PositionedDirectional$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {double? start}
    double? start,

    /// param: {double? top}
    double? top,

    /// param: {double? end}
    double? end,

    /// param: {double? bottom}
    double? bottom,

    /// param: {double? width}
    double? width,

    /// param: {double? height}
    double? height,

    /// param: {required Widget child}
    required Widget child,
  }) : super(
          key: key,
          start: start,
          top: top,
          end: end,
          bottom: bottom,
          width: width,
          height: height,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => PositionedDirectional$Mate(
        key: p.getValue('key'),
        start: p.getValue('start'),
        top: p.getValue('top'),
        end: p.getValue('end'),
        bottom: p.getValue('bottom'),
        width: p.getValue('width'),
        height: p.getValue('height'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'start', init: start);
    mateParams.set(name: 'top', init: top);
    mateParams.set(name: 'end', init: end);
    mateParams.set(name: 'bottom', init: bottom);
    mateParams.set(name: 'width', init: width);
    mateParams.set(name: 'height', init: height);
    mateParams.set(name: 'child', init: child);
  }
}

/// class Flex extends MultiChildRenderObjectWidget
class Flex$Mate extends Flex with WidgetMate<Flex$Mate> {
  /// Flex Flex({Key? key, required Axis direction, MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start, MainAxisSize mainAxisSize = MainAxisSize.max, CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center, TextDirection? textDirection, VerticalDirection verticalDirection = VerticalDirection.down, TextBaseline? textBaseline, Clip clipBehavior = Clip.none, List<Widget> children = const <Widget>[]})
  Flex$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required Axis direction}
    required Axis direction,

    /// param: {MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start}
    required MainAxisAlignment mainAxisAlignment,

    /// param: {MainAxisSize mainAxisSize = MainAxisSize.max}
    required MainAxisSize mainAxisSize,

    /// param: {CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center}
    required CrossAxisAlignment crossAxisAlignment,

    /// param: {TextDirection? textDirection}
    TextDirection? textDirection,

    /// param: {VerticalDirection verticalDirection = VerticalDirection.down}
    required VerticalDirection verticalDirection,

    /// param: {TextBaseline? textBaseline}
    TextBaseline? textBaseline,

    /// param: {Clip clipBehavior = Clip.none}
    required Clip clipBehavior,

    /// param: {List<Widget> children = const <Widget>[]}
    required List<Widget> children,
  }) : super(
          key: key,
          direction: direction,
          mainAxisAlignment: mainAxisAlignment,
          mainAxisSize: mainAxisSize,
          crossAxisAlignment: crossAxisAlignment,
          textDirection: textDirection,
          verticalDirection: verticalDirection,
          textBaseline: textBaseline,
          clipBehavior: clipBehavior,
          children: children,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Flex$Mate(
        key: p.getValue('key'),
        direction: p.getValue('direction'),
        mainAxisAlignment: p.getValue('mainAxisAlignment'),
        mainAxisSize: p.getValue('mainAxisSize'),
        crossAxisAlignment: p.getValue('crossAxisAlignment'),
        textDirection: p.getValue('textDirection'),
        verticalDirection: p.getValue('verticalDirection'),
        textBaseline: p.getValue('textBaseline'),
        clipBehavior: p.getValue('clipBehavior'),
        children: p.getValue('children'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'direction', init: direction);
    mateParams.set(name: 'mainAxisAlignment', init: mainAxisAlignment);
    mateParams.set(name: 'mainAxisSize', init: mainAxisSize);
    mateParams.set(name: 'crossAxisAlignment', init: crossAxisAlignment);
    mateParams.set(name: 'textDirection', init: textDirection);
    mateParams.set(name: 'verticalDirection', init: verticalDirection);
    mateParams.set(name: 'textBaseline', init: textBaseline);
    mateParams.set(name: 'clipBehavior', init: clipBehavior);
    mateParams.set(name: 'children', init: children);
  }
}

/// class Row extends Flex
class Row$Mate extends Row with WidgetMate<Row$Mate> {
  /// Row Row({Key? key, MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start, MainAxisSize mainAxisSize = MainAxisSize.max, CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center, TextDirection? textDirection, VerticalDirection verticalDirection = VerticalDirection.down, TextBaseline? textBaseline, List<Widget> children = const <Widget>[]})
  Row$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start}
    required MainAxisAlignment mainAxisAlignment,

    /// param: {MainAxisSize mainAxisSize = MainAxisSize.max}
    required MainAxisSize mainAxisSize,

    /// param: {CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center}
    required CrossAxisAlignment crossAxisAlignment,

    /// param: {TextDirection? textDirection}
    TextDirection? textDirection,

    /// param: {VerticalDirection verticalDirection = VerticalDirection.down}
    required VerticalDirection verticalDirection,

    /// param: {TextBaseline? textBaseline}
    TextBaseline? textBaseline,

    /// param: {List<Widget> children = const <Widget>[]}
    required List<Widget> children,
  }) : super(
          key: key,
          mainAxisAlignment: mainAxisAlignment,
          mainAxisSize: mainAxisSize,
          crossAxisAlignment: crossAxisAlignment,
          textDirection: textDirection,
          verticalDirection: verticalDirection,
          textBaseline: textBaseline,
          children: children,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Row$Mate(
        key: p.getValue('key'),
        mainAxisAlignment: p.getValue('mainAxisAlignment'),
        mainAxisSize: p.getValue('mainAxisSize'),
        crossAxisAlignment: p.getValue('crossAxisAlignment'),
        textDirection: p.getValue('textDirection'),
        verticalDirection: p.getValue('verticalDirection'),
        textBaseline: p.getValue('textBaseline'),
        children: p.getValue('children'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'mainAxisAlignment', init: mainAxisAlignment);
    mateParams.set(name: 'mainAxisSize', init: mainAxisSize);
    mateParams.set(name: 'crossAxisAlignment', init: crossAxisAlignment);
    mateParams.set(name: 'textDirection', init: textDirection);
    mateParams.set(name: 'verticalDirection', init: verticalDirection);
    mateParams.set(name: 'textBaseline', init: textBaseline);
    mateParams.set(name: 'children', init: children);
  }
}

/// class Column extends Flex
class Column$Mate extends Column with WidgetMate<Column$Mate> {
  /// Column Column({Key? key, MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start, MainAxisSize mainAxisSize = MainAxisSize.max, CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center, TextDirection? textDirection, VerticalDirection verticalDirection = VerticalDirection.down, TextBaseline? textBaseline, List<Widget> children = const <Widget>[]})
  Column$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start}
    required MainAxisAlignment mainAxisAlignment,

    /// param: {MainAxisSize mainAxisSize = MainAxisSize.max}
    required MainAxisSize mainAxisSize,

    /// param: {CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center}
    required CrossAxisAlignment crossAxisAlignment,

    /// param: {TextDirection? textDirection}
    TextDirection? textDirection,

    /// param: {VerticalDirection verticalDirection = VerticalDirection.down}
    required VerticalDirection verticalDirection,

    /// param: {TextBaseline? textBaseline}
    TextBaseline? textBaseline,

    /// param: {List<Widget> children = const <Widget>[]}
    required List<Widget> children,
  }) : super(
          key: key,
          mainAxisAlignment: mainAxisAlignment,
          mainAxisSize: mainAxisSize,
          crossAxisAlignment: crossAxisAlignment,
          textDirection: textDirection,
          verticalDirection: verticalDirection,
          textBaseline: textBaseline,
          children: children,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Column$Mate(
        key: p.getValue('key'),
        mainAxisAlignment: p.getValue('mainAxisAlignment'),
        mainAxisSize: p.getValue('mainAxisSize'),
        crossAxisAlignment: p.getValue('crossAxisAlignment'),
        textDirection: p.getValue('textDirection'),
        verticalDirection: p.getValue('verticalDirection'),
        textBaseline: p.getValue('textBaseline'),
        children: p.getValue('children'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'mainAxisAlignment', init: mainAxisAlignment);
    mateParams.set(name: 'mainAxisSize', init: mainAxisSize);
    mateParams.set(name: 'crossAxisAlignment', init: crossAxisAlignment);
    mateParams.set(name: 'textDirection', init: textDirection);
    mateParams.set(name: 'verticalDirection', init: verticalDirection);
    mateParams.set(name: 'textBaseline', init: textBaseline);
    mateParams.set(name: 'children', init: children);
  }
}

/// class Flexible extends ParentDataWidget<FlexParentData>
class Flexible$Mate extends Flexible with WidgetMate<Flexible$Mate> {
  /// Flexible Flexible({Key? key, int flex = 1, FlexFit fit = FlexFit.loose, required Widget child})
  Flexible$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {int flex = 1}
    required int flex,

    /// param: {FlexFit fit = FlexFit.loose}
    required FlexFit fit,

    /// param: {required Widget child}
    required Widget child,
  }) : super(
          key: key,
          flex: flex,
          fit: fit,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Flexible$Mate(
        key: p.getValue('key'),
        flex: p.getValue('flex'),
        fit: p.getValue('fit'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'flex', init: flex);
    mateParams.set(name: 'fit', init: fit);
    mateParams.set(name: 'child', init: child);
  }
}

/// class Expanded extends Flexible
class Expanded$Mate extends Expanded with WidgetMate<Expanded$Mate> {
  /// Expanded Expanded({Key? key, int flex = 1, required Widget child})
  Expanded$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {int flex = 1}
    required int flex,

    /// param: {required Widget child}
    required Widget child,
  }) : super(
          key: key,
          flex: flex,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Expanded$Mate(
        key: p.getValue('key'),
        flex: p.getValue('flex'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'flex', init: flex);
    mateParams.set(name: 'child', init: child);
  }
}

/// class Wrap extends MultiChildRenderObjectWidget
class Wrap$Mate extends Wrap with WidgetMate<Wrap$Mate> {
  /// Wrap Wrap({Key? key, Axis direction = Axis.horizontal, WrapAlignment alignment = WrapAlignment.start, double spacing = 0.0, WrapAlignment runAlignment = WrapAlignment.start, double runSpacing = 0.0, WrapCrossAlignment crossAxisAlignment = WrapCrossAlignment.start, TextDirection? textDirection, VerticalDirection verticalDirection = VerticalDirection.down, Clip clipBehavior = Clip.none, List<Widget> children = const <Widget>[]})
  Wrap$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {Axis direction = Axis.horizontal}
    required Axis direction,

    /// param: {WrapAlignment alignment = WrapAlignment.start}
    required WrapAlignment alignment,

    /// param: {double spacing = 0.0}
    required double spacing,

    /// param: {WrapAlignment runAlignment = WrapAlignment.start}
    required WrapAlignment runAlignment,

    /// param: {double runSpacing = 0.0}
    required double runSpacing,

    /// param: {WrapCrossAlignment crossAxisAlignment = WrapCrossAlignment.start}
    required WrapCrossAlignment crossAxisAlignment,

    /// param: {TextDirection? textDirection}
    TextDirection? textDirection,

    /// param: {VerticalDirection verticalDirection = VerticalDirection.down}
    required VerticalDirection verticalDirection,

    /// param: {Clip clipBehavior = Clip.none}
    required Clip clipBehavior,

    /// param: {List<Widget> children = const <Widget>[]}
    required List<Widget> children,
  }) : super(
          key: key,
          direction: direction,
          alignment: alignment,
          spacing: spacing,
          runAlignment: runAlignment,
          runSpacing: runSpacing,
          crossAxisAlignment: crossAxisAlignment,
          textDirection: textDirection,
          verticalDirection: verticalDirection,
          clipBehavior: clipBehavior,
          children: children,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Wrap$Mate(
        key: p.getValue('key'),
        direction: p.getValue('direction'),
        alignment: p.getValue('alignment'),
        spacing: p.getValue('spacing'),
        runAlignment: p.getValue('runAlignment'),
        runSpacing: p.getValue('runSpacing'),
        crossAxisAlignment: p.getValue('crossAxisAlignment'),
        textDirection: p.getValue('textDirection'),
        verticalDirection: p.getValue('verticalDirection'),
        clipBehavior: p.getValue('clipBehavior'),
        children: p.getValue('children'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'direction', init: direction);
    mateParams.set(name: 'alignment', init: alignment);
    mateParams.set(name: 'spacing', init: spacing);
    mateParams.set(name: 'runAlignment', init: runAlignment);
    mateParams.set(name: 'runSpacing', init: runSpacing);
    mateParams.set(name: 'crossAxisAlignment', init: crossAxisAlignment);
    mateParams.set(name: 'textDirection', init: textDirection);
    mateParams.set(name: 'verticalDirection', init: verticalDirection);
    mateParams.set(name: 'clipBehavior', init: clipBehavior);
    mateParams.set(name: 'children', init: children);
  }
}

/// class Flow extends MultiChildRenderObjectWidget
class Flow$Mate extends Flow with WidgetMate<Flow$Mate> {
  /// Flow Flow({Key? key, required FlowDelegate delegate, List<Widget> children = const <Widget>[], Clip clipBehavior = Clip.hardEdge})
  Flow$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required FlowDelegate delegate}
    required FlowDelegate delegate,

    /// param: {List<Widget> children = const <Widget>[]}
    required List<Widget> children,

    /// param: {Clip clipBehavior = Clip.hardEdge}
    required Clip clipBehavior,
  }) : super(
          key: key,
          delegate: delegate,
          children: children,
          clipBehavior: clipBehavior,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Flow$Mate(
        key: p.getValue('key'),
        delegate: p.getValue('delegate'),
        children: p.getValue('children'),
        clipBehavior: p.getValue('clipBehavior'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'delegate', init: delegate);
    mateParams.set(name: 'children', init: children);
    mateParams.set(name: 'clipBehavior', init: clipBehavior);
  }

  /// Flow Flow.unwrapped({Key? key, required FlowDelegate delegate, List<Widget> children = const <Widget>[], Clip clipBehavior = Clip.hardEdge})
  Flow$Mate.unwrapped({
    /// param: {Key? key}
    Key? key,

    /// param: {required FlowDelegate delegate}
    required FlowDelegate delegate,

    /// param: {List<Widget> children = const <Widget>[]}
    required List<Widget> children,

    /// param: {Clip clipBehavior = Clip.hardEdge}
    required Clip clipBehavior,
  }) : super.unwrapped(
          key: key,
          delegate: delegate,
          children: children,
          clipBehavior: clipBehavior,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Flow$Mate.unwrapped(
        key: p.getValue('key'),
        delegate: p.getValue('delegate'),
        children: p.getValue('children'),
        clipBehavior: p.getValue('clipBehavior'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'delegate', init: delegate);
    mateParams.set(name: 'children', init: children);
    mateParams.set(name: 'clipBehavior', init: clipBehavior);
  }
}

/// class RichText extends MultiChildRenderObjectWidget
class RichText$Mate extends RichText with WidgetMate<RichText$Mate> {
  /// RichText RichText({Key? key, required InlineSpan text, TextAlign textAlign = TextAlign.start, TextDirection? textDirection, bool softWrap = true, TextOverflow overflow = TextOverflow.clip, double textScaleFactor = 1.0, int? maxLines, Locale? locale, StrutStyle? strutStyle, TextWidthBasis textWidthBasis = TextWidthBasis.parent, TextHeightBehavior? textHeightBehavior, SelectionRegistrar? selectionRegistrar, Color? selectionColor})
  RichText$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required InlineSpan text}
    required InlineSpan text,

    /// param: {TextAlign textAlign = TextAlign.start}
    required TextAlign textAlign,

    /// param: {TextDirection? textDirection}
    TextDirection? textDirection,

    /// param: {bool softWrap = true}
    required bool softWrap,

    /// param: {TextOverflow overflow = TextOverflow.clip}
    required TextOverflow overflow,

    /// param: {double textScaleFactor = 1.0}
    required double textScaleFactor,

    /// param: {int? maxLines}
    int? maxLines,

    /// param: {Locale? locale}
    Locale? locale,

    /// param: {StrutStyle? strutStyle}
    StrutStyle? strutStyle,

    /// param: {TextWidthBasis textWidthBasis = TextWidthBasis.parent}
    required TextWidthBasis textWidthBasis,

    /// param: {TextHeightBehavior? textHeightBehavior}
    TextHeightBehavior? textHeightBehavior,

    /// param: {SelectionRegistrar? selectionRegistrar}
    SelectionRegistrar? selectionRegistrar,

    /// param: {Color? selectionColor}
    Color? selectionColor,
  }) : super(
          key: key,
          text: text,
          textAlign: textAlign,
          textDirection: textDirection,
          softWrap: softWrap,
          overflow: overflow,
          textScaleFactor: textScaleFactor,
          maxLines: maxLines,
          locale: locale,
          strutStyle: strutStyle,
          textWidthBasis: textWidthBasis,
          textHeightBehavior: textHeightBehavior,
          selectionRegistrar: selectionRegistrar,
          selectionColor: selectionColor,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => RichText$Mate(
        key: p.getValue('key'),
        text: p.getValue('text'),
        textAlign: p.getValue('textAlign'),
        textDirection: p.getValue('textDirection'),
        softWrap: p.getValue('softWrap'),
        overflow: p.getValue('overflow'),
        textScaleFactor: p.getValue('textScaleFactor'),
        maxLines: p.getValue('maxLines'),
        locale: p.getValue('locale'),
        strutStyle: p.getValue('strutStyle'),
        textWidthBasis: p.getValue('textWidthBasis'),
        textHeightBehavior: p.getValue('textHeightBehavior'),
        selectionRegistrar: p.getValue('selectionRegistrar'),
        selectionColor: p.getValue('selectionColor'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'text', init: text);
    mateParams.set(name: 'textAlign', init: textAlign);
    mateParams.set(name: 'textDirection', init: textDirection);
    mateParams.set(name: 'softWrap', init: softWrap);
    mateParams.set(name: 'overflow', init: overflow);
    mateParams.set(name: 'textScaleFactor', init: textScaleFactor);
    mateParams.set(name: 'maxLines', init: maxLines);
    mateParams.set(name: 'locale', init: locale);
    mateParams.set(name: 'strutStyle', init: strutStyle);
    mateParams.set(name: 'textWidthBasis', init: textWidthBasis);
    mateParams.set(name: 'textHeightBehavior', init: textHeightBehavior);
    mateParams.set(name: 'selectionRegistrar', init: selectionRegistrar);
    mateParams.set(name: 'selectionColor', init: selectionColor);
  }
}

/// class RawImage extends LeafRenderObjectWidget
class RawImage$Mate extends RawImage with WidgetMate<RawImage$Mate> {
  /// RawImage RawImage({Key? key, Image? image, String? debugImageLabel, double? width, double? height, double scale = 1.0, Color? color, Animation<double>? opacity, BlendMode? colorBlendMode, BoxFit? fit, AlignmentGeometry alignment = Alignment.center, ImageRepeat repeat = ImageRepeat.noRepeat, Rect? centerSlice, bool matchTextDirection = false, bool invertColors = false, FilterQuality filterQuality = FilterQuality.low, bool isAntiAlias = false})
  RawImage$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {Image? image}
    Image? image,

    /// param: {String? debugImageLabel}
    String? debugImageLabel,

    /// param: {double? width}
    double? width,

    /// param: {double? height}
    double? height,

    /// param: {double scale = 1.0}
    required double scale,

    /// param: {Color? color}
    Color? color,

    /// param: {Animation<double>? opacity}
    Animation<double>? opacity,

    /// param: {BlendMode? colorBlendMode}
    BlendMode? colorBlendMode,

    /// param: {BoxFit? fit}
    BoxFit? fit,

    /// param: {AlignmentGeometry alignment = Alignment.center}
    required AlignmentGeometry alignment,

    /// param: {ImageRepeat repeat = ImageRepeat.noRepeat}
    required ImageRepeat repeat,

    /// param: {Rect? centerSlice}
    Rect? centerSlice,

    /// param: {bool matchTextDirection = false}
    required bool matchTextDirection,

    /// param: {bool invertColors = false}
    required bool invertColors,

    /// param: {FilterQuality filterQuality = FilterQuality.low}
    required FilterQuality filterQuality,

    /// param: {bool isAntiAlias = false}
    required bool isAntiAlias,
  }) : super(
          key: key,
          image: image,
          debugImageLabel: debugImageLabel,
          width: width,
          height: height,
          scale: scale,
          color: color,
          opacity: opacity,
          colorBlendMode: colorBlendMode,
          fit: fit,
          alignment: alignment,
          repeat: repeat,
          centerSlice: centerSlice,
          matchTextDirection: matchTextDirection,
          invertColors: invertColors,
          filterQuality: filterQuality,
          isAntiAlias: isAntiAlias,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => RawImage$Mate(
        key: p.getValue('key'),
        image: p.getValue('image'),
        debugImageLabel: p.getValue('debugImageLabel'),
        width: p.getValue('width'),
        height: p.getValue('height'),
        scale: p.getValue('scale'),
        color: p.getValue('color'),
        opacity: p.getValue('opacity'),
        colorBlendMode: p.getValue('colorBlendMode'),
        fit: p.getValue('fit'),
        alignment: p.getValue('alignment'),
        repeat: p.getValue('repeat'),
        centerSlice: p.getValue('centerSlice'),
        matchTextDirection: p.getValue('matchTextDirection'),
        invertColors: p.getValue('invertColors'),
        filterQuality: p.getValue('filterQuality'),
        isAntiAlias: p.getValue('isAntiAlias'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'image', init: image);
    mateParams.set(name: 'debugImageLabel', init: debugImageLabel);
    mateParams.set(name: 'width', init: width);
    mateParams.set(name: 'height', init: height);
    mateParams.set(name: 'scale', init: scale);
    mateParams.set(name: 'color', init: color);
    mateParams.set(name: 'opacity', init: opacity);
    mateParams.set(name: 'colorBlendMode', init: colorBlendMode);
    mateParams.set(name: 'fit', init: fit);
    mateParams.set(name: 'alignment', init: alignment);
    mateParams.set(name: 'repeat', init: repeat);
    mateParams.set(name: 'centerSlice', init: centerSlice);
    mateParams.set(name: 'matchTextDirection', init: matchTextDirection);
    mateParams.set(name: 'invertColors', init: invertColors);
    mateParams.set(name: 'filterQuality', init: filterQuality);
    mateParams.set(name: 'isAntiAlias', init: isAntiAlias);
  }
}

/// class DefaultAssetBundle extends InheritedWidget
class DefaultAssetBundle$Mate extends DefaultAssetBundle with WidgetMate<DefaultAssetBundle$Mate> {
  /// DefaultAssetBundle DefaultAssetBundle({Key? key, required AssetBundle bundle, required Widget child})
  DefaultAssetBundle$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required AssetBundle bundle}
    required AssetBundle bundle,

    /// param: {required Widget child}
    required Widget child,
  }) : super(
          key: key,
          bundle: bundle,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => DefaultAssetBundle$Mate(
        key: p.getValue('key'),
        bundle: p.getValue('bundle'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'bundle', init: bundle);
    mateParams.set(name: 'child', init: child);
  }
}

/// class WidgetToRenderBoxAdapter extends LeafRenderObjectWidget
class WidgetToRenderBoxAdapter$Mate extends WidgetToRenderBoxAdapter with WidgetMate<WidgetToRenderBoxAdapter$Mate> {
  /// WidgetToRenderBoxAdapter WidgetToRenderBoxAdapter({required RenderBox renderBox, void Function()? onBuild, void Function()? onUnmount})
  WidgetToRenderBoxAdapter$Mate({
    /// param: {required RenderBox renderBox}
    required RenderBox renderBox,

    /// param: {void Function()? onBuild}
    VoidCallback? onBuild,

    /// param: {void Function()? onUnmount}
    VoidCallback? onUnmount,
  }) : super(
          renderBox: renderBox,
          onBuild: onBuild,
          onUnmount: onUnmount,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => WidgetToRenderBoxAdapter$Mate(
        renderBox: p.getValue('renderBox'),
        onBuild: p.getValue('onBuild'),
        onUnmount: p.getValue('onUnmount'),
      ),
    );
    mateParams.set(name: 'renderBox', init: renderBox);
    mateParams.set(name: 'onBuild', init: onBuild);
    mateParams.set(name: 'onUnmount', init: onUnmount);
  }
}

/// class Listener extends SingleChildRenderObjectWidget
class Listener$Mate extends Listener with WidgetMate<Listener$Mate> {
  /// Listener Listener({Key? key, void Function(PointerDownEvent)? onPointerDown, void Function(PointerMoveEvent)? onPointerMove, void Function(PointerUpEvent)? onPointerUp, void Function(PointerHoverEvent)? onPointerHover, void Function(PointerCancelEvent)? onPointerCancel, void Function(PointerPanZoomStartEvent)? onPointerPanZoomStart, void Function(PointerPanZoomUpdateEvent)? onPointerPanZoomUpdate, void Function(PointerPanZoomEndEvent)? onPointerPanZoomEnd, void Function(PointerSignalEvent)? onPointerSignal, HitTestBehavior behavior = HitTestBehavior.deferToChild, Widget? child})
  Listener$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {void Function(PointerDownEvent)? onPointerDown}
    PointerDownEventListener? onPointerDown,

    /// param: {void Function(PointerMoveEvent)? onPointerMove}
    PointerMoveEventListener? onPointerMove,

    /// param: {void Function(PointerUpEvent)? onPointerUp}
    PointerUpEventListener? onPointerUp,

    /// param: {void Function(PointerHoverEvent)? onPointerHover}
    PointerHoverEventListener? onPointerHover,

    /// param: {void Function(PointerCancelEvent)? onPointerCancel}
    PointerCancelEventListener? onPointerCancel,

    /// param: {void Function(PointerPanZoomStartEvent)? onPointerPanZoomStart}
    PointerPanZoomStartEventListener? onPointerPanZoomStart,

    /// param: {void Function(PointerPanZoomUpdateEvent)? onPointerPanZoomUpdate}
    PointerPanZoomUpdateEventListener? onPointerPanZoomUpdate,

    /// param: {void Function(PointerPanZoomEndEvent)? onPointerPanZoomEnd}
    PointerPanZoomEndEventListener? onPointerPanZoomEnd,

    /// param: {void Function(PointerSignalEvent)? onPointerSignal}
    PointerSignalEventListener? onPointerSignal,

    /// param: {HitTestBehavior behavior = HitTestBehavior.deferToChild}
    required HitTestBehavior behavior,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          onPointerDown: onPointerDown,
          onPointerMove: onPointerMove,
          onPointerUp: onPointerUp,
          onPointerHover: onPointerHover,
          onPointerCancel: onPointerCancel,
          onPointerPanZoomStart: onPointerPanZoomStart,
          onPointerPanZoomUpdate: onPointerPanZoomUpdate,
          onPointerPanZoomEnd: onPointerPanZoomEnd,
          onPointerSignal: onPointerSignal,
          behavior: behavior,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Listener$Mate(
        key: p.getValue('key'),
        onPointerDown: p.getValue('onPointerDown'),
        onPointerMove: p.getValue('onPointerMove'),
        onPointerUp: p.getValue('onPointerUp'),
        onPointerHover: p.getValue('onPointerHover'),
        onPointerCancel: p.getValue('onPointerCancel'),
        onPointerPanZoomStart: p.getValue('onPointerPanZoomStart'),
        onPointerPanZoomUpdate: p.getValue('onPointerPanZoomUpdate'),
        onPointerPanZoomEnd: p.getValue('onPointerPanZoomEnd'),
        onPointerSignal: p.getValue('onPointerSignal'),
        behavior: p.getValue('behavior'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'onPointerDown', init: onPointerDown);
    mateParams.set(name: 'onPointerMove', init: onPointerMove);
    mateParams.set(name: 'onPointerUp', init: onPointerUp);
    mateParams.set(name: 'onPointerHover', init: onPointerHover);
    mateParams.set(name: 'onPointerCancel', init: onPointerCancel);
    mateParams.set(name: 'onPointerPanZoomStart', init: onPointerPanZoomStart);
    mateParams.set(name: 'onPointerPanZoomUpdate', init: onPointerPanZoomUpdate);
    mateParams.set(name: 'onPointerPanZoomEnd', init: onPointerPanZoomEnd);
    mateParams.set(name: 'onPointerSignal', init: onPointerSignal);
    mateParams.set(name: 'behavior', init: behavior);
    mateParams.set(name: 'child', init: child);
  }
}

/// class MouseRegion extends SingleChildRenderObjectWidget
class MouseRegion$Mate extends MouseRegion with WidgetMate<MouseRegion$Mate> {
  /// MouseRegion MouseRegion({Key? key, void Function(PointerEnterEvent)? onEnter, void Function(PointerExitEvent)? onExit, void Function(PointerHoverEvent)? onHover, MouseCursor cursor = MouseCursor.defer, bool opaque = true, HitTestBehavior? hitTestBehavior, Widget? child})
  MouseRegion$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {void Function(PointerEnterEvent)? onEnter}
    PointerEnterEventListener? onEnter,

    /// param: {void Function(PointerExitEvent)? onExit}
    PointerExitEventListener? onExit,

    /// param: {void Function(PointerHoverEvent)? onHover}
    PointerHoverEventListener? onHover,

    /// param: {MouseCursor cursor = MouseCursor.defer}
    required MouseCursor cursor,

    /// param: {bool opaque = true}
    required bool opaque,

    /// param: {HitTestBehavior? hitTestBehavior}
    HitTestBehavior? hitTestBehavior,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          onEnter: onEnter,
          onExit: onExit,
          onHover: onHover,
          cursor: cursor,
          opaque: opaque,
          hitTestBehavior: hitTestBehavior,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => MouseRegion$Mate(
        key: p.getValue('key'),
        onEnter: p.getValue('onEnter'),
        onExit: p.getValue('onExit'),
        onHover: p.getValue('onHover'),
        cursor: p.getValue('cursor'),
        opaque: p.getValue('opaque'),
        hitTestBehavior: p.getValue('hitTestBehavior'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'onEnter', init: onEnter);
    mateParams.set(name: 'onExit', init: onExit);
    mateParams.set(name: 'onHover', init: onHover);
    mateParams.set(name: 'cursor', init: cursor);
    mateParams.set(name: 'opaque', init: opaque);
    mateParams.set(name: 'hitTestBehavior', init: hitTestBehavior);
    mateParams.set(name: 'child', init: child);
  }
}

/// class RepaintBoundary extends SingleChildRenderObjectWidget
class RepaintBoundary$Mate extends RepaintBoundary with WidgetMate<RepaintBoundary$Mate> {
  /// RepaintBoundary RepaintBoundary({Key? key, Widget? child})
  RepaintBoundary$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => RepaintBoundary$Mate(
        key: p.getValue('key'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'child', init: child);
  }
}

/// class IgnorePointer extends SingleChildRenderObjectWidget
class IgnorePointer$Mate extends IgnorePointer with WidgetMate<IgnorePointer$Mate> {
  /// IgnorePointer IgnorePointer({Key? key, bool ignoring = true, bool? ignoringSemantics, Widget? child})
  IgnorePointer$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {bool ignoring = true}
    required bool ignoring,

    /// param: {bool? ignoringSemantics}
    bool? ignoringSemantics,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          ignoring: ignoring,
          ignoringSemantics: ignoringSemantics,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => IgnorePointer$Mate(
        key: p.getValue('key'),
        ignoring: p.getValue('ignoring'),
        ignoringSemantics: p.getValue('ignoringSemantics'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'ignoring', init: ignoring);
    mateParams.set(name: 'ignoringSemantics', init: ignoringSemantics);
    mateParams.set(name: 'child', init: child);
  }
}

/// class AbsorbPointer extends SingleChildRenderObjectWidget
class AbsorbPointer$Mate extends AbsorbPointer with WidgetMate<AbsorbPointer$Mate> {
  /// AbsorbPointer AbsorbPointer({Key? key, bool absorbing = true, Widget? child, bool? ignoringSemantics})
  AbsorbPointer$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {bool absorbing = true}
    required bool absorbing,

    /// param: {Widget? child}
    Widget? child,

    /// param: {bool? ignoringSemantics}
    bool? ignoringSemantics,
  }) : super(
          key: key,
          absorbing: absorbing,
          child: child,
          ignoringSemantics: ignoringSemantics,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => AbsorbPointer$Mate(
        key: p.getValue('key'),
        absorbing: p.getValue('absorbing'),
        child: p.getValue('child'),
        ignoringSemantics: p.getValue('ignoringSemantics'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'absorbing', init: absorbing);
    mateParams.set(name: 'child', init: child);
    mateParams.set(name: 'ignoringSemantics', init: ignoringSemantics);
  }
}

/// class MetaData extends SingleChildRenderObjectWidget
class MetaData$Mate extends MetaData with WidgetMate<MetaData$Mate> {
  /// MetaData MetaData({Key? key, dynamic metaData, HitTestBehavior behavior = HitTestBehavior.deferToChild, Widget? child})
  MetaData$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {dynamic metaData}
    required dynamic metaData,

    /// param: {HitTestBehavior behavior = HitTestBehavior.deferToChild}
    required HitTestBehavior behavior,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          metaData: metaData,
          behavior: behavior,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => MetaData$Mate(
        key: p.getValue('key'),
        metaData: p.getValue('metaData'),
        behavior: p.getValue('behavior'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'metaData', init: metaData);
    mateParams.set(name: 'behavior', init: behavior);
    mateParams.set(name: 'child', init: child);
  }
}

/// class Semantics extends SingleChildRenderObjectWidget
class Semantics$Mate extends Semantics with WidgetMate<Semantics$Mate> {
  /// Semantics Semantics({Key? key, Widget? child, bool container = false, bool explicitChildNodes = false, bool excludeSemantics = false, bool? enabled, bool? checked, bool? mixed, bool? selected, bool? toggled, bool? button, bool? slider, bool? keyboardKey, bool? link, bool? header, bool? textField, bool? readOnly, bool? focusable, bool? focused, bool? inMutuallyExclusiveGroup, bool? obscured, bool? multiline, bool? scopesRoute, bool? namesRoute, bool? hidden, bool? image, bool? liveRegion, int? maxValueLength, int? currentValueLength, String? label, AttributedString? attributedLabel, String? value, AttributedString? attributedValue, String? increasedValue, AttributedString? attributedIncreasedValue, String? decreasedValue, AttributedString? attributedDecreasedValue, String? hint, AttributedString? attributedHint, String? tooltip, String? onTapHint, String? onLongPressHint, TextDirection? textDirection, SemanticsSortKey? sortKey, SemanticsTag? tagForChildren, void Function()? onTap, void Function()? onLongPress, void Function()? onScrollLeft, void Function()? onScrollRight, void Function()? onScrollUp, void Function()? onScrollDown, void Function()? onIncrease, void Function()? onDecrease, void Function()? onCopy, void Function()? onCut, void Function()? onPaste, void Function()? onDismiss, void Function(bool)? onMoveCursorForwardByCharacter, void Function(bool)? onMoveCursorBackwardByCharacter, void Function(TextSelection)? onSetSelection, void Function(String)? onSetText, void Function()? onDidGainAccessibilityFocus, void Function()? onDidLoseAccessibilityFocus, Map<CustomSemanticsAction, void Function()>? customSemanticsActions})
  Semantics$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {Widget? child}
    Widget? child,

    /// param: {bool container = false}
    required bool container,

    /// param: {bool explicitChildNodes = false}
    required bool explicitChildNodes,

    /// param: {bool excludeSemantics = false}
    required bool excludeSemantics,

    /// param: {bool? enabled}
    bool? enabled,

    /// param: {bool? checked}
    bool? checked,

    /// param: {bool? mixed}
    bool? mixed,

    /// param: {bool? selected}
    bool? selected,

    /// param: {bool? toggled}
    bool? toggled,

    /// param: {bool? button}
    bool? button,

    /// param: {bool? slider}
    bool? slider,

    /// param: {bool? keyboardKey}
    bool? keyboardKey,

    /// param: {bool? link}
    bool? link,

    /// param: {bool? header}
    bool? header,

    /// param: {bool? textField}
    bool? textField,

    /// param: {bool? readOnly}
    bool? readOnly,

    /// param: {bool? focusable}
    bool? focusable,

    /// param: {bool? focused}
    bool? focused,

    /// param: {bool? inMutuallyExclusiveGroup}
    bool? inMutuallyExclusiveGroup,

    /// param: {bool? obscured}
    bool? obscured,

    /// param: {bool? multiline}
    bool? multiline,

    /// param: {bool? scopesRoute}
    bool? scopesRoute,

    /// param: {bool? namesRoute}
    bool? namesRoute,

    /// param: {bool? hidden}
    bool? hidden,

    /// param: {bool? image}
    bool? image,

    /// param: {bool? liveRegion}
    bool? liveRegion,

    /// param: {int? maxValueLength}
    int? maxValueLength,

    /// param: {int? currentValueLength}
    int? currentValueLength,

    /// param: {String? label}
    String? label,

    /// param: {AttributedString? attributedLabel}
    AttributedString? attributedLabel,

    /// param: {String? value}
    String? value,

    /// param: {AttributedString? attributedValue}
    AttributedString? attributedValue,

    /// param: {String? increasedValue}
    String? increasedValue,

    /// param: {AttributedString? attributedIncreasedValue}
    AttributedString? attributedIncreasedValue,

    /// param: {String? decreasedValue}
    String? decreasedValue,

    /// param: {AttributedString? attributedDecreasedValue}
    AttributedString? attributedDecreasedValue,

    /// param: {String? hint}
    String? hint,

    /// param: {AttributedString? attributedHint}
    AttributedString? attributedHint,

    /// param: {String? tooltip}
    String? tooltip,

    /// param: {String? onTapHint}
    String? onTapHint,

    /// param: {String? onLongPressHint}
    String? onLongPressHint,

    /// param: {TextDirection? textDirection}
    TextDirection? textDirection,

    /// param: {SemanticsSortKey? sortKey}
    SemanticsSortKey? sortKey,

    /// param: {SemanticsTag? tagForChildren}
    SemanticsTag? tagForChildren,

    /// param: {void Function()? onTap}
    VoidCallback? onTap,

    /// param: {void Function()? onLongPress}
    VoidCallback? onLongPress,

    /// param: {void Function()? onScrollLeft}
    VoidCallback? onScrollLeft,

    /// param: {void Function()? onScrollRight}
    VoidCallback? onScrollRight,

    /// param: {void Function()? onScrollUp}
    VoidCallback? onScrollUp,

    /// param: {void Function()? onScrollDown}
    VoidCallback? onScrollDown,

    /// param: {void Function()? onIncrease}
    VoidCallback? onIncrease,

    /// param: {void Function()? onDecrease}
    VoidCallback? onDecrease,

    /// param: {void Function()? onCopy}
    VoidCallback? onCopy,

    /// param: {void Function()? onCut}
    VoidCallback? onCut,

    /// param: {void Function()? onPaste}
    VoidCallback? onPaste,

    /// param: {void Function()? onDismiss}
    VoidCallback? onDismiss,

    /// param: {void Function(bool)? onMoveCursorForwardByCharacter}
    MoveCursorHandler? onMoveCursorForwardByCharacter,

    /// param: {void Function(bool)? onMoveCursorBackwardByCharacter}
    MoveCursorHandler? onMoveCursorBackwardByCharacter,

    /// param: {void Function(TextSelection)? onSetSelection}
    SetSelectionHandler? onSetSelection,

    /// param: {void Function(String)? onSetText}
    SetTextHandler? onSetText,

    /// param: {void Function()? onDidGainAccessibilityFocus}
    VoidCallback? onDidGainAccessibilityFocus,

    /// param: {void Function()? onDidLoseAccessibilityFocus}
    VoidCallback? onDidLoseAccessibilityFocus,

    /// param: {Map<CustomSemanticsAction, void Function()>? customSemanticsActions}
    Map<CustomSemanticsAction, VoidCallback>? customSemanticsActions,
  }) : super(
          key: key,
          child: child,
          container: container,
          explicitChildNodes: explicitChildNodes,
          excludeSemantics: excludeSemantics,
          enabled: enabled,
          checked: checked,
          mixed: mixed,
          selected: selected,
          toggled: toggled,
          button: button,
          slider: slider,
          keyboardKey: keyboardKey,
          link: link,
          header: header,
          textField: textField,
          readOnly: readOnly,
          focusable: focusable,
          focused: focused,
          inMutuallyExclusiveGroup: inMutuallyExclusiveGroup,
          obscured: obscured,
          multiline: multiline,
          scopesRoute: scopesRoute,
          namesRoute: namesRoute,
          hidden: hidden,
          image: image,
          liveRegion: liveRegion,
          maxValueLength: maxValueLength,
          currentValueLength: currentValueLength,
          label: label,
          attributedLabel: attributedLabel,
          value: value,
          attributedValue: attributedValue,
          increasedValue: increasedValue,
          attributedIncreasedValue: attributedIncreasedValue,
          decreasedValue: decreasedValue,
          attributedDecreasedValue: attributedDecreasedValue,
          hint: hint,
          attributedHint: attributedHint,
          tooltip: tooltip,
          onTapHint: onTapHint,
          onLongPressHint: onLongPressHint,
          textDirection: textDirection,
          sortKey: sortKey,
          tagForChildren: tagForChildren,
          onTap: onTap,
          onLongPress: onLongPress,
          onScrollLeft: onScrollLeft,
          onScrollRight: onScrollRight,
          onScrollUp: onScrollUp,
          onScrollDown: onScrollDown,
          onIncrease: onIncrease,
          onDecrease: onDecrease,
          onCopy: onCopy,
          onCut: onCut,
          onPaste: onPaste,
          onDismiss: onDismiss,
          onMoveCursorForwardByCharacter: onMoveCursorForwardByCharacter,
          onMoveCursorBackwardByCharacter: onMoveCursorBackwardByCharacter,
          onSetSelection: onSetSelection,
          onSetText: onSetText,
          onDidGainAccessibilityFocus: onDidGainAccessibilityFocus,
          onDidLoseAccessibilityFocus: onDidLoseAccessibilityFocus,
          customSemanticsActions: customSemanticsActions,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Semantics$Mate(
        key: p.getValue('key'),
        child: p.getValue('child'),
        container: p.getValue('container'),
        explicitChildNodes: p.getValue('explicitChildNodes'),
        excludeSemantics: p.getValue('excludeSemantics'),
        enabled: p.getValue('enabled'),
        checked: p.getValue('checked'),
        mixed: p.getValue('mixed'),
        selected: p.getValue('selected'),
        toggled: p.getValue('toggled'),
        button: p.getValue('button'),
        slider: p.getValue('slider'),
        keyboardKey: p.getValue('keyboardKey'),
        link: p.getValue('link'),
        header: p.getValue('header'),
        textField: p.getValue('textField'),
        readOnly: p.getValue('readOnly'),
        focusable: p.getValue('focusable'),
        focused: p.getValue('focused'),
        inMutuallyExclusiveGroup: p.getValue('inMutuallyExclusiveGroup'),
        obscured: p.getValue('obscured'),
        multiline: p.getValue('multiline'),
        scopesRoute: p.getValue('scopesRoute'),
        namesRoute: p.getValue('namesRoute'),
        hidden: p.getValue('hidden'),
        image: p.getValue('image'),
        liveRegion: p.getValue('liveRegion'),
        maxValueLength: p.getValue('maxValueLength'),
        currentValueLength: p.getValue('currentValueLength'),
        label: p.getValue('label'),
        attributedLabel: p.getValue('attributedLabel'),
        value: p.getValue('value'),
        attributedValue: p.getValue('attributedValue'),
        increasedValue: p.getValue('increasedValue'),
        attributedIncreasedValue: p.getValue('attributedIncreasedValue'),
        decreasedValue: p.getValue('decreasedValue'),
        attributedDecreasedValue: p.getValue('attributedDecreasedValue'),
        hint: p.getValue('hint'),
        attributedHint: p.getValue('attributedHint'),
        tooltip: p.getValue('tooltip'),
        onTapHint: p.getValue('onTapHint'),
        onLongPressHint: p.getValue('onLongPressHint'),
        textDirection: p.getValue('textDirection'),
        sortKey: p.getValue('sortKey'),
        tagForChildren: p.getValue('tagForChildren'),
        onTap: p.getValue('onTap'),
        onLongPress: p.getValue('onLongPress'),
        onScrollLeft: p.getValue('onScrollLeft'),
        onScrollRight: p.getValue('onScrollRight'),
        onScrollUp: p.getValue('onScrollUp'),
        onScrollDown: p.getValue('onScrollDown'),
        onIncrease: p.getValue('onIncrease'),
        onDecrease: p.getValue('onDecrease'),
        onCopy: p.getValue('onCopy'),
        onCut: p.getValue('onCut'),
        onPaste: p.getValue('onPaste'),
        onDismiss: p.getValue('onDismiss'),
        onMoveCursorForwardByCharacter: p.getValue('onMoveCursorForwardByCharacter'),
        onMoveCursorBackwardByCharacter: p.getValue('onMoveCursorBackwardByCharacter'),
        onSetSelection: p.getValue('onSetSelection'),
        onSetText: p.getValue('onSetText'),
        onDidGainAccessibilityFocus: p.getValue('onDidGainAccessibilityFocus'),
        onDidLoseAccessibilityFocus: p.getValue('onDidLoseAccessibilityFocus'),
        customSemanticsActions: p.getValue('customSemanticsActions'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'child', init: child);
    mateParams.set(name: 'container', init: container);
    mateParams.set(name: 'explicitChildNodes', init: explicitChildNodes);
    mateParams.set(name: 'excludeSemantics', init: excludeSemantics);
    mateParams.set(name: 'enabled', init: enabled);
    mateParams.set(name: 'checked', init: checked);
    mateParams.set(name: 'mixed', init: mixed);
    mateParams.set(name: 'selected', init: selected);
    mateParams.set(name: 'toggled', init: toggled);
    mateParams.set(name: 'button', init: button);
    mateParams.set(name: 'slider', init: slider);
    mateParams.set(name: 'keyboardKey', init: keyboardKey);
    mateParams.set(name: 'link', init: link);
    mateParams.set(name: 'header', init: header);
    mateParams.set(name: 'textField', init: textField);
    mateParams.set(name: 'readOnly', init: readOnly);
    mateParams.set(name: 'focusable', init: focusable);
    mateParams.set(name: 'focused', init: focused);
    mateParams.set(name: 'inMutuallyExclusiveGroup', init: inMutuallyExclusiveGroup);
    mateParams.set(name: 'obscured', init: obscured);
    mateParams.set(name: 'multiline', init: multiline);
    mateParams.set(name: 'scopesRoute', init: scopesRoute);
    mateParams.set(name: 'namesRoute', init: namesRoute);
    mateParams.set(name: 'hidden', init: hidden);
    mateParams.set(name: 'image', init: image);
    mateParams.set(name: 'liveRegion', init: liveRegion);
    mateParams.set(name: 'maxValueLength', init: maxValueLength);
    mateParams.set(name: 'currentValueLength', init: currentValueLength);
    mateParams.set(name: 'label', init: label);
    mateParams.set(name: 'attributedLabel', init: attributedLabel);
    mateParams.set(name: 'value', init: value);
    mateParams.set(name: 'attributedValue', init: attributedValue);
    mateParams.set(name: 'increasedValue', init: increasedValue);
    mateParams.set(name: 'attributedIncreasedValue', init: attributedIncreasedValue);
    mateParams.set(name: 'decreasedValue', init: decreasedValue);
    mateParams.set(name: 'attributedDecreasedValue', init: attributedDecreasedValue);
    mateParams.set(name: 'hint', init: hint);
    mateParams.set(name: 'attributedHint', init: attributedHint);
    mateParams.set(name: 'tooltip', init: tooltip);
    mateParams.set(name: 'onTapHint', init: onTapHint);
    mateParams.set(name: 'onLongPressHint', init: onLongPressHint);
    mateParams.set(name: 'textDirection', init: textDirection);
    mateParams.set(name: 'sortKey', init: sortKey);
    mateParams.set(name: 'tagForChildren', init: tagForChildren);
    mateParams.set(name: 'onTap', init: onTap);
    mateParams.set(name: 'onLongPress', init: onLongPress);
    mateParams.set(name: 'onScrollLeft', init: onScrollLeft);
    mateParams.set(name: 'onScrollRight', init: onScrollRight);
    mateParams.set(name: 'onScrollUp', init: onScrollUp);
    mateParams.set(name: 'onScrollDown', init: onScrollDown);
    mateParams.set(name: 'onIncrease', init: onIncrease);
    mateParams.set(name: 'onDecrease', init: onDecrease);
    mateParams.set(name: 'onCopy', init: onCopy);
    mateParams.set(name: 'onCut', init: onCut);
    mateParams.set(name: 'onPaste', init: onPaste);
    mateParams.set(name: 'onDismiss', init: onDismiss);
    mateParams.set(name: 'onMoveCursorForwardByCharacter', init: onMoveCursorForwardByCharacter);
    mateParams.set(name: 'onMoveCursorBackwardByCharacter', init: onMoveCursorBackwardByCharacter);
    mateParams.set(name: 'onSetSelection', init: onSetSelection);
    mateParams.set(name: 'onSetText', init: onSetText);
    mateParams.set(name: 'onDidGainAccessibilityFocus', init: onDidGainAccessibilityFocus);
    mateParams.set(name: 'onDidLoseAccessibilityFocus', init: onDidLoseAccessibilityFocus);
    mateParams.set(name: 'customSemanticsActions', init: customSemanticsActions);
  }

  /// Semantics Semantics.fromProperties({Key? key, Widget? child, bool container = false, bool explicitChildNodes = false, bool excludeSemantics = false, required SemanticsProperties properties})
  Semantics$Mate.fromProperties({
    /// param: {Key? key}
    Key? key,

    /// param: {Widget? child}
    Widget? child,

    /// param: {bool container = false}
    required bool container,

    /// param: {bool explicitChildNodes = false}
    required bool explicitChildNodes,

    /// param: {bool excludeSemantics = false}
    required bool excludeSemantics,

    /// param: {required SemanticsProperties properties}
    required SemanticsProperties properties,
  }) : super.fromProperties(
          key: key,
          child: child,
          container: container,
          explicitChildNodes: explicitChildNodes,
          excludeSemantics: excludeSemantics,
          properties: properties,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Semantics$Mate.fromProperties(
        key: p.getValue('key'),
        child: p.getValue('child'),
        container: p.getValue('container'),
        explicitChildNodes: p.getValue('explicitChildNodes'),
        excludeSemantics: p.getValue('excludeSemantics'),
        properties: p.getValue('properties'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'child', init: child);
    mateParams.set(name: 'container', init: container);
    mateParams.set(name: 'explicitChildNodes', init: explicitChildNodes);
    mateParams.set(name: 'excludeSemantics', init: excludeSemantics);
    mateParams.set(name: 'properties', init: properties);
  }
}

/// class MergeSemantics extends SingleChildRenderObjectWidget
class MergeSemantics$Mate extends MergeSemantics with WidgetMate<MergeSemantics$Mate> {
  /// MergeSemantics MergeSemantics({Key? key, Widget? child})
  MergeSemantics$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => MergeSemantics$Mate(
        key: p.getValue('key'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'child', init: child);
  }
}

/// class BlockSemantics extends SingleChildRenderObjectWidget
class BlockSemantics$Mate extends BlockSemantics with WidgetMate<BlockSemantics$Mate> {
  /// BlockSemantics BlockSemantics({Key? key, bool blocking = true, Widget? child})
  BlockSemantics$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {bool blocking = true}
    required bool blocking,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          blocking: blocking,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => BlockSemantics$Mate(
        key: p.getValue('key'),
        blocking: p.getValue('blocking'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'blocking', init: blocking);
    mateParams.set(name: 'child', init: child);
  }
}

/// class ExcludeSemantics extends SingleChildRenderObjectWidget
class ExcludeSemantics$Mate extends ExcludeSemantics with WidgetMate<ExcludeSemantics$Mate> {
  /// ExcludeSemantics ExcludeSemantics({Key? key, bool excluding = true, Widget? child})
  ExcludeSemantics$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {bool excluding = true}
    required bool excluding,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          excluding: excluding,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => ExcludeSemantics$Mate(
        key: p.getValue('key'),
        excluding: p.getValue('excluding'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'excluding', init: excluding);
    mateParams.set(name: 'child', init: child);
  }
}

/// class IndexedSemantics extends SingleChildRenderObjectWidget
class IndexedSemantics$Mate extends IndexedSemantics with WidgetMate<IndexedSemantics$Mate> {
  /// IndexedSemantics IndexedSemantics({Key? key, required int index, Widget? child})
  IndexedSemantics$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required int index}
    required int index,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          index: index,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => IndexedSemantics$Mate(
        key: p.getValue('key'),
        index: p.getValue('index'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'index', init: index);
    mateParams.set(name: 'child', init: child);
  }
}

/// class KeyedSubtree extends StatelessWidget
class KeyedSubtree$Mate extends KeyedSubtree with WidgetMate<KeyedSubtree$Mate> {
  /// KeyedSubtree KeyedSubtree({Key? key, required Widget child})
  KeyedSubtree$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required Widget child}
    required Widget child,
  }) : super(
          key: key,
          child: child,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => KeyedSubtree$Mate(
        key: p.getValue('key'),
        child: p.getValue('child'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'child', init: child);
  }
}

/// class Builder extends StatelessWidget
class Builder$Mate extends Builder with WidgetMate<Builder$Mate> {
  /// Builder Builder({Key? key, required Widget Function(BuildContext) builder})
  Builder$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required Widget Function(BuildContext) builder}
    required WidgetBuilder builder,
  }) : super(
          key: key,
          builder: builder,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => Builder$Mate(
        key: p.getValue('key'),
        builder: p.getValue('builder'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'builder', init: builder);
  }
}

/// class StatefulBuilder extends StatefulWidget
class StatefulBuilder$Mate extends StatefulBuilder with WidgetMate<StatefulBuilder$Mate> {
  /// StatefulBuilder StatefulBuilder({Key? key, required Widget Function(BuildContext, void Function(void Function())) builder})
  StatefulBuilder$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required Widget Function(BuildContext, void Function(void Function())) builder}
    required StatefulWidgetBuilder builder,
  }) : super(
          key: key,
          builder: builder,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => StatefulBuilder$Mate(
        key: p.getValue('key'),
        builder: p.getValue('builder'),
      ),
    );
    mateParams.set(name: 'key', init: key);
    mateParams.set(name: 'builder', init: builder);
  }
}

/// class ColoredBox extends SingleChildRenderObjectWidget
class ColoredBox$Mate extends ColoredBox with WidgetMate<ColoredBox$Mate> {
  /// ColoredBox ColoredBox({required Color color, Widget? child, Key? key})
  ColoredBox$Mate({
    /// param: {required Color color}
    required Color color,

    /// param: {Widget? child}
    Widget? child,

    /// param: {Key? key}
    Key? key,
  }) : super(
          color: color,
          child: child,
          key: key,
        ) {
    mateParams = Params(
      init: this,
      builder: (p) => ColoredBox$Mate(
        color: p.getValue('color'),
        child: p.getValue('child'),
        key: p.getValue('key'),
      ),
    );
    mateParams.set(name: 'color', init: color);
    mateParams.set(name: 'child', init: child);
    mateParams.set(name: 'key', init: key);
  }
}
