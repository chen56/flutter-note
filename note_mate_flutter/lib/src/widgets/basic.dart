// /// Generated by mate_flutter, please don't edit! Created time: 2023-03-11 13:17:26.187284

import 'package:flutter/src/widgets/basic.dart';
import 'package:flutter/src/foundation/key.dart';
import 'dart:ui';
import 'package:flutter/src/widgets/framework.dart';
import 'dart:core';
import 'package:flutter/src/rendering/proxy_box.dart';
import 'package:flutter/src/rendering/custom_paint.dart';
import 'package:flutter/src/painting/border_radius.dart';
import 'package:flutter/src/painting/box_border.dart';
import 'package:vector_math/vector_math_64.dart';
import 'package:flutter/src/painting/alignment.dart';
import 'package:flutter/src/rendering/layer.dart';
import 'package:flutter/src/painting/box_fit.dart';
import 'package:flutter/src/painting/edge_insets.dart';
import 'package:flutter/src/rendering/shifted_box.dart';
import 'package:flutter/src/rendering/custom_layout.dart';
import 'package:flutter/src/rendering/box.dart';
import 'package:flutter/src/painting/basic_types.dart';
import 'package:flutter/src/rendering/stack.dart';
import 'package:flutter/src/rendering/flex.dart';
import 'package:flutter/src/rendering/wrap.dart';
import 'package:flutter/src/rendering/flow.dart';
import 'package:flutter/src/painting/inline_span.dart';
import 'package:flutter/src/painting/text_painter.dart';
import 'package:flutter/src/painting/strut_style.dart';
import 'package:flutter/src/rendering/selection.dart';
import 'package:flutter/src/animation/animation.dart';
import 'package:flutter/src/painting/decoration_image.dart';
import 'package:flutter/src/services/asset_bundle.dart';
import 'package:flutter/src/services/mouse_tracking.dart';
import 'package:flutter/src/services/mouse_cursor.dart';
import 'package:flutter/src/semantics/semantics.dart';
export 'package:flutter/animation.dart';
export 'package:flutter/foundation.dart'
    show ChangeNotifier, FlutterErrorDetails, Listenable, TargetPlatform, ValueNotifier;
export 'package:flutter/painting.dart';
export 'package:flutter/rendering.dart'
    show
        AlignmentGeometryTween,
        AlignmentTween,
        Axis,
        BoxConstraints,
        BoxConstraintsTransform,
        CrossAxisAlignment,
        CustomClipper,
        CustomPainter,
        CustomPainterSemantics,
        DecorationPosition,
        FlexFit,
        FlowDelegate,
        FlowPaintingContext,
        FractionalOffsetTween,
        HitTestBehavior,
        LayerLink,
        MainAxisAlignment,
        MainAxisSize,
        MouseCursor,
        MultiChildLayoutDelegate,
        PaintingContext,
        PointerCancelEvent,
        PointerCancelEventListener,
        PointerDownEvent,
        PointerDownEventListener,
        PointerEvent,
        PointerMoveEvent,
        PointerMoveEventListener,
        PointerUpEvent,
        PointerUpEventListener,
        RelativeRect,
        SemanticsBuilderCallback,
        ShaderCallback,
        ShapeBorderClipper,
        SingleChildLayoutDelegate,
        StackFit,
        SystemMouseCursors,
        TextOverflow,
        ValueChanged,
        ValueGetter,
        WrapAlignment,
        WrapCrossAlignment;
export 'package:flutter/services.dart' show AssetBundle;

/// class Directionality extends _UbiquitousInheritedWidget
class Directionality$Mate extends Directionality {
  /// Directionality Directionality({Key? key, required TextDirection textDirection, required Widget child})
  Directionality$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required TextDirection textDirection}
    required TextDirection textDirection,

    /// param: {required Widget child}
    required Widget child,
  }) : super(
          key: key,
          textDirection: textDirection,
          child: child,
        ) {}
}

/// class Opacity extends SingleChildRenderObjectWidget
class Opacity$Mate extends Opacity {
  /// Opacity Opacity({Key? key, required double opacity, bool alwaysIncludeSemantics = false, Widget? child})
  Opacity$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required double opacity}
    required double opacity,

    /// param: {bool alwaysIncludeSemantics = false}
    required bool alwaysIncludeSemantics,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          opacity: opacity,
          alwaysIncludeSemantics: alwaysIncludeSemantics,
          child: child,
        ) {}
}

/// class ShaderMask extends SingleChildRenderObjectWidget
class ShaderMask$Mate extends ShaderMask {
  /// ShaderMask ShaderMask({Key? key, required Shader Function(Rect) shaderCallback, BlendMode blendMode = BlendMode.modulate, Widget? child})
  ShaderMask$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required Shader Function(Rect) shaderCallback}
    required ShaderCallback shaderCallback,

    /// param: {BlendMode blendMode = BlendMode.modulate}
    required BlendMode blendMode,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          shaderCallback: shaderCallback,
          blendMode: blendMode,
          child: child,
        ) {}
}

/// class BackdropFilter extends SingleChildRenderObjectWidget
class BackdropFilter$Mate extends BackdropFilter {
  /// BackdropFilter BackdropFilter({Key? key, required ImageFilter filter, Widget? child, BlendMode blendMode = BlendMode.srcOver})
  BackdropFilter$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required ImageFilter filter}
    required ImageFilter filter,

    /// param: {Widget? child}
    Widget? child,

    /// param: {BlendMode blendMode = BlendMode.srcOver}
    required BlendMode blendMode,
  }) : super(
          key: key,
          filter: filter,
          child: child,
          blendMode: blendMode,
        ) {}
}

/// class CustomPaint extends SingleChildRenderObjectWidget
class CustomPaint$Mate extends CustomPaint {
  /// CustomPaint CustomPaint({Key? key, CustomPainter? painter, CustomPainter? foregroundPainter, Size size = Size.zero, bool isComplex = false, bool willChange = false, Widget? child})
  CustomPaint$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {CustomPainter? painter}
    CustomPainter? painter,

    /// param: {CustomPainter? foregroundPainter}
    CustomPainter? foregroundPainter,

    /// param: {Size size = Size.zero}
    required Size size,

    /// param: {bool isComplex = false}
    required bool isComplex,

    /// param: {bool willChange = false}
    required bool willChange,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          painter: painter,
          foregroundPainter: foregroundPainter,
          size: size,
          isComplex: isComplex,
          willChange: willChange,
          child: child,
        ) {}
}

/// class ClipRect extends SingleChildRenderObjectWidget
class ClipRect$Mate extends ClipRect {
  /// ClipRect ClipRect({Key? key, CustomClipper<Rect>? clipper, Clip clipBehavior = Clip.hardEdge, Widget? child})
  ClipRect$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {CustomClipper<Rect>? clipper}
    CustomClipper<Rect>? clipper,

    /// param: {Clip clipBehavior = Clip.hardEdge}
    required Clip clipBehavior,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          clipper: clipper,
          clipBehavior: clipBehavior,
          child: child,
        ) {}
}

/// class ClipRRect extends SingleChildRenderObjectWidget
class ClipRRect$Mate extends ClipRRect {
  /// ClipRRect ClipRRect({Key? key, BorderRadiusGeometry? borderRadius = BorderRadius.zero, CustomClipper<RRect>? clipper, Clip clipBehavior = Clip.antiAlias, Widget? child})
  ClipRRect$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {BorderRadiusGeometry? borderRadius = BorderRadius.zero}
    BorderRadiusGeometry? borderRadius,

    /// param: {CustomClipper<RRect>? clipper}
    CustomClipper<RRect>? clipper,

    /// param: {Clip clipBehavior = Clip.antiAlias}
    required Clip clipBehavior,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          borderRadius: borderRadius,
          clipper: clipper,
          clipBehavior: clipBehavior,
          child: child,
        ) {}
}

/// class ClipOval extends SingleChildRenderObjectWidget
class ClipOval$Mate extends ClipOval {
  /// ClipOval ClipOval({Key? key, CustomClipper<Rect>? clipper, Clip clipBehavior = Clip.antiAlias, Widget? child})
  ClipOval$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {CustomClipper<Rect>? clipper}
    CustomClipper<Rect>? clipper,

    /// param: {Clip clipBehavior = Clip.antiAlias}
    required Clip clipBehavior,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          clipper: clipper,
          clipBehavior: clipBehavior,
          child: child,
        ) {}
}

/// class ClipPath extends SingleChildRenderObjectWidget
class ClipPath$Mate extends ClipPath {
  /// ClipPath ClipPath({Key? key, CustomClipper<Path>? clipper, Clip clipBehavior = Clip.antiAlias, Widget? child})
  ClipPath$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {CustomClipper<Path>? clipper}
    CustomClipper<Path>? clipper,

    /// param: {Clip clipBehavior = Clip.antiAlias}
    required Clip clipBehavior,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          clipper: clipper,
          clipBehavior: clipBehavior,
          child: child,
        ) {}
}

/// class PhysicalModel extends SingleChildRenderObjectWidget
class PhysicalModel$Mate extends PhysicalModel {
  /// PhysicalModel PhysicalModel({Key? key, BoxShape shape = BoxShape.rectangle, Clip clipBehavior = Clip.none, BorderRadius? borderRadius, double elevation = 0.0, required Color color, Color shadowColor = const Color(0xFF000000), Widget? child})
  PhysicalModel$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {BoxShape shape = BoxShape.rectangle}
    required BoxShape shape,

    /// param: {Clip clipBehavior = Clip.none}
    required Clip clipBehavior,

    /// param: {BorderRadius? borderRadius}
    BorderRadius? borderRadius,

    /// param: {double elevation = 0.0}
    required double elevation,

    /// param: {required Color color}
    required Color color,

    /// param: {Color shadowColor = const Color(0xFF000000)}
    required Color shadowColor,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          shape: shape,
          clipBehavior: clipBehavior,
          borderRadius: borderRadius,
          elevation: elevation,
          color: color,
          shadowColor: shadowColor,
          child: child,
        ) {}
}

/// class PhysicalShape extends SingleChildRenderObjectWidget
class PhysicalShape$Mate extends PhysicalShape {
  /// PhysicalShape PhysicalShape({Key? key, required CustomClipper<Path> clipper, Clip clipBehavior = Clip.none, double elevation = 0.0, required Color color, Color shadowColor = const Color(0xFF000000), Widget? child})
  PhysicalShape$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required CustomClipper<Path> clipper}
    required CustomClipper<Path> clipper,

    /// param: {Clip clipBehavior = Clip.none}
    required Clip clipBehavior,

    /// param: {double elevation = 0.0}
    required double elevation,

    /// param: {required Color color}
    required Color color,

    /// param: {Color shadowColor = const Color(0xFF000000)}
    required Color shadowColor,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          clipper: clipper,
          clipBehavior: clipBehavior,
          elevation: elevation,
          color: color,
          shadowColor: shadowColor,
          child: child,
        ) {}
}

/// class Transform extends SingleChildRenderObjectWidget
class Transform$Mate extends Transform {
  /// Transform Transform({Key? key, required Matrix4 transform, Offset? origin, AlignmentGeometry? alignment, bool transformHitTests = true, FilterQuality? filterQuality, Widget? child})
  Transform$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required Matrix4 transform}
    required Matrix4 transform,

    /// param: {Offset? origin}
    Offset? origin,

    /// param: {AlignmentGeometry? alignment}
    AlignmentGeometry? alignment,

    /// param: {bool transformHitTests = true}
    required bool transformHitTests,

    /// param: {FilterQuality? filterQuality}
    FilterQuality? filterQuality,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          transform: transform,
          origin: origin,
          alignment: alignment,
          transformHitTests: transformHitTests,
          filterQuality: filterQuality,
          child: child,
        ) {}

  /// Transform Transform.rotate({Key? key, required double angle, Offset? origin, AlignmentGeometry? alignment = Alignment.center, bool transformHitTests = true, FilterQuality? filterQuality, Widget? child})
  Transform$Mate.rotate({
    /// param: {Key? key}
    Key? key,

    /// param: {required double angle}
    required double angle,

    /// param: {Offset? origin}
    Offset? origin,

    /// param: {AlignmentGeometry? alignment = Alignment.center}
    AlignmentGeometry? alignment,

    /// param: {bool transformHitTests = true}
    required bool transformHitTests,

    /// param: {FilterQuality? filterQuality}
    FilterQuality? filterQuality,

    /// param: {Widget? child}
    Widget? child,
  }) : super.rotate(
          key: key,
          angle: angle,
          origin: origin,
          alignment: alignment,
          transformHitTests: transformHitTests,
          filterQuality: filterQuality,
          child: child,
        ) {}

  /// Transform Transform.translate({Key? key, required Offset offset, bool transformHitTests = true, FilterQuality? filterQuality, Widget? child})
  Transform$Mate.translate({
    /// param: {Key? key}
    Key? key,

    /// param: {required Offset offset}
    required Offset offset,

    /// param: {bool transformHitTests = true}
    required bool transformHitTests,

    /// param: {FilterQuality? filterQuality}
    FilterQuality? filterQuality,

    /// param: {Widget? child}
    Widget? child,
  }) : super.translate(
          key: key,
          offset: offset,
          transformHitTests: transformHitTests,
          filterQuality: filterQuality,
          child: child,
        ) {}

  /// Transform Transform.scale({Key? key, double? scale, double? scaleX, double? scaleY, Offset? origin, AlignmentGeometry? alignment = Alignment.center, bool transformHitTests = true, FilterQuality? filterQuality, Widget? child})
  Transform$Mate.scale({
    /// param: {Key? key}
    Key? key,

    /// param: {double? scale}
    double? scale,

    /// param: {double? scaleX}
    double? scaleX,

    /// param: {double? scaleY}
    double? scaleY,

    /// param: {Offset? origin}
    Offset? origin,

    /// param: {AlignmentGeometry? alignment = Alignment.center}
    AlignmentGeometry? alignment,

    /// param: {bool transformHitTests = true}
    required bool transformHitTests,

    /// param: {FilterQuality? filterQuality}
    FilterQuality? filterQuality,

    /// param: {Widget? child}
    Widget? child,
  }) : super.scale(
          key: key,
          scale: scale,
          scaleX: scaleX,
          scaleY: scaleY,
          origin: origin,
          alignment: alignment,
          transformHitTests: transformHitTests,
          filterQuality: filterQuality,
          child: child,
        ) {}

  /// Transform Transform.flip({Key? key, bool flipX = false, bool flipY = false, Offset? origin, bool transformHitTests = true, FilterQuality? filterQuality, Widget? child})
  Transform$Mate.flip({
    /// param: {Key? key}
    Key? key,

    /// param: {bool flipX = false}
    required bool flipX,

    /// param: {bool flipY = false}
    required bool flipY,

    /// param: {Offset? origin}
    Offset? origin,

    /// param: {bool transformHitTests = true}
    required bool transformHitTests,

    /// param: {FilterQuality? filterQuality}
    FilterQuality? filterQuality,

    /// param: {Widget? child}
    Widget? child,
  }) : super.flip(
          key: key,
          flipX: flipX,
          flipY: flipY,
          origin: origin,
          transformHitTests: transformHitTests,
          filterQuality: filterQuality,
          child: child,
        ) {}
}

/// class CompositedTransformTarget extends SingleChildRenderObjectWidget
class CompositedTransformTarget$Mate extends CompositedTransformTarget {
  /// CompositedTransformTarget CompositedTransformTarget({Key? key, required LayerLink link, Widget? child})
  CompositedTransformTarget$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required LayerLink link}
    required LayerLink link,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          link: link,
          child: child,
        ) {}
}

/// class CompositedTransformFollower extends SingleChildRenderObjectWidget
class CompositedTransformFollower$Mate extends CompositedTransformFollower {
  /// CompositedTransformFollower CompositedTransformFollower({Key? key, required LayerLink link, bool showWhenUnlinked = true, Offset offset = Offset.zero, Alignment targetAnchor = Alignment.topLeft, Alignment followerAnchor = Alignment.topLeft, Widget? child})
  CompositedTransformFollower$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required LayerLink link}
    required LayerLink link,

    /// param: {bool showWhenUnlinked = true}
    required bool showWhenUnlinked,

    /// param: {Offset offset = Offset.zero}
    required Offset offset,

    /// param: {Alignment targetAnchor = Alignment.topLeft}
    required Alignment targetAnchor,

    /// param: {Alignment followerAnchor = Alignment.topLeft}
    required Alignment followerAnchor,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          link: link,
          showWhenUnlinked: showWhenUnlinked,
          offset: offset,
          targetAnchor: targetAnchor,
          followerAnchor: followerAnchor,
          child: child,
        ) {}
}

/// class FittedBox extends SingleChildRenderObjectWidget
class FittedBox$Mate extends FittedBox {
  /// FittedBox FittedBox({Key? key, BoxFit fit = BoxFit.contain, AlignmentGeometry alignment = Alignment.center, Clip clipBehavior = Clip.none, Widget? child})
  FittedBox$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {BoxFit fit = BoxFit.contain}
    required BoxFit fit,

    /// param: {AlignmentGeometry alignment = Alignment.center}
    required AlignmentGeometry alignment,

    /// param: {Clip clipBehavior = Clip.none}
    required Clip clipBehavior,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          fit: fit,
          alignment: alignment,
          clipBehavior: clipBehavior,
          child: child,
        ) {}
}

/// class FractionalTranslation extends SingleChildRenderObjectWidget
class FractionalTranslation$Mate extends FractionalTranslation {
  /// FractionalTranslation FractionalTranslation({Key? key, required Offset translation, bool transformHitTests = true, Widget? child})
  FractionalTranslation$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required Offset translation}
    required Offset translation,

    /// param: {bool transformHitTests = true}
    required bool transformHitTests,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          translation: translation,
          transformHitTests: transformHitTests,
          child: child,
        ) {}
}

/// class RotatedBox extends SingleChildRenderObjectWidget
class RotatedBox$Mate extends RotatedBox {
  /// RotatedBox RotatedBox({Key? key, required int quarterTurns, Widget? child})
  RotatedBox$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required int quarterTurns}
    required int quarterTurns,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          quarterTurns: quarterTurns,
          child: child,
        ) {}
}

/// class Padding extends SingleChildRenderObjectWidget
class Padding$Mate extends Padding {
  /// Padding Padding({Key? key, required EdgeInsetsGeometry padding, Widget? child})
  Padding$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required EdgeInsetsGeometry padding}
    required EdgeInsetsGeometry padding,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          padding: padding,
          child: child,
        ) {}
}

/// class Align extends SingleChildRenderObjectWidget
class Align$Mate extends Align {
  /// Align Align({Key? key, AlignmentGeometry alignment = Alignment.center, double? widthFactor, double? heightFactor, Widget? child})
  Align$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {AlignmentGeometry alignment = Alignment.center}
    required AlignmentGeometry alignment,

    /// param: {double? widthFactor}
    double? widthFactor,

    /// param: {double? heightFactor}
    double? heightFactor,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          alignment: alignment,
          widthFactor: widthFactor,
          heightFactor: heightFactor,
          child: child,
        ) {}
}

/// class Center extends Align
class Center$Mate extends Center {
  /// Center Center({Key? key, double? widthFactor, double? heightFactor, Widget? child})
  Center$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {double? widthFactor}
    double? widthFactor,

    /// param: {double? heightFactor}
    double? heightFactor,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          widthFactor: widthFactor,
          heightFactor: heightFactor,
          child: child,
        ) {}
}

/// class CustomSingleChildLayout extends SingleChildRenderObjectWidget
class CustomSingleChildLayout$Mate extends CustomSingleChildLayout {
  /// CustomSingleChildLayout CustomSingleChildLayout({Key? key, required SingleChildLayoutDelegate delegate, Widget? child})
  CustomSingleChildLayout$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required SingleChildLayoutDelegate delegate}
    required SingleChildLayoutDelegate delegate,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          delegate: delegate,
          child: child,
        ) {}
}

/// class LayoutId extends ParentDataWidget<MultiChildLayoutParentData>
class LayoutId$Mate extends LayoutId {
  /// LayoutId LayoutId({Key? key, required Object id, required Widget child})
  LayoutId$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required Object id}
    required Object id,

    /// param: {required Widget child}
    required Widget child,
  }) : super(
          key: key,
          id: id,
          child: child,
        ) {}
}

/// class CustomMultiChildLayout extends MultiChildRenderObjectWidget
class CustomMultiChildLayout$Mate extends CustomMultiChildLayout {
  /// CustomMultiChildLayout CustomMultiChildLayout({Key? key, required MultiChildLayoutDelegate delegate, List<Widget> children = const <Widget>[]})
  CustomMultiChildLayout$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required MultiChildLayoutDelegate delegate}
    required MultiChildLayoutDelegate delegate,

    /// param: {List<Widget> children = const <Widget>[]}
    required List<Widget> children,
  }) : super(
          key: key,
          delegate: delegate,
          children: children,
        ) {}
}

/// class SizedBox extends SingleChildRenderObjectWidget
class SizedBox$Mate extends SizedBox {
  /// SizedBox SizedBox({Key? key, double? width, double? height, Widget? child})
  SizedBox$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {double? width}
    double? width,

    /// param: {double? height}
    double? height,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          width: width,
          height: height,
          child: child,
        ) {}

  /// SizedBox SizedBox.expand({Key? key, Widget? child})
  SizedBox$Mate.expand({
    /// param: {Key? key}
    Key? key,

    /// param: {Widget? child}
    Widget? child,
  }) : super.expand(
          key: key,
          child: child,
        ) {}

  /// SizedBox SizedBox.shrink({Key? key, Widget? child})
  SizedBox$Mate.shrink({
    /// param: {Key? key}
    Key? key,

    /// param: {Widget? child}
    Widget? child,
  }) : super.shrink(
          key: key,
          child: child,
        ) {}

  /// SizedBox SizedBox.fromSize({Key? key, Widget? child, Size? size})
  SizedBox$Mate.fromSize({
    /// param: {Key? key}
    Key? key,

    /// param: {Widget? child}
    Widget? child,

    /// param: {Size? size}
    Size? size,
  }) : super.fromSize(
          key: key,
          child: child,
          size: size,
        ) {}

  /// SizedBox SizedBox.square({Key? key, Widget? child, double? dimension})
  SizedBox$Mate.square({
    /// param: {Key? key}
    Key? key,

    /// param: {Widget? child}
    Widget? child,

    /// param: {double? dimension}
    double? dimension,
  }) : super.square(
          key: key,
          child: child,
          dimension: dimension,
        ) {}
}

/// class ConstrainedBox extends SingleChildRenderObjectWidget
class ConstrainedBox$Mate extends ConstrainedBox {
  /// ConstrainedBox ConstrainedBox({Key? key, required BoxConstraints constraints, Widget? child})
  ConstrainedBox$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required BoxConstraints constraints}
    required BoxConstraints constraints,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          constraints: constraints,
          child: child,
        ) {}
}

/// class ConstraintsTransformBox extends SingleChildRenderObjectWidget
class ConstraintsTransformBox$Mate extends ConstraintsTransformBox {
  /// ConstraintsTransformBox ConstraintsTransformBox({Key? key, Widget? child, TextDirection? textDirection, AlignmentGeometry alignment = Alignment.center, required BoxConstraints Function(BoxConstraints) constraintsTransform, Clip clipBehavior = Clip.none, String debugTransformType = ''})
  ConstraintsTransformBox$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {Widget? child}
    Widget? child,

    /// param: {TextDirection? textDirection}
    TextDirection? textDirection,

    /// param: {AlignmentGeometry alignment = Alignment.center}
    required AlignmentGeometry alignment,

    /// param: {required BoxConstraints Function(BoxConstraints) constraintsTransform}
    required BoxConstraintsTransform constraintsTransform,

    /// param: {Clip clipBehavior = Clip.none}
    required Clip clipBehavior,

    /// param: {String debugTransformType = ''}
    required String debugTransformType,
  }) : super(
          key: key,
          child: child,
          textDirection: textDirection,
          alignment: alignment,
          constraintsTransform: constraintsTransform,
          clipBehavior: clipBehavior,
          debugTransformType: debugTransformType,
        ) {}
}

/// class UnconstrainedBox extends StatelessWidget
class UnconstrainedBox$Mate extends UnconstrainedBox {
  /// UnconstrainedBox UnconstrainedBox({Key? key, Widget? child, TextDirection? textDirection, AlignmentGeometry alignment = Alignment.center, Axis? constrainedAxis, Clip clipBehavior = Clip.none})
  UnconstrainedBox$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {Widget? child}
    Widget? child,

    /// param: {TextDirection? textDirection}
    TextDirection? textDirection,

    /// param: {AlignmentGeometry alignment = Alignment.center}
    required AlignmentGeometry alignment,

    /// param: {Axis? constrainedAxis}
    Axis? constrainedAxis,

    /// param: {Clip clipBehavior = Clip.none}
    required Clip clipBehavior,
  }) : super(
          key: key,
          child: child,
          textDirection: textDirection,
          alignment: alignment,
          constrainedAxis: constrainedAxis,
          clipBehavior: clipBehavior,
        ) {}
}

/// class FractionallySizedBox extends SingleChildRenderObjectWidget
class FractionallySizedBox$Mate extends FractionallySizedBox {
  /// FractionallySizedBox FractionallySizedBox({Key? key, AlignmentGeometry alignment = Alignment.center, double? widthFactor, double? heightFactor, Widget? child})
  FractionallySizedBox$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {AlignmentGeometry alignment = Alignment.center}
    required AlignmentGeometry alignment,

    /// param: {double? widthFactor}
    double? widthFactor,

    /// param: {double? heightFactor}
    double? heightFactor,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          alignment: alignment,
          widthFactor: widthFactor,
          heightFactor: heightFactor,
          child: child,
        ) {}
}

/// class LimitedBox extends SingleChildRenderObjectWidget
class LimitedBox$Mate extends LimitedBox {
  /// LimitedBox LimitedBox({Key? key, double maxWidth = double.infinity, double maxHeight = double.infinity, Widget? child})
  LimitedBox$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {double maxWidth = double.infinity}
    required double maxWidth,

    /// param: {double maxHeight = double.infinity}
    required double maxHeight,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          maxWidth: maxWidth,
          maxHeight: maxHeight,
          child: child,
        ) {}
}

/// class OverflowBox extends SingleChildRenderObjectWidget
class OverflowBox$Mate extends OverflowBox {
  /// OverflowBox OverflowBox({Key? key, AlignmentGeometry alignment = Alignment.center, double? minWidth, double? maxWidth, double? minHeight, double? maxHeight, Widget? child})
  OverflowBox$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {AlignmentGeometry alignment = Alignment.center}
    required AlignmentGeometry alignment,

    /// param: {double? minWidth}
    double? minWidth,

    /// param: {double? maxWidth}
    double? maxWidth,

    /// param: {double? minHeight}
    double? minHeight,

    /// param: {double? maxHeight}
    double? maxHeight,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          alignment: alignment,
          minWidth: minWidth,
          maxWidth: maxWidth,
          minHeight: minHeight,
          maxHeight: maxHeight,
          child: child,
        ) {}
}

/// class SizedOverflowBox extends SingleChildRenderObjectWidget
class SizedOverflowBox$Mate extends SizedOverflowBox {
  /// SizedOverflowBox SizedOverflowBox({Key? key, required Size size, AlignmentGeometry alignment = Alignment.center, Widget? child})
  SizedOverflowBox$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required Size size}
    required Size size,

    /// param: {AlignmentGeometry alignment = Alignment.center}
    required AlignmentGeometry alignment,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          size: size,
          alignment: alignment,
          child: child,
        ) {}
}

/// class Offstage extends SingleChildRenderObjectWidget
class Offstage$Mate extends Offstage {
  /// Offstage Offstage({Key? key, bool offstage = true, Widget? child})
  Offstage$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {bool offstage = true}
    required bool offstage,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          offstage: offstage,
          child: child,
        ) {}
}

/// class AspectRatio extends SingleChildRenderObjectWidget
class AspectRatio$Mate extends AspectRatio {
  /// AspectRatio AspectRatio({Key? key, required double aspectRatio, Widget? child})
  AspectRatio$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required double aspectRatio}
    required double aspectRatio,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          aspectRatio: aspectRatio,
          child: child,
        ) {}
}

/// class IntrinsicWidth extends SingleChildRenderObjectWidget
class IntrinsicWidth$Mate extends IntrinsicWidth {
  /// IntrinsicWidth IntrinsicWidth({Key? key, double? stepWidth, double? stepHeight, Widget? child})
  IntrinsicWidth$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {double? stepWidth}
    double? stepWidth,

    /// param: {double? stepHeight}
    double? stepHeight,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          stepWidth: stepWidth,
          stepHeight: stepHeight,
          child: child,
        ) {}
}

/// class IntrinsicHeight extends SingleChildRenderObjectWidget
class IntrinsicHeight$Mate extends IntrinsicHeight {
  /// IntrinsicHeight IntrinsicHeight({Key? key, Widget? child})
  IntrinsicHeight$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          child: child,
        ) {}
}

/// class Baseline extends SingleChildRenderObjectWidget
class Baseline$Mate extends Baseline {
  /// Baseline Baseline({Key? key, required double baseline, required TextBaseline baselineType, Widget? child})
  Baseline$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required double baseline}
    required double baseline,

    /// param: {required TextBaseline baselineType}
    required TextBaseline baselineType,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          baseline: baseline,
          baselineType: baselineType,
          child: child,
        ) {}
}

/// class SliverToBoxAdapter extends SingleChildRenderObjectWidget
class SliverToBoxAdapter$Mate extends SliverToBoxAdapter {
  /// SliverToBoxAdapter SliverToBoxAdapter({Key? key, Widget? child})
  SliverToBoxAdapter$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          child: child,
        ) {}
}

/// class SliverPadding extends SingleChildRenderObjectWidget
class SliverPadding$Mate extends SliverPadding {
  /// SliverPadding SliverPadding({Key? key, required EdgeInsetsGeometry padding, Widget? sliver})
  SliverPadding$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required EdgeInsetsGeometry padding}
    required EdgeInsetsGeometry padding,

    /// param: {Widget? sliver}
    Widget? sliver,
  }) : super(
          key: key,
          padding: padding,
          sliver: sliver,
        ) {}
}

/// class ListBody extends MultiChildRenderObjectWidget
class ListBody$Mate extends ListBody {
  /// ListBody ListBody({Key? key, Axis mainAxis = Axis.vertical, bool reverse = false, List<Widget> children = const <Widget>[]})
  ListBody$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {Axis mainAxis = Axis.vertical}
    required Axis mainAxis,

    /// param: {bool reverse = false}
    required bool reverse,

    /// param: {List<Widget> children = const <Widget>[]}
    required List<Widget> children,
  }) : super(
          key: key,
          mainAxis: mainAxis,
          reverse: reverse,
          children: children,
        ) {}
}

/// class Stack extends MultiChildRenderObjectWidget
class Stack$Mate extends Stack {
  /// Stack Stack({Key? key, AlignmentGeometry alignment = AlignmentDirectional.topStart, TextDirection? textDirection, StackFit fit = StackFit.loose, Clip clipBehavior = Clip.hardEdge, List<Widget> children = const <Widget>[]})
  Stack$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {AlignmentGeometry alignment = AlignmentDirectional.topStart}
    required AlignmentGeometry alignment,

    /// param: {TextDirection? textDirection}
    TextDirection? textDirection,

    /// param: {StackFit fit = StackFit.loose}
    required StackFit fit,

    /// param: {Clip clipBehavior = Clip.hardEdge}
    required Clip clipBehavior,

    /// param: {List<Widget> children = const <Widget>[]}
    required List<Widget> children,
  }) : super(
          key: key,
          alignment: alignment,
          textDirection: textDirection,
          fit: fit,
          clipBehavior: clipBehavior,
          children: children,
        ) {}
}

/// class IndexedStack extends Stack
class IndexedStack$Mate extends IndexedStack {
  /// IndexedStack IndexedStack({Key? key, AlignmentGeometry alignment = AlignmentDirectional.topStart, TextDirection? textDirection, Clip clipBehavior = Clip.hardEdge, StackFit sizing = StackFit.loose, int? index = 0, List<Widget> children = const <Widget>[]})
  IndexedStack$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {AlignmentGeometry alignment = AlignmentDirectional.topStart}
    required AlignmentGeometry alignment,

    /// param: {TextDirection? textDirection}
    TextDirection? textDirection,

    /// param: {Clip clipBehavior = Clip.hardEdge}
    required Clip clipBehavior,

    /// param: {StackFit sizing = StackFit.loose}
    required StackFit sizing,

    /// param: {int? index = 0}
    int? index,

    /// param: {List<Widget> children = const <Widget>[]}
    required List<Widget> children,
  }) : super(
          key: key,
          alignment: alignment,
          textDirection: textDirection,
          clipBehavior: clipBehavior,
          sizing: sizing,
          index: index,
          children: children,
        ) {}
}

/// class Positioned extends ParentDataWidget<StackParentData>
class Positioned$Mate extends Positioned {
  /// Positioned Positioned({Key? key, double? left, double? top, double? right, double? bottom, double? width, double? height, required Widget child})
  Positioned$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {double? left}
    double? left,

    /// param: {double? top}
    double? top,

    /// param: {double? right}
    double? right,

    /// param: {double? bottom}
    double? bottom,

    /// param: {double? width}
    double? width,

    /// param: {double? height}
    double? height,

    /// param: {required Widget child}
    required Widget child,
  }) : super(
          key: key,
          left: left,
          top: top,
          right: right,
          bottom: bottom,
          width: width,
          height: height,
          child: child,
        ) {}

  /// Positioned Positioned.fromRect({Key? key, required Rect rect, required Widget child})
  Positioned$Mate.fromRect({
    /// param: {Key? key}
    Key? key,

    /// param: {required Rect rect}
    required Rect rect,

    /// param: {required Widget child}
    required Widget child,
  }) : super.fromRect(
          key: key,
          rect: rect,
          child: child,
        ) {}

  /// Positioned Positioned.fromRelativeRect({Key? key, required RelativeRect rect, required Widget child})
  Positioned$Mate.fromRelativeRect({
    /// param: {Key? key}
    Key? key,

    /// param: {required RelativeRect rect}
    required RelativeRect rect,

    /// param: {required Widget child}
    required Widget child,
  }) : super.fromRelativeRect(
          key: key,
          rect: rect,
          child: child,
        ) {}

  /// Positioned Positioned.fill({Key? key, double? left = 0.0, double? top = 0.0, double? right = 0.0, double? bottom = 0.0, required Widget child})
  Positioned$Mate.fill({
    /// param: {Key? key}
    Key? key,

    /// param: {double? left = 0.0}
    double? left,

    /// param: {double? top = 0.0}
    double? top,

    /// param: {double? right = 0.0}
    double? right,

    /// param: {double? bottom = 0.0}
    double? bottom,

    /// param: {required Widget child}
    required Widget child,
  }) : super.fill(
          key: key,
          left: left,
          top: top,
          right: right,
          bottom: bottom,
          child: child,
        ) {}
}

/// class PositionedDirectional extends StatelessWidget
class PositionedDirectional$Mate extends PositionedDirectional {
  /// PositionedDirectional PositionedDirectional({Key? key, double? start, double? top, double? end, double? bottom, double? width, double? height, required Widget child})
  PositionedDirectional$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {double? start}
    double? start,

    /// param: {double? top}
    double? top,

    /// param: {double? end}
    double? end,

    /// param: {double? bottom}
    double? bottom,

    /// param: {double? width}
    double? width,

    /// param: {double? height}
    double? height,

    /// param: {required Widget child}
    required Widget child,
  }) : super(
          key: key,
          start: start,
          top: top,
          end: end,
          bottom: bottom,
          width: width,
          height: height,
          child: child,
        ) {}
}

/// class Flex extends MultiChildRenderObjectWidget
class Flex$Mate extends Flex {
  /// Flex Flex({Key? key, required Axis direction, MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start, MainAxisSize mainAxisSize = MainAxisSize.max, CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center, TextDirection? textDirection, VerticalDirection verticalDirection = VerticalDirection.down, TextBaseline? textBaseline, Clip clipBehavior = Clip.none, List<Widget> children = const <Widget>[]})
  Flex$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required Axis direction}
    required Axis direction,

    /// param: {MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start}
    required MainAxisAlignment mainAxisAlignment,

    /// param: {MainAxisSize mainAxisSize = MainAxisSize.max}
    required MainAxisSize mainAxisSize,

    /// param: {CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center}
    required CrossAxisAlignment crossAxisAlignment,

    /// param: {TextDirection? textDirection}
    TextDirection? textDirection,

    /// param: {VerticalDirection verticalDirection = VerticalDirection.down}
    required VerticalDirection verticalDirection,

    /// param: {TextBaseline? textBaseline}
    TextBaseline? textBaseline,

    /// param: {Clip clipBehavior = Clip.none}
    required Clip clipBehavior,

    /// param: {List<Widget> children = const <Widget>[]}
    required List<Widget> children,
  }) : super(
          key: key,
          direction: direction,
          mainAxisAlignment: mainAxisAlignment,
          mainAxisSize: mainAxisSize,
          crossAxisAlignment: crossAxisAlignment,
          textDirection: textDirection,
          verticalDirection: verticalDirection,
          textBaseline: textBaseline,
          clipBehavior: clipBehavior,
          children: children,
        ) {}
}

/// class Row extends Flex
class Row$Mate extends Row {
  /// Row Row({Key? key, MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start, MainAxisSize mainAxisSize = MainAxisSize.max, CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center, TextDirection? textDirection, VerticalDirection verticalDirection = VerticalDirection.down, TextBaseline? textBaseline, List<Widget> children = const <Widget>[]})
  Row$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start}
    required MainAxisAlignment mainAxisAlignment,

    /// param: {MainAxisSize mainAxisSize = MainAxisSize.max}
    required MainAxisSize mainAxisSize,

    /// param: {CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center}
    required CrossAxisAlignment crossAxisAlignment,

    /// param: {TextDirection? textDirection}
    TextDirection? textDirection,

    /// param: {VerticalDirection verticalDirection = VerticalDirection.down}
    required VerticalDirection verticalDirection,

    /// param: {TextBaseline? textBaseline}
    TextBaseline? textBaseline,

    /// param: {List<Widget> children = const <Widget>[]}
    required List<Widget> children,
  }) : super(
          key: key,
          mainAxisAlignment: mainAxisAlignment,
          mainAxisSize: mainAxisSize,
          crossAxisAlignment: crossAxisAlignment,
          textDirection: textDirection,
          verticalDirection: verticalDirection,
          textBaseline: textBaseline,
          children: children,
        ) {}
}

/// class Column extends Flex
class Column$Mate extends Column {
  /// Column Column({Key? key, MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start, MainAxisSize mainAxisSize = MainAxisSize.max, CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center, TextDirection? textDirection, VerticalDirection verticalDirection = VerticalDirection.down, TextBaseline? textBaseline, List<Widget> children = const <Widget>[]})
  Column$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start}
    required MainAxisAlignment mainAxisAlignment,

    /// param: {MainAxisSize mainAxisSize = MainAxisSize.max}
    required MainAxisSize mainAxisSize,

    /// param: {CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center}
    required CrossAxisAlignment crossAxisAlignment,

    /// param: {TextDirection? textDirection}
    TextDirection? textDirection,

    /// param: {VerticalDirection verticalDirection = VerticalDirection.down}
    required VerticalDirection verticalDirection,

    /// param: {TextBaseline? textBaseline}
    TextBaseline? textBaseline,

    /// param: {List<Widget> children = const <Widget>[]}
    required List<Widget> children,
  }) : super(
          key: key,
          mainAxisAlignment: mainAxisAlignment,
          mainAxisSize: mainAxisSize,
          crossAxisAlignment: crossAxisAlignment,
          textDirection: textDirection,
          verticalDirection: verticalDirection,
          textBaseline: textBaseline,
          children: children,
        ) {}
}

/// class Flexible extends ParentDataWidget<FlexParentData>
class Flexible$Mate extends Flexible {
  /// Flexible Flexible({Key? key, int flex = 1, FlexFit fit = FlexFit.loose, required Widget child})
  Flexible$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {int flex = 1}
    required int flex,

    /// param: {FlexFit fit = FlexFit.loose}
    required FlexFit fit,

    /// param: {required Widget child}
    required Widget child,
  }) : super(
          key: key,
          flex: flex,
          fit: fit,
          child: child,
        ) {}
}

/// class Expanded extends Flexible
class Expanded$Mate extends Expanded {
  /// Expanded Expanded({Key? key, int flex = 1, required Widget child})
  Expanded$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {int flex = 1}
    required int flex,

    /// param: {required Widget child}
    required Widget child,
  }) : super(
          key: key,
          flex: flex,
          child: child,
        ) {}
}

/// class Wrap extends MultiChildRenderObjectWidget
class Wrap$Mate extends Wrap {
  /// Wrap Wrap({Key? key, Axis direction = Axis.horizontal, WrapAlignment alignment = WrapAlignment.start, double spacing = 0.0, WrapAlignment runAlignment = WrapAlignment.start, double runSpacing = 0.0, WrapCrossAlignment crossAxisAlignment = WrapCrossAlignment.start, TextDirection? textDirection, VerticalDirection verticalDirection = VerticalDirection.down, Clip clipBehavior = Clip.none, List<Widget> children = const <Widget>[]})
  Wrap$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {Axis direction = Axis.horizontal}
    required Axis direction,

    /// param: {WrapAlignment alignment = WrapAlignment.start}
    required WrapAlignment alignment,

    /// param: {double spacing = 0.0}
    required double spacing,

    /// param: {WrapAlignment runAlignment = WrapAlignment.start}
    required WrapAlignment runAlignment,

    /// param: {double runSpacing = 0.0}
    required double runSpacing,

    /// param: {WrapCrossAlignment crossAxisAlignment = WrapCrossAlignment.start}
    required WrapCrossAlignment crossAxisAlignment,

    /// param: {TextDirection? textDirection}
    TextDirection? textDirection,

    /// param: {VerticalDirection verticalDirection = VerticalDirection.down}
    required VerticalDirection verticalDirection,

    /// param: {Clip clipBehavior = Clip.none}
    required Clip clipBehavior,

    /// param: {List<Widget> children = const <Widget>[]}
    required List<Widget> children,
  }) : super(
          key: key,
          direction: direction,
          alignment: alignment,
          spacing: spacing,
          runAlignment: runAlignment,
          runSpacing: runSpacing,
          crossAxisAlignment: crossAxisAlignment,
          textDirection: textDirection,
          verticalDirection: verticalDirection,
          clipBehavior: clipBehavior,
          children: children,
        ) {}
}

/// class Flow extends MultiChildRenderObjectWidget
class Flow$Mate extends Flow {
  /// Flow Flow({Key? key, required FlowDelegate delegate, List<Widget> children = const <Widget>[], Clip clipBehavior = Clip.hardEdge})
  Flow$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required FlowDelegate delegate}
    required FlowDelegate delegate,

    /// param: {List<Widget> children = const <Widget>[]}
    required List<Widget> children,

    /// param: {Clip clipBehavior = Clip.hardEdge}
    required Clip clipBehavior,
  }) : super(
          key: key,
          delegate: delegate,
          children: children,
          clipBehavior: clipBehavior,
        ) {}

  /// Flow Flow.unwrapped({Key? key, required FlowDelegate delegate, List<Widget> children = const <Widget>[], Clip clipBehavior = Clip.hardEdge})
  Flow$Mate.unwrapped({
    /// param: {Key? key}
    Key? key,

    /// param: {required FlowDelegate delegate}
    required FlowDelegate delegate,

    /// param: {List<Widget> children = const <Widget>[]}
    required List<Widget> children,

    /// param: {Clip clipBehavior = Clip.hardEdge}
    required Clip clipBehavior,
  }) : super.unwrapped(
          key: key,
          delegate: delegate,
          children: children,
          clipBehavior: clipBehavior,
        ) {}
}

/// class RichText extends MultiChildRenderObjectWidget
class RichText$Mate extends RichText {
  /// RichText RichText({Key? key, required InlineSpan text, TextAlign textAlign = TextAlign.start, TextDirection? textDirection, bool softWrap = true, TextOverflow overflow = TextOverflow.clip, double textScaleFactor = 1.0, int? maxLines, Locale? locale, StrutStyle? strutStyle, TextWidthBasis textWidthBasis = TextWidthBasis.parent, TextHeightBehavior? textHeightBehavior, SelectionRegistrar? selectionRegistrar, Color? selectionColor})
  RichText$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required InlineSpan text}
    required InlineSpan text,

    /// param: {TextAlign textAlign = TextAlign.start}
    required TextAlign textAlign,

    /// param: {TextDirection? textDirection}
    TextDirection? textDirection,

    /// param: {bool softWrap = true}
    required bool softWrap,

    /// param: {TextOverflow overflow = TextOverflow.clip}
    required TextOverflow overflow,

    /// param: {double textScaleFactor = 1.0}
    required double textScaleFactor,

    /// param: {int? maxLines}
    int? maxLines,

    /// param: {Locale? locale}
    Locale? locale,

    /// param: {StrutStyle? strutStyle}
    StrutStyle? strutStyle,

    /// param: {TextWidthBasis textWidthBasis = TextWidthBasis.parent}
    required TextWidthBasis textWidthBasis,

    /// param: {TextHeightBehavior? textHeightBehavior}
    TextHeightBehavior? textHeightBehavior,

    /// param: {SelectionRegistrar? selectionRegistrar}
    SelectionRegistrar? selectionRegistrar,

    /// param: {Color? selectionColor}
    Color? selectionColor,
  }) : super(
          key: key,
          text: text,
          textAlign: textAlign,
          textDirection: textDirection,
          softWrap: softWrap,
          overflow: overflow,
          textScaleFactor: textScaleFactor,
          maxLines: maxLines,
          locale: locale,
          strutStyle: strutStyle,
          textWidthBasis: textWidthBasis,
          textHeightBehavior: textHeightBehavior,
          selectionRegistrar: selectionRegistrar,
          selectionColor: selectionColor,
        ) {}
}

/// class RawImage extends LeafRenderObjectWidget
class RawImage$Mate extends RawImage {
  /// RawImage RawImage({Key? key, Image? image, String? debugImageLabel, double? width, double? height, double scale = 1.0, Color? color, Animation<double>? opacity, BlendMode? colorBlendMode, BoxFit? fit, AlignmentGeometry alignment = Alignment.center, ImageRepeat repeat = ImageRepeat.noRepeat, Rect? centerSlice, bool matchTextDirection = false, bool invertColors = false, FilterQuality filterQuality = FilterQuality.low, bool isAntiAlias = false})
  RawImage$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {Image? image}
    Image? image,

    /// param: {String? debugImageLabel}
    String? debugImageLabel,

    /// param: {double? width}
    double? width,

    /// param: {double? height}
    double? height,

    /// param: {double scale = 1.0}
    required double scale,

    /// param: {Color? color}
    Color? color,

    /// param: {Animation<double>? opacity}
    Animation<double>? opacity,

    /// param: {BlendMode? colorBlendMode}
    BlendMode? colorBlendMode,

    /// param: {BoxFit? fit}
    BoxFit? fit,

    /// param: {AlignmentGeometry alignment = Alignment.center}
    required AlignmentGeometry alignment,

    /// param: {ImageRepeat repeat = ImageRepeat.noRepeat}
    required ImageRepeat repeat,

    /// param: {Rect? centerSlice}
    Rect? centerSlice,

    /// param: {bool matchTextDirection = false}
    required bool matchTextDirection,

    /// param: {bool invertColors = false}
    required bool invertColors,

    /// param: {FilterQuality filterQuality = FilterQuality.low}
    required FilterQuality filterQuality,

    /// param: {bool isAntiAlias = false}
    required bool isAntiAlias,
  }) : super(
          key: key,
          image: image,
          debugImageLabel: debugImageLabel,
          width: width,
          height: height,
          scale: scale,
          color: color,
          opacity: opacity,
          colorBlendMode: colorBlendMode,
          fit: fit,
          alignment: alignment,
          repeat: repeat,
          centerSlice: centerSlice,
          matchTextDirection: matchTextDirection,
          invertColors: invertColors,
          filterQuality: filterQuality,
          isAntiAlias: isAntiAlias,
        ) {}
}

/// class DefaultAssetBundle extends InheritedWidget
class DefaultAssetBundle$Mate extends DefaultAssetBundle {
  /// DefaultAssetBundle DefaultAssetBundle({Key? key, required AssetBundle bundle, required Widget child})
  DefaultAssetBundle$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required AssetBundle bundle}
    required AssetBundle bundle,

    /// param: {required Widget child}
    required Widget child,
  }) : super(
          key: key,
          bundle: bundle,
          child: child,
        ) {}
}

/// class WidgetToRenderBoxAdapter extends LeafRenderObjectWidget
class WidgetToRenderBoxAdapter$Mate extends WidgetToRenderBoxAdapter {
  /// WidgetToRenderBoxAdapter WidgetToRenderBoxAdapter({required RenderBox renderBox, void Function()? onBuild, void Function()? onUnmount})
  WidgetToRenderBoxAdapter$Mate({
    /// param: {required RenderBox renderBox}
    required RenderBox renderBox,

    /// param: {void Function()? onBuild}
    VoidCallback? onBuild,

    /// param: {void Function()? onUnmount}
    VoidCallback? onUnmount,
  }) : super(
          renderBox: renderBox,
          onBuild: onBuild,
          onUnmount: onUnmount,
        ) {}
}

/// class Listener extends SingleChildRenderObjectWidget
class Listener$Mate extends Listener {
  /// Listener Listener({Key? key, void Function(PointerDownEvent)? onPointerDown, void Function(PointerMoveEvent)? onPointerMove, void Function(PointerUpEvent)? onPointerUp, void Function(PointerHoverEvent)? onPointerHover, void Function(PointerCancelEvent)? onPointerCancel, void Function(PointerPanZoomStartEvent)? onPointerPanZoomStart, void Function(PointerPanZoomUpdateEvent)? onPointerPanZoomUpdate, void Function(PointerPanZoomEndEvent)? onPointerPanZoomEnd, void Function(PointerSignalEvent)? onPointerSignal, HitTestBehavior behavior = HitTestBehavior.deferToChild, Widget? child})
  Listener$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {void Function(PointerDownEvent)? onPointerDown}
    PointerDownEventListener? onPointerDown,

    /// param: {void Function(PointerMoveEvent)? onPointerMove}
    PointerMoveEventListener? onPointerMove,

    /// param: {void Function(PointerUpEvent)? onPointerUp}
    PointerUpEventListener? onPointerUp,

    /// param: {void Function(PointerHoverEvent)? onPointerHover}
    PointerHoverEventListener? onPointerHover,

    /// param: {void Function(PointerCancelEvent)? onPointerCancel}
    PointerCancelEventListener? onPointerCancel,

    /// param: {void Function(PointerPanZoomStartEvent)? onPointerPanZoomStart}
    PointerPanZoomStartEventListener? onPointerPanZoomStart,

    /// param: {void Function(PointerPanZoomUpdateEvent)? onPointerPanZoomUpdate}
    PointerPanZoomUpdateEventListener? onPointerPanZoomUpdate,

    /// param: {void Function(PointerPanZoomEndEvent)? onPointerPanZoomEnd}
    PointerPanZoomEndEventListener? onPointerPanZoomEnd,

    /// param: {void Function(PointerSignalEvent)? onPointerSignal}
    PointerSignalEventListener? onPointerSignal,

    /// param: {HitTestBehavior behavior = HitTestBehavior.deferToChild}
    required HitTestBehavior behavior,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          onPointerDown: onPointerDown,
          onPointerMove: onPointerMove,
          onPointerUp: onPointerUp,
          onPointerHover: onPointerHover,
          onPointerCancel: onPointerCancel,
          onPointerPanZoomStart: onPointerPanZoomStart,
          onPointerPanZoomUpdate: onPointerPanZoomUpdate,
          onPointerPanZoomEnd: onPointerPanZoomEnd,
          onPointerSignal: onPointerSignal,
          behavior: behavior,
          child: child,
        ) {}
}

/// class MouseRegion extends SingleChildRenderObjectWidget
class MouseRegion$Mate extends MouseRegion {
  /// MouseRegion MouseRegion({Key? key, void Function(PointerEnterEvent)? onEnter, void Function(PointerExitEvent)? onExit, void Function(PointerHoverEvent)? onHover, MouseCursor cursor = MouseCursor.defer, bool opaque = true, HitTestBehavior? hitTestBehavior, Widget? child})
  MouseRegion$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {void Function(PointerEnterEvent)? onEnter}
    PointerEnterEventListener? onEnter,

    /// param: {void Function(PointerExitEvent)? onExit}
    PointerExitEventListener? onExit,

    /// param: {void Function(PointerHoverEvent)? onHover}
    PointerHoverEventListener? onHover,

    /// param: {MouseCursor cursor = MouseCursor.defer}
    required MouseCursor cursor,

    /// param: {bool opaque = true}
    required bool opaque,

    /// param: {HitTestBehavior? hitTestBehavior}
    HitTestBehavior? hitTestBehavior,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          onEnter: onEnter,
          onExit: onExit,
          onHover: onHover,
          cursor: cursor,
          opaque: opaque,
          hitTestBehavior: hitTestBehavior,
          child: child,
        ) {}
}

/// class RepaintBoundary extends SingleChildRenderObjectWidget
class RepaintBoundary$Mate extends RepaintBoundary {
  /// RepaintBoundary RepaintBoundary({Key? key, Widget? child})
  RepaintBoundary$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          child: child,
        ) {}
}

/// class IgnorePointer extends SingleChildRenderObjectWidget
class IgnorePointer$Mate extends IgnorePointer {
  /// IgnorePointer IgnorePointer({Key? key, bool ignoring = true, bool? ignoringSemantics, Widget? child})
  IgnorePointer$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {bool ignoring = true}
    required bool ignoring,

    /// param: {bool? ignoringSemantics}
    bool? ignoringSemantics,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          ignoring: ignoring,
          ignoringSemantics: ignoringSemantics,
          child: child,
        ) {}
}

/// class AbsorbPointer extends SingleChildRenderObjectWidget
class AbsorbPointer$Mate extends AbsorbPointer {
  /// AbsorbPointer AbsorbPointer({Key? key, bool absorbing = true, Widget? child, bool? ignoringSemantics})
  AbsorbPointer$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {bool absorbing = true}
    required bool absorbing,

    /// param: {Widget? child}
    Widget? child,

    /// param: {bool? ignoringSemantics}
    bool? ignoringSemantics,
  }) : super(
          key: key,
          absorbing: absorbing,
          child: child,
          ignoringSemantics: ignoringSemantics,
        ) {}
}

/// class MetaData extends SingleChildRenderObjectWidget
class MetaData$Mate extends MetaData {
  /// MetaData MetaData({Key? key, dynamic metaData, HitTestBehavior behavior = HitTestBehavior.deferToChild, Widget? child})
  MetaData$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {dynamic metaData}
    required dynamic metaData,

    /// param: {HitTestBehavior behavior = HitTestBehavior.deferToChild}
    required HitTestBehavior behavior,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          metaData: metaData,
          behavior: behavior,
          child: child,
        ) {}
}

/// class Semantics extends SingleChildRenderObjectWidget
class Semantics$Mate extends Semantics {
  /// Semantics Semantics({Key? key, Widget? child, bool container = false, bool explicitChildNodes = false, bool excludeSemantics = false, bool? enabled, bool? checked, bool? mixed, bool? selected, bool? toggled, bool? button, bool? slider, bool? keyboardKey, bool? link, bool? header, bool? textField, bool? readOnly, bool? focusable, bool? focused, bool? inMutuallyExclusiveGroup, bool? obscured, bool? multiline, bool? scopesRoute, bool? namesRoute, bool? hidden, bool? image, bool? liveRegion, int? maxValueLength, int? currentValueLength, String? label, AttributedString? attributedLabel, String? value, AttributedString? attributedValue, String? increasedValue, AttributedString? attributedIncreasedValue, String? decreasedValue, AttributedString? attributedDecreasedValue, String? hint, AttributedString? attributedHint, String? tooltip, String? onTapHint, String? onLongPressHint, TextDirection? textDirection, SemanticsSortKey? sortKey, SemanticsTag? tagForChildren, void Function()? onTap, void Function()? onLongPress, void Function()? onScrollLeft, void Function()? onScrollRight, void Function()? onScrollUp, void Function()? onScrollDown, void Function()? onIncrease, void Function()? onDecrease, void Function()? onCopy, void Function()? onCut, void Function()? onPaste, void Function()? onDismiss, void Function(bool)? onMoveCursorForwardByCharacter, void Function(bool)? onMoveCursorBackwardByCharacter, void Function(TextSelection)? onSetSelection, void Function(String)? onSetText, void Function()? onDidGainAccessibilityFocus, void Function()? onDidLoseAccessibilityFocus, Map<CustomSemanticsAction, void Function()>? customSemanticsActions})
  Semantics$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {Widget? child}
    Widget? child,

    /// param: {bool container = false}
    required bool container,

    /// param: {bool explicitChildNodes = false}
    required bool explicitChildNodes,

    /// param: {bool excludeSemantics = false}
    required bool excludeSemantics,

    /// param: {bool? enabled}
    bool? enabled,

    /// param: {bool? checked}
    bool? checked,

    /// param: {bool? mixed}
    bool? mixed,

    /// param: {bool? selected}
    bool? selected,

    /// param: {bool? toggled}
    bool? toggled,

    /// param: {bool? button}
    bool? button,

    /// param: {bool? slider}
    bool? slider,

    /// param: {bool? keyboardKey}
    bool? keyboardKey,

    /// param: {bool? link}
    bool? link,

    /// param: {bool? header}
    bool? header,

    /// param: {bool? textField}
    bool? textField,

    /// param: {bool? readOnly}
    bool? readOnly,

    /// param: {bool? focusable}
    bool? focusable,

    /// param: {bool? focused}
    bool? focused,

    /// param: {bool? inMutuallyExclusiveGroup}
    bool? inMutuallyExclusiveGroup,

    /// param: {bool? obscured}
    bool? obscured,

    /// param: {bool? multiline}
    bool? multiline,

    /// param: {bool? scopesRoute}
    bool? scopesRoute,

    /// param: {bool? namesRoute}
    bool? namesRoute,

    /// param: {bool? hidden}
    bool? hidden,

    /// param: {bool? image}
    bool? image,

    /// param: {bool? liveRegion}
    bool? liveRegion,

    /// param: {int? maxValueLength}
    int? maxValueLength,

    /// param: {int? currentValueLength}
    int? currentValueLength,

    /// param: {String? label}
    String? label,

    /// param: {AttributedString? attributedLabel}
    AttributedString? attributedLabel,

    /// param: {String? value}
    String? value,

    /// param: {AttributedString? attributedValue}
    AttributedString? attributedValue,

    /// param: {String? increasedValue}
    String? increasedValue,

    /// param: {AttributedString? attributedIncreasedValue}
    AttributedString? attributedIncreasedValue,

    /// param: {String? decreasedValue}
    String? decreasedValue,

    /// param: {AttributedString? attributedDecreasedValue}
    AttributedString? attributedDecreasedValue,

    /// param: {String? hint}
    String? hint,

    /// param: {AttributedString? attributedHint}
    AttributedString? attributedHint,

    /// param: {String? tooltip}
    String? tooltip,

    /// param: {String? onTapHint}
    String? onTapHint,

    /// param: {String? onLongPressHint}
    String? onLongPressHint,

    /// param: {TextDirection? textDirection}
    TextDirection? textDirection,

    /// param: {SemanticsSortKey? sortKey}
    SemanticsSortKey? sortKey,

    /// param: {SemanticsTag? tagForChildren}
    SemanticsTag? tagForChildren,

    /// param: {void Function()? onTap}
    VoidCallback? onTap,

    /// param: {void Function()? onLongPress}
    VoidCallback? onLongPress,

    /// param: {void Function()? onScrollLeft}
    VoidCallback? onScrollLeft,

    /// param: {void Function()? onScrollRight}
    VoidCallback? onScrollRight,

    /// param: {void Function()? onScrollUp}
    VoidCallback? onScrollUp,

    /// param: {void Function()? onScrollDown}
    VoidCallback? onScrollDown,

    /// param: {void Function()? onIncrease}
    VoidCallback? onIncrease,

    /// param: {void Function()? onDecrease}
    VoidCallback? onDecrease,

    /// param: {void Function()? onCopy}
    VoidCallback? onCopy,

    /// param: {void Function()? onCut}
    VoidCallback? onCut,

    /// param: {void Function()? onPaste}
    VoidCallback? onPaste,

    /// param: {void Function()? onDismiss}
    VoidCallback? onDismiss,

    /// param: {void Function(bool)? onMoveCursorForwardByCharacter}
    MoveCursorHandler? onMoveCursorForwardByCharacter,

    /// param: {void Function(bool)? onMoveCursorBackwardByCharacter}
    MoveCursorHandler? onMoveCursorBackwardByCharacter,

    /// param: {void Function(TextSelection)? onSetSelection}
    SetSelectionHandler? onSetSelection,

    /// param: {void Function(String)? onSetText}
    SetTextHandler? onSetText,

    /// param: {void Function()? onDidGainAccessibilityFocus}
    VoidCallback? onDidGainAccessibilityFocus,

    /// param: {void Function()? onDidLoseAccessibilityFocus}
    VoidCallback? onDidLoseAccessibilityFocus,

    /// param: {Map<CustomSemanticsAction, void Function()>? customSemanticsActions}
    Map<CustomSemanticsAction, VoidCallback>? customSemanticsActions,
  }) : super(
          key: key,
          child: child,
          container: container,
          explicitChildNodes: explicitChildNodes,
          excludeSemantics: excludeSemantics,
          enabled: enabled,
          checked: checked,
          mixed: mixed,
          selected: selected,
          toggled: toggled,
          button: button,
          slider: slider,
          keyboardKey: keyboardKey,
          link: link,
          header: header,
          textField: textField,
          readOnly: readOnly,
          focusable: focusable,
          focused: focused,
          inMutuallyExclusiveGroup: inMutuallyExclusiveGroup,
          obscured: obscured,
          multiline: multiline,
          scopesRoute: scopesRoute,
          namesRoute: namesRoute,
          hidden: hidden,
          image: image,
          liveRegion: liveRegion,
          maxValueLength: maxValueLength,
          currentValueLength: currentValueLength,
          label: label,
          attributedLabel: attributedLabel,
          value: value,
          attributedValue: attributedValue,
          increasedValue: increasedValue,
          attributedIncreasedValue: attributedIncreasedValue,
          decreasedValue: decreasedValue,
          attributedDecreasedValue: attributedDecreasedValue,
          hint: hint,
          attributedHint: attributedHint,
          tooltip: tooltip,
          onTapHint: onTapHint,
          onLongPressHint: onLongPressHint,
          textDirection: textDirection,
          sortKey: sortKey,
          tagForChildren: tagForChildren,
          onTap: onTap,
          onLongPress: onLongPress,
          onScrollLeft: onScrollLeft,
          onScrollRight: onScrollRight,
          onScrollUp: onScrollUp,
          onScrollDown: onScrollDown,
          onIncrease: onIncrease,
          onDecrease: onDecrease,
          onCopy: onCopy,
          onCut: onCut,
          onPaste: onPaste,
          onDismiss: onDismiss,
          onMoveCursorForwardByCharacter: onMoveCursorForwardByCharacter,
          onMoveCursorBackwardByCharacter: onMoveCursorBackwardByCharacter,
          onSetSelection: onSetSelection,
          onSetText: onSetText,
          onDidGainAccessibilityFocus: onDidGainAccessibilityFocus,
          onDidLoseAccessibilityFocus: onDidLoseAccessibilityFocus,
          customSemanticsActions: customSemanticsActions,
        ) {}

  /// Semantics Semantics.fromProperties({Key? key, Widget? child, bool container = false, bool explicitChildNodes = false, bool excludeSemantics = false, required SemanticsProperties properties})
  Semantics$Mate.fromProperties({
    /// param: {Key? key}
    Key? key,

    /// param: {Widget? child}
    Widget? child,

    /// param: {bool container = false}
    required bool container,

    /// param: {bool explicitChildNodes = false}
    required bool explicitChildNodes,

    /// param: {bool excludeSemantics = false}
    required bool excludeSemantics,

    /// param: {required SemanticsProperties properties}
    required SemanticsProperties properties,
  }) : super.fromProperties(
          key: key,
          child: child,
          container: container,
          explicitChildNodes: explicitChildNodes,
          excludeSemantics: excludeSemantics,
          properties: properties,
        ) {}
}

/// class MergeSemantics extends SingleChildRenderObjectWidget
class MergeSemantics$Mate extends MergeSemantics {
  /// MergeSemantics MergeSemantics({Key? key, Widget? child})
  MergeSemantics$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          child: child,
        ) {}
}

/// class BlockSemantics extends SingleChildRenderObjectWidget
class BlockSemantics$Mate extends BlockSemantics {
  /// BlockSemantics BlockSemantics({Key? key, bool blocking = true, Widget? child})
  BlockSemantics$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {bool blocking = true}
    required bool blocking,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          blocking: blocking,
          child: child,
        ) {}
}

/// class ExcludeSemantics extends SingleChildRenderObjectWidget
class ExcludeSemantics$Mate extends ExcludeSemantics {
  /// ExcludeSemantics ExcludeSemantics({Key? key, bool excluding = true, Widget? child})
  ExcludeSemantics$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {bool excluding = true}
    required bool excluding,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          excluding: excluding,
          child: child,
        ) {}
}

/// class IndexedSemantics extends SingleChildRenderObjectWidget
class IndexedSemantics$Mate extends IndexedSemantics {
  /// IndexedSemantics IndexedSemantics({Key? key, required int index, Widget? child})
  IndexedSemantics$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required int index}
    required int index,

    /// param: {Widget? child}
    Widget? child,
  }) : super(
          key: key,
          index: index,
          child: child,
        ) {}
}

/// class KeyedSubtree extends StatelessWidget
class KeyedSubtree$Mate extends KeyedSubtree {
  /// KeyedSubtree KeyedSubtree({Key? key, required Widget child})
  KeyedSubtree$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required Widget child}
    required Widget child,
  }) : super(
          key: key,
          child: child,
        ) {}
}

/// class Builder extends StatelessWidget
class Builder$Mate extends Builder {
  /// Builder Builder({Key? key, required Widget Function(BuildContext) builder})
  Builder$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required Widget Function(BuildContext) builder}
    required WidgetBuilder builder,
  }) : super(
          key: key,
          builder: builder,
        ) {}
}

/// class StatefulBuilder extends StatefulWidget
class StatefulBuilder$Mate extends StatefulBuilder {
  /// StatefulBuilder StatefulBuilder({Key? key, required Widget Function(BuildContext, void Function(void Function())) builder})
  StatefulBuilder$Mate({
    /// param: {Key? key}
    Key? key,

    /// param: {required Widget Function(BuildContext, void Function(void Function())) builder}
    required StatefulWidgetBuilder builder,
  }) : super(
          key: key,
          builder: builder,
        ) {}
}

/// class ColoredBox extends SingleChildRenderObjectWidget
class ColoredBox$Mate extends ColoredBox {
  /// ColoredBox ColoredBox({required Color color, Widget? child, Key? key})
  ColoredBox$Mate({
    /// param: {required Color color}
    required Color color,

    /// param: {Widget? child}
    Widget? child,

    /// param: {Key? key}
    Key? key,
  }) : super(
          color: color,
          child: child,
          key: key,
        ) {}
}
